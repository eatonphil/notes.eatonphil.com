<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Notes on software, organizations, product development, and professional growth</title><link>http://notes.eatonphil.com/</link><description>Notes on software, organizations, product development, and professional growth</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><language>en</language><lastBuildDate>Sat, 13 Nov 2021 23:58:57 +0000</lastBuildDate><item><title>Benchmarking esbuild, swc, tsc, and babel for React/JSX projects</title><link>http://notes.eatonphil.com/benchmarking-esbuild-swc-typescript-babel.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-11-13-benchmarking-esbuild-swc-typescript-babel.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-11-13-benchmarking-esbuild-swc-typescript-babel.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/benchmarking-esbuild-swc-typescript-babel.html</guid><pubDate>Sat, 13 Nov 2021 00:00:00 +0000</pubDate></item><item><title>Building a fast SCSS-like rule expander for CSS using fuzzy parsing</title><link>http://notes.eatonphil.com/building-a-nested-css-rule-expander.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-10-31-building-a-nested-css-rule-expander.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-10-31-building-a-nested-css-rule-expander.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/building-a-nested-css-rule-expander.html</guid><pubDate>Sun, 31 Oct 2021 00:00:00 +0000</pubDate></item><item><title>Exploring PL/pgSQL part two: implementing a Forth-like interpreter</title><link>http://notes.eatonphil.com/exploring-plpgsql-forth-like.html</link><description>&lt;p class="note"&gt;
  Previously in exploring PL/pgSQL:
  &lt;br /&gt;
  &lt;a href="exploring-plpgsql.html"&gt;Strings, arrays, recursion and parsing JSON&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In my &lt;a href="https://notes.eatonphil.com/exploring-plpgsql.html"&gt;last post&lt;/a&gt;
I walked through the basics of PL/pgSQL, the embedded procedural
language inside of PostgreSQL. It covered simple functions, recursions
and parsing. But there was something very obviously missing from that
post: a working interpreter.&lt;/p&gt;
&lt;p&gt;So in this post we'll walk through building a Forth-like language from
scratch in PL/pgSQL. We'll be able to write a fibonacci function in
this Forth-like language and have it be evaluated correctly like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;
DEF fib
  DUP 1 &amp;gt; IF
  1- DUP 1- fib CALL SWAP fib CALL + THEN
  RET

20 fib CALL
EXIT&amp;#39;)&amp;quot;

...

 sm_run
--------
 6765
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All code is available on &lt;a href="https://github.com/eatonphil/exploring-plpgsql/blob/main/sm.sql"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="forth"&gt;Forth&lt;/h3&gt;&lt;p&gt;&lt;a href="https://www.forth.com/resources/forth-programming-language/"&gt;Forth&lt;/a&gt;
is a stack-oriented language. Literals are pushed onto the stack.
Functions and builtins operate on the stack.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;3 2 + EXIT&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will produce &lt;code&gt;5&lt;/code&gt;. And:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;3 2 + 1 - EXIT&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will produce &lt;code&gt;4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Our code will notably not be a real Forth, since there are many
special features of a real Forth. But it will look like one to a
novice Forth programmer like myself.&lt;/p&gt;
&lt;p&gt;You can read more about Forth basics
&lt;a href="https://skilldrick.github.io/easyforth/"&gt;here&lt;/a&gt;. And you can read a
truly stunning, real Forth implementation in
&lt;a href="https://github.com/nornagon/jonesforth/blob/master/jonesforth.S"&gt;jonesforth.S&lt;/a&gt;. Or
you can pick up &lt;a href="https://letoverlambda.com/"&gt;Let Over Lambda&lt;/a&gt; for a
fantastic book on Common Lisp that culminates in a Forth interpreter.&lt;/p&gt;
&lt;h3 id="implementation"&gt;Implementation&lt;/h3&gt;&lt;p&gt;Since the builtin &lt;code&gt;array_length($arr, $dim)&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt; if the
array is &lt;code&gt;NULL&lt;/code&gt; and our dimension is always 1, we'll write a helper.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;DROP FUNCTION IF EXISTS sm_alength;
CREATE FUNCTION sm_alength(a text[]) RETURNS int AS $$
BEGIN
  RETURN COALESCE(array_length(a, 1), 0);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll also need to bring in the &lt;code&gt;hstore&lt;/code&gt; extension so we can map
function names to their positions. (We could use an association list
but those are less programmer-friendly.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE EXTENSION IF NOT EXISTS hstore;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our interpreter function will take a string to evaluate, splitting the
string on whitespace into tokens.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;DROP FUNCTION IF EXISTS sm_run;
CREATE FUNCTION sm_run(s text) RETURNS TEXT AS $$
DECLARE
  tokens text[] = regexp_split_to_array(s, &amp;#39;\s+&amp;#39;);
  stack text[]; -- Data stack
  defs hstore; -- Map of functions to location
  tmps text[]; -- Array we can use for temporary variables
  token text; -- Current token
  rps text[]; -- Return pointer stack, always ints but easier to store as text
  pc int = 1; -- Program counter
BEGIN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We set up a &lt;code&gt;tmps&lt;/code&gt; array because each builtin may need differing
number of temporary variables and PL/pgSQL makes ad-hoc variables
cumbersome (or at least an easier way exists outside my knowledge).&lt;/p&gt;
&lt;p&gt;And we store the return pointer stack as a text array so that we can
use &lt;code&gt;sm_alength&lt;/code&gt; on it even though values in this array will always be
integers.&lt;/p&gt;
&lt;p&gt;Next we'll start an infinite loop to evaluate the program. The only thing
that will stop the input is the &lt;code&gt;EXIT&lt;/code&gt; builtin that will return from
this function with the top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;  WHILE true LOOP
    token = tokens[pc];
    RAISE NOTICE &amp;#39;[Debug] Current token: %. Current stack: %.&amp;#39;, token, stack;
    IF token IS NULL THEN
      RAISE EXCEPTION &amp;#39;PC out of bounds.&amp;#39;;
    END IF;

    IF token = &amp;#39;EXIT&amp;#39; THEN
      RETURN stack[sm_alength(stack)];
    END IF;

    ... TODO ...

    stack = array_append(stack, token);
    pc = pc + 1;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If no other condition is met (the token is not a builtin), we push it
onto the data stack and increment the program counter.&lt;/p&gt;
&lt;h3 id="conditionals"&gt;Conditionals&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;IF&lt;/code&gt; builtin pops the top of the stack. If it is true evaluation
continues. If it is false evaluation skips ahead until after a &lt;code&gt;THEN&lt;/code&gt;
builtin.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;1 1 1 = IF 2 THEN EXIT&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Produces &lt;code&gt;2&lt;/code&gt;. But&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;1 1 0 = IF 2 THEN EXIT&amp;#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Produces &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="implementation"&gt;Implementation&lt;/h3&gt;&lt;p&gt;Joining the &lt;code&gt;EXIT&lt;/code&gt; condition in the interpeter loop we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;...

  WHILE true LOOP

    ...

    IF token = &amp;#39;IF&amp;#39; THEN
      -- Grab last item from stack
      tmps[1] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      IF NOT tmps[1]::boolean THEN
        WHILE tokens[pc] &amp;lt;&amp;gt; &amp;#39;THEN&amp;#39; LOOP
      pc = pc + 1;
    END LOOP;
    pc = pc + 1; -- Skip past THEN
      ELSE
        pc = pc + 1;
      END IF;
      CONTINUE;
    END IF;

    IF token = &amp;#39;THEN&amp;#39; THEN
      -- Just skip past it
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;EXIT&amp;#39; THEN
      RETURN stack[sm_alength(stack)];
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="other-builtins"&gt;Other builtins&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;DUP&lt;/code&gt; builtin makes a copy of the top of the stack. The &lt;code&gt;SWAP&lt;/code&gt;
builtin swaps the order of the top two items on the stack. And the
&lt;code&gt;1-&lt;/code&gt; builtin subtracts 1 from the top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    ...

    IF token = &amp;#39;DUP&amp;#39; THEN
      -- Grab item
      tmps[1] = stack[sm_alength(stack)];
      -- Add it to the stack
      stack = array_append(stack, tmps[1]);
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;1-&amp;#39; THEN
      -- Grab item
      tmps[1] = stack[sm_alength(stack)];
      -- Rewrite top of stack
      stack[sm_alength(stack)] = tmps[1]::int - 1;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;SWAP&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Swap the two
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1];
      stack[sm_alength(stack) - 1] = tmps[2];
      pc = pc + 1;
      CONTINUE;
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's important that every builtin handle incrementing the program
counter and skipping to the beginning of the loop. Because some
builtins increment the program counter under different conditions
(like &lt;code&gt;IF&lt;/code&gt; above).&lt;/p&gt;
&lt;p&gt;The last few builtins are the simplest: arithmetic operations that
produce integers or booleans.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    ...

    IF token = &amp;#39;=&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int = tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;&amp;gt;&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int &amp;gt; tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;+&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int + tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;-&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int - tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;*&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int * tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    IF token = &amp;#39;/&amp;#39; THEN
      -- Grab two items from stack
      tmps[1] = stack[sm_alength(stack) - 1];
      tmps[2] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Replace last item on stack
      stack[sm_alength(stack)] = tmps[1]::int / tmps[2]::int;
      pc = pc + 1;
      CONTINUE;
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="function-definitions"&gt;Function definitions&lt;/h3&gt;&lt;p&gt;Functions here will differ from Forth, borrowing elements of machine
code. Return pointers will be stored in a dedicated return pointer
stack. We could store it on the data stack but that would require more
effort on the part of the programmer to restore the stack. Calling
&lt;code&gt;RET&lt;/code&gt; inside a function pops a return pointer off the return pointer
stack.&lt;/p&gt;
&lt;p&gt;Here's a simple function definition: &lt;code&gt;DEF plus + RET&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    ...

    IF token = &amp;#39;DEF&amp;#39; THEN
      tmps[1] = tokens[pc+1]; -- function name
      tmps[2] = pc + 2; -- starting pc
      WHILE tokens[pc] &amp;lt;&amp;gt; &amp;#39;RET&amp;#39; LOOP
        -- RAISE NOTICE &amp;#39;[Debug] skipping past: %.&amp;#39;, tokens[pc];
        pc = pc + 1;
      END LOOP;

      IF defs IS NULL THEN
        defs = hstore(tmps[1], tmps[2]);
      ELSE
        defs = defs || hstore(tmps[1], tmps[2]);
      END IF;
      pc = pc + 1; -- continue past &amp;#39;RET&amp;#39;
      CONTINUE;
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There doesn't seem to be a way to combine a NULL hstore value and a
non-NULL hstore value. So that's why we need that special case.&lt;/p&gt;
&lt;h3 id="return"&gt;Return&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;RET&lt;/code&gt; builtin pops a value off the return pointer stack and jumps
to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;   ...

   IF token = &amp;#39;RET&amp;#39; THEN
      -- Grab last return pointer
      tmps[1] = rps[sm_alength(rps)];
      -- Drop last return pointer from stack
      rps = rps[1:sm_alength(rps) - 1];
      -- Jump to last return pointer
      pc = tmps[1]::int;
      CONTINUE;
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="function-calls"&gt;Function calls&lt;/h3&gt;&lt;p&gt;Forming the other half of function calls is the &lt;code&gt;CALL&lt;/code&gt; builtin. This
places the program counter (plus one, past the &lt;code&gt;CALL&lt;/code&gt; token) onto the
return pointer stack and jumps to the position of the function if it
exists.&lt;/p&gt;
&lt;p&gt;A simple function call for the above &lt;code&gt;plus&lt;/code&gt; function might be: &lt;code&gt;2 3
plus CALL&lt;/code&gt; and would produce &lt;code&gt;5&lt;/code&gt; on the top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    ...

    IF token = &amp;#39;CALL&amp;#39; THEN
      -- Grab item
      tmps[1] = stack[sm_alength(stack)];
      -- Remove one item from stack
      stack = stack[1:sm_alength(stack) - 1];
      -- Store return pointer
      rps = array_append(rps, (pc + 1)::text);
      -- Fail if function not defined
      IF NOT defs?tmps[1] THEN
        RAISE EXCEPTION &amp;#39;No such function, %.&amp;#39;, tmps[1];
      END IF;
      -- Otherwise jump to function
      RAISE NOTICE &amp;#39;[Debug] Jumping to: %:%.&amp;#39;, tmps[1], defs-&amp;gt;tmps[1];
      pc = defs-&amp;gt;tmps[1];
      CONTINUE;
    END IF;

    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it! All done the basic instructions needed. Store all that code in &lt;code&gt;sm.sql&lt;/code&gt; and grab the &lt;code&gt;test.sh&lt;/code&gt; code from the previous post:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat ./test.sh
sudo -u postgres psql -c &amp;quot;$(printf &amp;quot;%s;\n%s&amp;quot; &amp;quot;$(cat $1)&amp;quot; &amp;quot;$2&amp;quot;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And try out our port of recursive fibonacci:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh sm.sql &amp;quot;SELECT sm_run(&amp;#39;
DEF fib
  DUP 1 &amp;gt; IF
  1- DUP 1- fib CALL SWAP fib CALL + THEN
  RET

20 fib CALL
EXIT&amp;#39;)&amp;quot;

...

 sm_run
--------
 6765
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Happy PL/pgSQL- and Forth-ish-ing!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post is up! Writing a Forth(-inspired language) implementation from scratch in PL/pgSQL. Because who doesn&amp;#39;t want to be able to run stack machine code from SELECT statements in PostgreSQL?&lt;a href="https://t.co/sbxhuDp1J9"&gt;https://t.co/sbxhuDp1J9&lt;/a&gt; &lt;a href="https://t.co/9nrHEIhRPa"&gt;pic.twitter.com/9nrHEIhRPa&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1453958284109500417?ref_src=twsrc%5Etfw"&gt;October 29, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/exploring-plpgsql-forth-like.html</guid><pubDate>Fri, 29 Oct 2021 00:00:00 +0000</pubDate></item><item><title>Exploring PL/pgSQL: Strings, arrays, recursion, and parsing JSON</title><link>http://notes.eatonphil.com/exploring-plpgsql.html</link><description>&lt;p class="note"&gt;
  Next in exploring PL/pgSQL:
  &lt;br /&gt;
  &lt;a href="exploring-plpgsql-forth-like.html"&gt;Implementing a Forth-like interpreter&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;PostgreSQL comes with a builtin imperative programming language called
PL/pgSQL. I used to think this language was scary because it has a bit
more adornment than your usual language does. But looking deeper, it's
actually reasonably pleasant to program in.&lt;/p&gt;
&lt;p&gt;In this post we'll get familiar with it by working with strings,
arrays and recursive functions. We'll top it all off by building a
parser for a subset of JSON (no nested objects, no arrays, no unicode,
no decimals).&lt;/p&gt;
&lt;p&gt;The goal here is not production-quality code (an amazing JSON library
is already built into PostgreSQL) but simply to get more familiar with
the PL/pgSQL language.&lt;/p&gt;
&lt;p&gt;All code for this post is available on &lt;a href="https://github.com/eatonphil/exploring-plpgsql"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="creating-functions"&gt;Creating functions&lt;/h3&gt;&lt;p&gt;Functions are declared like tables. Here's a very simple one that
returns the length of a string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION slength(s text) RETURNS int AS $$
BEGIN
  RETURN length(s);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's not a very useful function because &lt;code&gt;length&lt;/code&gt; already exists but
the point is to see a basic custom function.&lt;/p&gt;
&lt;p&gt;All statements in PL/pgSQL must end in a statement. Arguments do not
have to be named. If they are not named they get default names of &lt;code&gt;$1&lt;/code&gt;
to &lt;code&gt;$N&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="named/unnamed-arguments"&gt;Named/unnamed arguments&lt;/h4&gt;&lt;p&gt;Here's how the function could be written without named arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION slength(text) RETURNS int AS $$
BEGIN
  RETURN length($1);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="out-declarations"&gt;Out declarations&lt;/h4&gt;&lt;p&gt;PL/pgSQL also allows you to declare which variables will be returned
in the function argument list. They call it OUT parameters but as far
as I can tell it is not like OUT parameters in C# where you are
modifying the value of a variable in an external scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION slength(s text, OUT i int) RETURNS int AS $$
BEGIN
  i = length(s);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is still equivalent to the first function and is basically a shortcut for:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION slength(s text) RETURNS int AS $$
DECLARE
  i int;
BEGIN
  i = length(s);
  RETURN i;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whether you declare OUT or not you still must include &lt;code&gt;RETURNS &amp;lt;type&amp;gt;&lt;/code&gt;
in the function signature otherwise even if you call &lt;code&gt;RETURN&lt;/code&gt; in the
body, the result will just be ignored.&lt;/p&gt;
&lt;p&gt;Don't worry about case sensitivity too much. It's really only
important, as in typical SQL, for mixed-case table and column
names. But we won't be dealing with that situation in this article
focused on programming PL/pgSQL.&lt;/p&gt;
&lt;h4 id="testing-it-out"&gt;Testing it out&lt;/h4&gt;&lt;p&gt;Once the function is created, you can call it like &lt;code&gt;SELECT
slength('foo');&lt;/code&gt;. So here's a helper script to load a SQL file and run
a command:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat ./test.sh
sudo -u postgres psql -c &amp;quot;$(printf &amp;quot;%s;\n%s&amp;quot; &amp;quot;$(cat $1)&amp;quot; &amp;quot;$2&amp;quot;)&amp;quot;
$ chmod +x ./test.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After storing the above &lt;code&gt;slength&lt;/code&gt; code in &lt;code&gt;slength.sql&lt;/code&gt; we can run a test:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;$ ./test.sh ./slength.sql &amp;quot;SELECT slength(&amp;#39;foo&amp;#39;)&amp;quot;
 slength
---------
       3
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Easy!&lt;/p&gt;
&lt;h3 id="numbers-and-recursion"&gt;Numbers and recursion&lt;/h3&gt;&lt;p&gt;Ok now that we've got the basics of function definition down and a way
to test the code, let's write a fibonacci program.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat ./fib.sql
CREATE OR REPLACE FUNCTION fib(i int) RETURNS int AS $$
BEGIN
  IF i = 0 OR i = 1 THEN
    RETURN i;
  END IF;

  RETURN fib(i - 1) + fib(i - 2);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything in the if test is normal SQL WHERE clause syntax. This
makes it very easy for folks familiar with SQL to pick up conditionals
in PL/pgSQL.&lt;/p&gt;
&lt;p&gt;And there's no special syntax to allow function recursion. Nice!&lt;/p&gt;
&lt;p&gt;Run and test this function:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ./test.sh ./fib.sql "SELECT fib(10)"
 fib
-----
  55
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Getting the hang of it?&lt;/p&gt;
&lt;h3 id="strings-and-arrays"&gt;Strings and arrays&lt;/h3&gt;&lt;p&gt;You may have noticed that &lt;code&gt;length&lt;/code&gt; used in &lt;code&gt;slength&lt;/code&gt; is a builtin
PostgreSQL function for dealing with strings. All builtin functions in
PostgreSQL can be used in PL/pgSQL.&lt;/p&gt;
&lt;p&gt;In order to get familiar with using arrays in PL/pgSQL let's write a
&lt;code&gt;string_to_array&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;$ cat ./string_to_array.sql
CREATE OR REPLACE FUNCTION string_to_array(s text) RETURNS char[] AS $$
DECLARE
  a char[];
BEGIN
  WHILE COALESCE(array_length(a, 1), 0) &amp;lt; length(s) LOOP
    a[COALESCE(array_length(a, 1), 0) + 1] = substr(s, COALESCE(array_length(a, 1), 0) + 1, 1);
  END LOOP;
  RETURN a;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is one way to do it by modify array values directly by index. We
need to coalesce because calling &lt;code&gt;array_length&lt;/code&gt; on an empty array
returns &lt;code&gt;NULL&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another way to do this is by calling the builtin function &lt;code&gt;array_append&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION string_to_array(s text) RETURNS char[] AS $$
DECLARE
  a char[];
BEGIN
  WHILE COALESCE(array_length(a, 1), 0) &amp;lt; length(s) LOOP
    a = array_append(a, substr(s, COALESCE(array_length(a, 1), 0) + 1, 1)::char);
  END LOOP;
  RETURN a;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can test and run both:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./test.sh ./string_to_array.sql &amp;quot;SELECT string_to_array(&amp;#39;foo&amp;#39;)&amp;quot;
 string_to_array
-----------------
 {f,o,o}
(1 row)
$ ./test.sh ./string_to_array2.sql &amp;quot;SELECT string_to_array(&amp;#39;foo&amp;#39;)&amp;quot;
 string_to_array
-----------------
 {f,o,o}
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course the builtin alternative might be &lt;code&gt;SELECT
regexp_split_to_array('foo')&lt;/code&gt; but we need the practice.&lt;/p&gt;
&lt;h3 id="custom-compound-types"&gt;Custom compound types&lt;/h3&gt;&lt;p&gt;If we're going to lex and parse JSON, we're going to want to return an
array of tokens from the lexer. A token will need to contain the type
(e.g. number, string, syntax) and the string value of the token
(e.g. &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;my great key&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;PostgreSQL allows us to create compound types that we can then use as
the base of an array:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;DROP TYPE IF EXISTS json_token CASCADE;
CREATE TYPE json_token AS (
  kind text,
  value text
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to add &lt;code&gt;CASCADE&lt;/code&gt; here because functions will have this type in
their signature and it otherwise makes PostgreSQL unhappy to delete
the type used in a function before deleting the function.&lt;/p&gt;
&lt;p&gt;We can create literals of this type like &lt;code&gt;SELECT ('number',
'12')::json_token)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now we're ready to build out the lexer.&lt;/p&gt;
&lt;h3 id="lexing"&gt;Lexing&lt;/h3&gt;&lt;p&gt;The lexers job is to clump together groups of characters into tokens.&lt;/p&gt;
&lt;p&gt;I'm going to describe this function in literate code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION json_lex(j text, OUT ts json_token[]) RETURNS json_token[] AS $$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function takes a string in and returns an array of json tokens.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;DECLARE 
  i int = 1; -- Index in loop
  c text; -- Current character in loop
  token text; -- Current accumulated characters
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to declare all variables up front.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;BEGIN
  WHILE i &amp;lt; length(j) + 1 LOOP
    c = substr(j, i, 1);
    token = &amp;#39;&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The main loop just looks at all characters.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    -- Handle syntax characters
    IF c = &amp;#39;{&amp;#39; OR c = &amp;#39;}&amp;#39; OR c = &amp;#39;,&amp;#39; OR c = &amp;#39;:&amp;#39; THEN
      ts = array_append(ts, (&amp;#39;syntax&amp;#39;, c)::json_token);
      i = i + 1;
      CONTINUE;
    END IF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First we look if the character is a syntax character. If it is we
append it to the array of tokens, increment the index, and go back to
the start of the main loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    -- Handle whitespace
    IF regexp_replace(c, &amp;#39;^\s+&amp;#39;, &amp;#39;&amp;#39;) = &amp;#39;&amp;#39; THEN
      i = i + 1;
      CONTINUE;
    END IF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we check for whitespace characters. If replacing all whitespace
characters returns an empty string then we know it's whitespace. We
could also have done something like &lt;code&gt;IF c = ' ' OR c = '\n'
... THEN&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;Same as before though if we find whitespace characters we move on
(don't accumulate them) and restart the main loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    -- Handle strings
    IF c = &amp;#39;&amp;quot;&amp;#39; THEN
      i = i + 1;
      c = substr(j, i, 1);
      WHILE c &amp;lt;&amp;gt; &amp;#39;&amp;quot;&amp;#39; LOOP
        token = token || c;
        i = i + 1;
        c = substr(j, i, 1);
      END LOOP;

      i = i + 1;
      ts = array_append(ts, (&amp;#39;string&amp;#39;, token)::json_token);
      CONTINUE;
    END IF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we loop through any strings we find and accumulate them as tokens
before restarting the main loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    -- Handle numbers
    WHILE c ~ &amp;#39;^[0-9]+$&amp;#39; LOOP
      token = token || c;
      i = i + 1;
      c = substr(j, i, 1);
    END LOOP;
    IF length(token) &amp;gt; 0 THEN
      ts = array_append(ts, (&amp;#39;number&amp;#39;, token)::json_token);
      CONTINUE;
    END IF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we look for integers.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    RAISE EXCEPTION &amp;#39;Unknown character: %, at index: %; already found: %.&amp;#39;, c, i, ts;
  END LOOP;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lastly if none of those lexing handlers match, we give up! Then the
loop is done and the function is too.&lt;/p&gt;
&lt;p&gt;There's no &lt;code&gt;RETURN&lt;/code&gt; statement because we already declared an &lt;code&gt;OUT&lt;/code&gt;
variable.&lt;/p&gt;
&lt;p&gt;If we test and run this now:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./test.sh ./json.sql &amp;quot;SELECT json_lex(&amp;#39;{\&amp;quot;flubberty\&amp;quot;: 12, \&amp;quot;nice\&amp;quot;: \&amp;quot;a\&amp;quot;}&amp;#39;)&amp;quot;
                                                                json_lex
----------------------------------------------------------------------------------------------------------------------------------------
 {&amp;quot;(syntax,{)&amp;quot;,&amp;quot;(string,flubberty)&amp;quot;,&amp;quot;(syntax,:)&amp;quot;,&amp;quot;(number,12)&amp;quot;,&amp;quot;(syntax,\&amp;quot;,\&amp;quot;)&amp;quot;,&amp;quot;(string,nice)&amp;quot;,&amp;quot;(syntax,:)&amp;quot;,&amp;quot;(string,a)&amp;quot;,&amp;quot;(syntax,})&amp;quot;}
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's messy but it worked! Now on to parsing.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;Our parser will only accept JSON objects. JSON objects will be defined
as an array of key-value pairs. Custom types make this nice again.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;DROP TYPE IF EXISTS json_key_value CASCADE;
CREATE TYPE json_key_value AS (
  k text,
  v text
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One thing PostgreSQL does not make nice is sum types or parametric
types. But even if the value here is stored as text it can be easily
cast to a number by the user. And again, we're not going to support
nested objects/arrays. But using &lt;code&gt;hstore&lt;/code&gt; for key-values might be the
better alternative if we wanted to build a real JSON parser.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION json_parse(ts json_token[], i int) RETURNS json_key_value[] AS $$
DECLARE
  t json_token; -- Current token in tokens loop
  kvs json_key_value[];
  k text;
BEGIN
  t = ts[i];

  IF t.kind &amp;lt;&amp;gt; &amp;#39;syntax&amp;#39; OR t.value &amp;lt;&amp;gt; &amp;#39;{&amp;#39; THEN
    RAISE EXCEPTION &amp;#39;Invalid JSON, must be an object, got: %.&amp;#39;, t;
  END IF;
  i = i + 1;
  t = ts[i];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First up in the parser is variable declarations and validating that
this list of tokens represents a JSON object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;  WHILE t.kind &amp;lt;&amp;gt; &amp;#39;syntax&amp;#39; OR t.value &amp;lt;&amp;gt; &amp;#39;}&amp;#39; LOOP
    IF array_length(kvs, 1) &amp;gt; 0 THEN
      IF t.kind &amp;lt;&amp;gt; &amp;#39;syntax&amp;#39; OR t.value &amp;lt;&amp;gt; &amp;#39;,&amp;#39; THEN
        RAISE EXCEPTION &amp;#39;JSON key-value pair must be followed by a comma or closing brace, got: %.&amp;#39;, t;
      END IF;

      i = i + 1;
      t = ts[i];
    END IF;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we loop to find each key-value pair. If one has already been
found, we need to find a comma before the next pair.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;    IF t.kind &amp;lt;&amp;gt; &amp;#39;string&amp;#39; THEN
      RAISE EXCEPTION &amp;#39;JSON object must start with string key, got: %.&amp;#39;, t;
    END IF;
    k = t.value;

    i = i + 1;
    t = ts[i];
    IF t.kind &amp;lt;&amp;gt; &amp;#39;syntax&amp;#39; OR t.value &amp;lt;&amp;gt; &amp;#39;:&amp;#39; THEN
      RAISE EXCEPTION &amp;#39;JSON object must start with string key followed by colon, got: %.&amp;#39;, t;
    END IF;

    i = i + 1;
    t = ts[i];
    IF t.kind = &amp;#39;number&amp;#39; OR t.kind = &amp;#39;string&amp;#39; THEN
      kvs = array_append(kvs, (k, t)::json_key_value);
      i = i + 1;
      t = ts[i];
      CONTINUE;
    END IF;

    RAISE EXCEPTION &amp;#39;Invalid key-value pair syntax, got: %.&amp;#39;, t;
  END LOOP;

  RETURN kvs;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we just look for the key, colon, value syntax and fail if we
don't see it. And that's it! Very simple when not dealing with arrays
and nested objects.&lt;/p&gt;
&lt;h3 id="helpers"&gt;Helpers&lt;/h3&gt;&lt;p&gt;Lastly it would just be nice to have a single function that calls lex and parse:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION json_from_string(s text) RETURNS json_key_value[] AS $$
BEGIN
  RETURN json_parse(json_lex(s), 1);
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And another function to look up a value in a parsed object by key:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;CREATE OR REPLACE FUNCTION json_get(kvs json_key_value[], key text) RETURNS text AS $$
DECLARE
  kv json_key_value;
BEGIN
  FOREACH kv IN ARRAY kvs LOOP
    IF kv.k = key THEN RETURN (kv.v::json_token).value; END IF;
  END LOOP;

  RAISE EXCEPTION &amp;#39;Key not found.&amp;#39;;
END;
$$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're all set!&lt;/p&gt;
&lt;h3 id="testing"&gt;Testing&lt;/h3&gt;&lt;p&gt;Let's try some bad syntax (missing a comma between pairs):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./test.sh ./json.sql &amp;quot;SELECT json_get(json_from_string(&amp;#39;{\&amp;quot;flubberty\&amp;quot;: 12 \&amp;quot;nice\&amp;quot;: \&amp;quot;a\&amp;quot;}&amp;#39;), &amp;#39;ipo&amp;#39;)&amp;quot;
ERROR:  JSON key-value pair must be followed by a comma or closing brace, got: (string,nice).
CONTEXT:  PL/pgSQL function json_parse(json_token[],integer) line 18 at RAISE
PL/pgSQL function json_from_string(text) line 3 at RETURN
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sweet, it fails correctly.&lt;/p&gt;
&lt;p&gt;Now correct syntax but missing key:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./test.sh ./json.sql &amp;quot;SELECT json_get(json_from_string(&amp;#39;{\&amp;quot;flubberty\&amp;quot;: 12, \&amp;quot;nice\&amp;quot;: \&amp;quot;a\&amp;quot;}&amp;#39;), &amp;#39;ipo&amp;#39;)&amp;quot;
ERROR:  Key not found.
CONTEXT:  PL/pgSQL function json_get(json_key_value[],text) line 9 at RAISE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, correct syntax and existing key:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./test.sh ./json.sql &amp;quot;SELECT json_get(json_from_string(&amp;#39;{\&amp;quot;flubberty\&amp;quot;: 12, \&amp;quot;nice\&amp;quot;: \&amp;quot;a\&amp;quot;}&amp;#39;), &amp;#39;flubberty&amp;#39;)&amp;quot;
 json_get
----------
 12
(1 row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Huzzah! Now hopefully PL/pgSQL is a little less scary to you, whether
or not you decide to use it.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;For everyone dying to write imperative code in PostgreSQL, I wrote a post about PL/pgSQL 👽 It starts with implementing simple string and array functions, to recursive Fibonacci, to a small JSON parsing library. A nice little language with a great stdlib!&lt;a href="https://t.co/m4Tff99N6R"&gt;https://t.co/m4Tff99N6R&lt;/a&gt; &lt;a href="https://t.co/2ZMJn2foNa"&gt;pic.twitter.com/2ZMJn2foNa&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1452339113131139072?ref_src=twsrc%5Etfw"&gt;October 24, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/exploring-plpgsql.html</guid><pubDate>Sun, 24 Oct 2021 00:00:00 +0000</pubDate></item><item><title>Experimenting with column- and row-oriented datastructures</title><link>http://notes.eatonphil.com/experimenting-with-column-and-row-oriented-datastructures.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-10-18-experimenting-with-column-and-row-oriented-datastructures.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-10-18-experimenting-with-column-and-row-oriented-datastructures.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/experimenting-with-column-and-row-oriented-datastructures.html</guid><pubDate>Mon, 18 Oct 2021 00:00:00 +0000</pubDate></item><item><title>Notes on running Electron</title><link>http://notes.eatonphil.com/notes-on-running-electron.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-10-13-notes-on-running-electron.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-10-13-notes-on-running-electron.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/notes-on-running-electron.html</guid><pubDate>Wed, 13 Oct 2021 00:00:00 +0000</pubDate></item><item><title>Enumerating and analyzing 40+ non-V8 JavaScript implementations</title><link>http://notes.eatonphil.com/javascript-implementations.html</link><description>&lt;p&gt;V8 is, I'm sure, the most used implementation of JavaScript
today. Used in Chrome, (and by extension) Microsoft Edge, Node.js,
etc. Safari's JavaScriptCore and Firefox's SpiderMonkey are also
contenders for extremely mainstream implementations.&lt;/p&gt;
&lt;p&gt;But what else is out there? What if I want to embed JavaScript in a C
program, or a Go program, or a Rust program, or a Java program(, and
so on)? Or what if I want to run JavaScript on a microcontroller? Or
use it as a base for language research? It turns out there are many
high-quality implementations out there.&lt;/p&gt;
&lt;p&gt;This post describes a number of them and their implementation
choices. I'm not going to cover V8, JavaScriptCore, or SpiderMonkey
because they are massive and hide multiple various interpreters and
compilers inside. Plus, you already know about them.&lt;/p&gt;
&lt;p class="note"&gt;
  I'm going to miss some implementations and get some details
  wrong. Please &lt;a href="https://twitter.com/phil_eaton"&gt;Tweet&lt;/a&gt; or
  &lt;a href="mailto:phil@eatonphil.com"&gt;email&lt;/a&gt; me with your corrections! I'd be
  particularly interested to hear about pure-research; and commercial,
  closed-source implementations of JavaScript.
&lt;/p&gt;&lt;h3 id="corporate-backed"&gt;Corporate-backed&lt;/h3&gt;&lt;p&gt;These are implementations that would make sense to look into for your
own commercial, production applications.&lt;/p&gt;
&lt;h4 id="on-the-jvm"&gt;On the JVM&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/oracle/graaljs"&gt;Oracle's GraalJS&lt;/a&gt;: compiles JavaScript to JVM bytecode or GraalVM&lt;ul&gt;
&lt;li&gt;Support: Full compatibility with latest ECMAScript specification&lt;/li&gt;
&lt;li&gt;Implementation language: Java&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://www.graalvm.org/"&gt;GraalVM&lt;/a&gt; or &lt;a href="https://www.graalvm.org/reference-manual/js/RunOnJDK/"&gt;stock JDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/oracle/graaljs/blob/master/graal-js/src/com.oracle.js.parser/src/com/oracle/js/parser/Parser.java"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/oracle/graaljs/releases/tag/vm-19.0.0"&gt;2019?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Replaced Nashorn as the default JavaScript implementation in JDK.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mozilla/rhino"&gt;Mozilla's Rhino&lt;/a&gt;: interprets and compiles JavaScript to JVM bytecode&lt;ul&gt;
&lt;li&gt;Support: ES6&lt;/li&gt;
&lt;li&gt;Implementation language: Java&lt;/li&gt;
&lt;li&gt;Runtime: Both &lt;a href="https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/Interpreter.java"&gt;interpreted through custom bytecode VM&lt;/a&gt; and interpreted &lt;a href="https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/optimizer/Codegen.java"&gt;after compiling to JVM bytecode&lt;/a&gt; as an optimization&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/mozilla/rhino/blob/master/src/org/mozilla/javascript/Parser.java"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="http://udn.realityripple.com/docs/Mozilla/Projects/Rhino/History"&gt;1998?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Replaced by Nashorn as the default JavaScript engine on the JVM, but remains actively developed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/openjdk/nashorn"&gt;Oracle's Nashorn&lt;/a&gt;: compiles JavaScript to JVM bytecode&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: Java&lt;/li&gt;
&lt;li&gt;Runtime: compiles to &lt;a href="https://github.com/openjdk/nashorn/tree/main/src/org.openjdk.nashorn/share/classes/org/openjdk/nashorn/internal/codegen"&gt;JVM bytecode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/openjdk/nashorn/blob/main/src/org.openjdk.nashorn/share/classes/org/openjdk/nashorn/internal/parser/Parser.java"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://blogs.oracle.com/nashorn/open-for-business"&gt;2012?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Replaced Rhino as default JavaScript implementation on JVM. Replaced by GraalJS more recently, but remains actively developed.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="embeddable"&gt;Embeddable&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/nginx/njs"&gt;Nginx's njs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/nginx/njs/blob/master/src/njs_vmcode.c"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/nginx/njs/blob/master/src/njs_parser.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://mp2.dk/techblog/chowjs/"&gt;ChowJS&lt;/a&gt;: proprietary AOT compiler based on QuickJS for game developers&lt;ul&gt;
&lt;li&gt;Support: everything QuickJS does presumably (see further down for QuickJS)&lt;/li&gt;
&lt;li&gt;Implementation language: C presumably&lt;/li&gt;
&lt;li&gt;Runtime: QuickJS's bytecode interpreter but also an AOT compiler&lt;/li&gt;
&lt;li&gt;Parser: QuickJS's presumably&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://mp2.dk/techblog/chowjs/"&gt;2021&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Code is not available so exact analysis on these points is not possible at the moment.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ccxvii/mujs"&gt;Artifex's mujs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5, probably&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/ccxvii/mujs/blob/master/jsrun.c"&gt;Bytecode stack-oriented VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/ccxvii/mujs/blob/master/jsparse.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/ccxvii/mujs/releases/tag/1.0.0"&gt;2017?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Originally part of MuPDF viewer, but now broken out. Thanks to &lt;a href="https://twitter.com/rwoodsmall"&gt;@rwoodsmalljs&lt;/a&gt; for mentioning!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="embedded-systems"&gt;Embedded Systems&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Samsung/escargot"&gt;Samsung's Escargot&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES2020&lt;/li&gt;
&lt;li&gt;Implementation language: C++&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/Samsung/escargot/tree/master/src/interpreter"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/Samsung/escargot/tree/master/src/parser"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/Samsung/escargot/graphs/contributors"&gt;2017?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/espruino/Espruino"&gt;Espruino&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: parts of ES5, ES6, ES7/8&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: Seems like direct recursive interpreting without an AST/intermediate form&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/espruino/Espruino/blob/master/src/jsparse.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/espruino/Espruino/releases/tag/BEFORE_FUNCTION_REFACTOR"&gt;2012?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cesanta/elk"&gt;Cesanta's Elk&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: subset of ES6&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/cesanta/elk/blob/master/elk.c"&gt;Direct recursive interpreter without AST or bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/cesanta/elk/blob/master/elk.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/cesanta/elk/releases/tag/0.0.1"&gt;2019?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: It does all of this with a GC and FFI in &amp;lt;1400 lines of readable C code. Damn.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/cesanta/mjs"&gt;Cesanta's mJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: subset of ES6&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/cesanta/mjs/blob/master/mjs.c#L3411"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/cesanta/mjs/blob/master/mjs.c#L12780"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/cesanta/mjs/releases/tag/1.5"&gt;2017?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/Moddable-OpenSource/moddable/blob/public/xs/sources/xsSyntaxical.c"&gt;Moddable's XS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES2018&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/Moddable-OpenSource/moddable/blob/public/xs/sources/xsRun.c"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/Moddable-OpenSource/moddable/blob/public/xs/sources/xsSyntaxical.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://www.moddable.com/XS7-TC-39"&gt;2017?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: More details at &lt;a href="https://www.moddable.com/XS7-TC-39"&gt;https://www.moddable.com/XS7-TC-39&lt;/a&gt; and &lt;a href="https://www.moddable.com/faq#what-is-xs"&gt;https://www.moddable.com/faq#what-is-xs&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="other"&gt;Other&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/facebook/hermes"&gt;Facebook's Hermes&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES6 &lt;a href="https://hermesengine.dev/docs/language-features"&gt;with exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Implementation language: C++&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/facebook/hermes/tree/main/lib/VM"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/facebook/hermes/blob/main/lib/Parser/JSParserImpl.cpp"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/facebook/hermes/releases/tag/v0.0.1"&gt;2019?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/qt/qtdeclarative/tree/dev/src/qml/jsruntime"&gt;Qt's V4&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: C++&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/qt/qtdeclarative/blob/dev/src/qml/jsruntime/qv4vme_moth.cpp"&gt;Bytecode VM&lt;/a&gt; and JIT compiler&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/qt/qtdeclarative/blob/dev/src/qml/parser/qqmljs.g"&gt;qlalr custom parser generator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: 2013&lt;/li&gt;
&lt;li&gt;Notes: Unclear if can be run standalone outside of Qt.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I don't know whether to put Microsoft's ChakraCore into this list or
the next. So I'll put it here but note that as of this year 2021, they
are transitioning it to become a community-driven project.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/chakra-core/ChakraCore"&gt;Microsoft's ChakraCore&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES6, probably more&lt;/li&gt;
&lt;li&gt;Implementation language: C++&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/chakra-core/ChakraCore/tree/master/lib/Backend"&gt;Bytecode VM and JIT on x86/ARM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/chakra-core/ChakraCore/blob/master/lib/Parser/Parse.cpp"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: 2015?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="mature,-community-driven"&gt;Mature, community-driven&lt;/h3&gt;&lt;p&gt;Implementations toward the top are more reliable and
proven. Implementations toward the bottom less so.&lt;/p&gt;
&lt;p&gt;If you are a looking to get involved in language development, the
implementation further down on the list can be a great place to start
since they typically need work in documentation, testing, and language
features.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/bellard/quickjs"&gt;Fabrice Bellard's QuickJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES2020&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://raw.githubusercontent.com/bellard/quickjs/master/quickjs.c"&gt;Bytecode VM&lt;/a&gt; (this is a single large file)&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://raw.githubusercontent.com/bellard/quickjs/master/quickjs.c"&gt;Hand-written&lt;/a&gt; (this is a single large file)&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/bellard/quickjs/commit/91459fb6723e29e923380cec0023af93819ae69d#diff-ead07c84baac57a9542f388a07a2a5209456ce790b04251bc9bd7d179ea85cb1R84"&gt;2019&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/svaarala/duktape"&gt;DuktapeJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5, some parts of ES6/ES7&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/svaarala/duktape/blob/master/src-input/duk_js_executor.c"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/svaarala/duktape/blob/master/src-input/duk_js_compiler.c"&gt;Hand-written&lt;/a&gt;, notably with no AST. It just directly compiles to its own bytecode.&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://duktape.org/download.html"&gt;2013&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/engine262/engine262"&gt;engine262&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: 100% spec compliance&lt;/li&gt;
&lt;li&gt;Implementation language: JavaScript&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/engine262/engine262/blob/14f50592362d889289e133fff4200e8e304c995a/src/runtime-semantics/IfStatement.mjs"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/engine262/engine262/blob/main/src/parser/ExpressionParser.mjs"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jerryscript-project/jerryscript"&gt;JerryScript&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: C&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/jerryscript-project/jerryscript/blob/master/jerry-core/vm/vm.c"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/jerryscript-project/jerryscript/blob/master/jerry-core/parser/js/js-parser.c"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/jerryscript-project/jerryscript/releases/tag/v1.0"&gt;2016?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/SerenityOS/serenity/tree/master/Userland/Libraries/LibJS"&gt;Serenity's LibJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: &lt;a href="https://libjs.dev/test262/"&gt;Progressing toward compliance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Implementation language: C++&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/SerenityOS/serenity/tree/master/Userland/Libraries/LibJS/Bytecode"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/SerenityOS/serenity/blob/master/Userland/Libraries/LibJS/Parser.cpp"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Might also work outside of Serenity but documentation on building/running it on Linux is hard to find.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dop251/goja"&gt;goja&lt;/a&gt;: JavaScript interpreter for Go&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: Go&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/dop251/goja/blob/master/vm.go"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/dop251/goja/blob/master/parser/statement.go"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/dop251/goja/graphs/contributors"&gt;2017?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/robertkrimen/otto"&gt;otto&lt;/a&gt;: JavaScript interpreter for Go&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: Go&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/robertkrimen/otto/blob/373ff54384526e8336b5b597619d0923a4a83ae0/cmpl_evaluate_expression.go#L183"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/robertkrimen/otto/blob/master/parser/statement.go"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/robertkrimen/otto/graphs/contributors"&gt;2012?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: The AST interpreter-only implementation might suggest this implementation is slower than Goja. I don't have benchmarks for that.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/paulbartrum/jurassic"&gt;Jurassic&lt;/a&gt;: JavaScript parser and interpreter for .NET&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: C#&lt;/li&gt;
&lt;li&gt;Runtime: Compiles to &lt;a href="https://github.com/paulbartrum/jurassic/blob/ee6f4fa17e6205e15412a214b24d7575b0bd461c/Jurassic/Compiler/MethodGenerator/GlobalOrEvalMethodGenerator.cs#L139"&gt;.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/paulbartrum/jurassic/blob/master/Jurassic/Compiler/Parser/Parser.cs"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/paulbartrum/jurassic/graphs/contributors"&gt;2011?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/sebastienros/jint"&gt;Jint&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5, most of ES6/7/8&lt;/li&gt;
&lt;li&gt;Implementation language: C#&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/sebastienros/jint/blob/main/Jint/Runtime/Interpreter/Expressions/JintUnaryExpression.cs"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/sebastienros/esprima-dotnet/blob/main/src/Esprima/JavascriptParser.cs"&gt;Hand-written via Esprima.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/sebastienros/jint/graphs/contributors"&gt;2014?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: Thanks &lt;a href="https://news.ycombinator.com/user?id=fowl2"&gt;fowl2&lt;/a&gt; for mentioning!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/nilproject/NiL.JS"&gt;NiL.JS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES6&lt;/li&gt;
&lt;li&gt;Implementation language: C#&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/nilproject/NiL.JS/blob/develop/NiL.JS/Expressions/Assignment.cs"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/nilproject/NiL.JS/blob/develop/NiL.JS/Core/Parser.cs"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/nilproject/NiL.JS/graphs/contributors"&gt;2014?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/NeilFraser/JS-Interpreter"&gt;Neil Fraser's JS-Interpreter&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: JavaScript&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/NeilFraser/JS-Interpreter/blob/master/interpreter.js"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/NeilFraser/JS-Interpreter/blob/master/acorn.js"&gt;Hand-written, uses Acorn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/NeilFraser/JS-Interpreter/graphs/contributors"&gt;2014?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/BeRo1985/besen"&gt;BESEN&lt;/a&gt;: Bytecode VM and JIT compiler in Object Pascal&lt;ul&gt;
&lt;li&gt;Support: ES5&lt;/li&gt;
&lt;li&gt;Implementation language: Object Pascal&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/BeRo1985/besen/blob/master/src/BESENCode.pas"&gt;Bytecode VM&lt;/a&gt; with &lt;a href="https://github.com/BeRo1985/besen/blob/master/src/BESENCodeJITx86.pas"&gt;JIT for x86&lt;/a&gt; and &lt;a href="https://github.com/BeRo1985/besen/blob/master/src/BESENCodeJITx64.pas"&gt;x86_64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/BeRo1985/besen/blob/master/src/BESENParser.pas"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/BeRo1985/besen/graphs/contributors"&gt;2015?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These last few are not toys but they are also more experimental or, in
AssemblyScript's case, not JavaScript.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/boa-dev/boa"&gt;boa&lt;/a&gt;: JavaScript interpreter for Rust&lt;ul&gt;
&lt;li&gt;Support: &lt;a href="https://boa-dev.github.io/boa/test262/"&gt;Unclear&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Implementation language: Rust&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/boa-dev/boa/tree/master/boa/src/vm"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/boa-dev/boa/tree/master/boa/src/syntax/parser"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;First release: &lt;a href="https://github.com/boa-dev/boa/releases/tag/v0.2.0"&gt;2019?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/AssemblyScript/assemblyscript"&gt;AssemblyScript&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Subset of TypeScript&lt;/li&gt;
&lt;li&gt;Implementation language: AssemblyScript subset of TypeScript&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/AssemblyScript/assemblyscript/blob/main/src/compiler.ts"&gt;webassembly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/AssemblyScript/assemblyscript/blob/main/src/parser.ts"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/nickmain/kawa-scheme/tree/master/gnu/ecmascript"&gt;JavaScript in Kawa Scheme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wingolog.org/archives/2009/02/22/ecmascript-for-guile"&gt;JavaScript in GNU Guile Scheme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="research-implementations"&gt;Research Implementations&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/higgsjs/Higgs"&gt;Higgs&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: D&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/higgsjs/Higgs/blob/master/source/runtime/vm.d"&gt;Bytecode VM&lt;/a&gt; and &lt;a href="https://github.com/higgsjs/Higgs/tree/master/source/jit"&gt;JIT compiler on x64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/higgsjs/Higgs/blob/master/source/parser/parser.d"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tugawa/ejs-new"&gt;eJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: Java&lt;/li&gt;
&lt;li&gt;Runtime: Bytecode VM&lt;/li&gt;
&lt;li&gt;Parser: ANTLR&lt;/li&gt;
&lt;li&gt;Notes: eJS is a framework to generate JavaScript VMs that are specialised for applications.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/endojs/Jessie"&gt;Jessie&lt;/a&gt;: safe subset of JavaScript non-exploitable smart contracts&lt;ul&gt;
&lt;li&gt;Support: some subset of ES2017&lt;/li&gt;
&lt;li&gt;???&lt;/li&gt;
&lt;li&gt;See &lt;a href="https://github.com/agoric-labs/jessica"&gt;https://github.com/agoric-labs/jessica&lt;/a&gt; for more info.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/b9org/b9"&gt;https://github.com/b9org/b9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.defensivejs.com/"&gt;https://www.defensivejs.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="note"&gt;
  Thanks to &lt;a href="https://twitter.com/smarr"&gt;@smarr&lt;/a&gt; for contributing eJS, Higgs, and b9!
&lt;/p&gt;&lt;h3 id="notable-abandoned"&gt;Notable Abandoned&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/DigitalMars/DMDScript"&gt;DMDScript&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: D&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/DigitalMars/DMDScript/blob/master/engine/source/dmdscript/opcodes.d#L15"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/DigitalMars/DMDScript/blob/master/engine/source/dmdscript/parse.d"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Notes: It's possible this is commercially maintained by DigitalMars but I'm not sure. There are also references in this repo to another C++ implementation of DMDScript that may be commercial. Thanks to &lt;a href="https://twitter.com/moon_chilled"&gt;@moon_chilled&lt;/a&gt; for mentioning!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/toshok/echojs"&gt;EchoJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: JavaScript&lt;/li&gt;
&lt;li&gt;Runtime: Native through LLVM&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/toshok/esprima/tree/e4445c9cc2530d672c4e9f68f5e2a53673b57af0"&gt;Hand-written via Esprima&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/haileys/twostroke"&gt;twostroke&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: Ruby&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/haileys/twostroke/blob/master/lib/twostroke/runtime/vm_frame.rb"&gt;Bytecode VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/haileys/twostroke/blob/master/lib/twostroke/parser.rb"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/progval/rpython-langjs"&gt;PyPy-JS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: RPython&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/progval/rpython-langjs/blob/master/js/jscode.py"&gt;RPython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/progval/rpython-langjs/blob/master/js/jsgrammar.txt"&gt;EBNF parser generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/jterrace/js.js/"&gt;js.js&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: JavaScript&lt;/li&gt;
&lt;li&gt;Runtime: Too scared to look at the gigantic files in this repo.&lt;/li&gt;
&lt;li&gt;Parser: Ditto.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/fholm/IronJS"&gt;IronJS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: ES3&lt;/li&gt;
&lt;li&gt;Implementation language: F#&lt;/li&gt;
&lt;li&gt;Runtime: .NET through &lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/reflection-and-codedom/dynamic-language-runtime-overview"&gt;DLR&lt;/a&gt;, I think.&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/fholm/IronJS/blob/master/Src/IronJS/Compiler.Parser.fs"&gt;Hand-written&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/polydojo/jispy"&gt;jispy&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;Support: Unclear&lt;/li&gt;
&lt;li&gt;Implementation language: Python&lt;/li&gt;
&lt;li&gt;Runtime: &lt;a href="https://github.com/polydojo/jispy/blob/master/jispy.py#L730"&gt;AST interpreter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Parser: &lt;a href="https://github.com/polydojo/jispy/blob/master/jispy.py#L311"&gt;Unclear&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://metacpan.org/pod/JE#Simple-Use"&gt;JE: Pure-Perl JavaScript Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.racket-lang.org/javascript/index.html"&gt;Dave Herman's JavaScript for PLT Scheme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="notable-toy-implementations"&gt;Notable toy implementations&lt;/h3&gt;&lt;p&gt;Great for inspiriration if you've never implemented a language before.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/timruffles/js-to-c"&gt;js-to-c&lt;/a&gt;: A JavaScript to C compiler, written in C&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/mras0/mjs"&gt;mjs&lt;/a&gt;: AST interpreter for not just ES5 or even ES3 but also ES1&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/gojisvm/gojis"&gt;gojis&lt;/a&gt;: AST interpreter in Go&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/DelSkayn/toyjs"&gt;tojs&lt;/a&gt;: Bytecode VM in Rust&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/CrimsonAS/v2"&gt;v2&lt;/a&gt;: Bytecode VM in Go&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/githubyang/SparrowJS"&gt;SparrowJS&lt;/a&gt;: AST interpreter in C++&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/jsc"&gt;jsc&lt;/a&gt;: My own experiment compiling JavaScript to C++/libV8&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New post is up! Enumerating and analyzing 40+ non-V8 JavaScript implementations; of course with links to source code and parser &amp;amp; runtime/backend decisions.&lt;br&gt;&lt;br&gt;I hope you enjoy learning about JavaScript engines as much as I did. 😁&lt;a href="https://t.co/dEX06WU38f"&gt;https://t.co/dEX06WU38f&lt;/a&gt; &lt;a href="https://t.co/AoYScphG6m"&gt;pic.twitter.com/AoYScphG6m&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1440436962305789952?ref_src=twsrc%5Etfw"&gt;September 21, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/javascript-implementations.html</guid><pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate></item><item><title>Writing a simple JSON library from scratch: a tour through modern C++</title><link>http://notes.eatonphil.com/writing-a-simple-json-library-in-modern-cpp.html</link><description>&lt;p&gt;Modern C++ has a lot of cool features. Move semantics means passing
around structs in functions is cheap. &lt;code&gt;std::shared_ptr&lt;/code&gt;
means I don't have to manage any memory; no
more &lt;code&gt;new&lt;/code&gt;/&lt;code&gt;delete&lt;/code&gt;! (But try as I might to
understand &lt;code&gt;std::unique_ptr&lt;/code&gt;, I'm just not there yet.)&lt;/p&gt;
&lt;p&gt;The syntax has also gotten some treatment with &lt;code&gt;auto&lt;/code&gt; and
tuple destructuring.&lt;/p&gt;
&lt;p&gt;In order to test out this modern C++ I wanted a small but meaningful
project that operates on very dynamic data. The two that always come
to mind are JSON parsers or Lisp interpreters.&lt;/p&gt;
&lt;p&gt;This post walks through
writing a basic JSON library from scratch using only the standard
library. The source code for the resulting library is available &lt;a href="https://github.com/eatonphil/cpp-json"&gt;on
Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The biggest simplification we'll make is that rather than full JSON
numbers, we'll only allow integers.&lt;/p&gt;
&lt;p class="note"&gt;
  Big caveat! I couldn't be farther from a C++ expert! Email or tweet
  me as you see mistakes, madness, lies.
&lt;/p&gt;&lt;h3 id="api"&gt;API&lt;/h3&gt;&lt;p&gt;The two big parts of the API will be about lexing (turning a string
into an array of tokens) and parsing (turning an array of tokens into
a JSON object-tree). A better implementation would implement the lexer
as taking a character stream rather than a string, but taking a string
is simpler. So we'll stick with that.&lt;/p&gt;
&lt;p&gt;Both of these functions can fail so we'll return a tuple in both cases
with a string containing a possibly blank error message.&lt;/p&gt;
&lt;p&gt;We will define the header in &lt;code&gt;./include/json.hpp&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;#ifndef JSON_H
#define JSON_H

#include &amp;lt;tuple&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;string&amp;gt;

namespace json {
std::tuple&amp;lt;std::vector&amp;lt;JSONToken&amp;gt;, std::string&amp;gt; lex(std::string);
std::tuple&amp;lt;JSONValue, int, std::string&amp;gt; parse(std::vector&amp;lt;JSONToken&amp;gt;, int index = 0);
} // namespace json

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The token returned by &lt;code&gt;lex&lt;/code&gt; will need to contain the
token's string value, the location (offset) in the original source, a
pointer to the full source (for debugging), and the token's type. The
token type itself will be an enum of either string, number, syntax
(colon, bracket, etc.), boolean, or null.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;...
#include &amp;lt;string&amp;gt;
#include &amp;lt;memory&amp;gt;

namespace json {

enum class JSONTokenType { String, Number, Syntax, Boolean, Null };
struct JSONToken {
  std::string value;
  JSONTokenType type;
  int location;
  std::shared_ptr&amp;lt;std::string&amp;gt; full_source;
};

...

} // namespace json

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the only place in the entire code we'll pass around a
pointer. Using &lt;code&gt;std::shared_ptr&lt;/code&gt; means we don't have to do
any manual memory management either. No &lt;code&gt;new&lt;/code&gt; or
&lt;code&gt;delete&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, &lt;code&gt;JSONValue&lt;/code&gt; is a struct containing optional string,
boolean, number, array, and object fields with a type num to
differentiate.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;
...
#include &amp;lt;map&amp;gt;
#include &amp;lt;optional&amp;gt;

namespace json {

enum class JSONValueType { String, Number, Object, Array, Boolean, Null };
struct JSONValue {
  std::optional&amp;lt;std::string&amp;gt; string;
  std::optional&amp;lt;double&amp;gt; number;
  std::optional&amp;lt;bool&amp;gt; boolean;
  std::optional&amp;lt;std::vector&amp;lt;JSONValue&amp;gt;&amp;gt; array;
  std::optional&amp;lt;std::map&amp;lt;std::string, JSONValue&amp;gt;&amp;gt; object;
  JSONValueType type;
};

enum class JSONTokenType { String, Number, Syntax, Boolean, Null };

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thanks to &lt;code&gt;std::optional&lt;/code&gt; we can avoid using pointers to
describe these fields. I did take a look at &lt;code&gt;std::variant&lt;/code&gt;
but it seemed like its API was overly complex.&lt;/p&gt;
&lt;p&gt;Finally, we'll add two more functions: a high level &lt;code&gt;parse&lt;/code&gt;
function that combines the job of lexing and parsing, and a
&lt;code&gt;deparse&lt;/code&gt; function for printing a &lt;code&gt;JSONValue&lt;/code&gt; as
a JSON string.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;...
std::tuple&amp;lt;JSONValue, int, std::string&amp;gt; parse(std::vector&amp;lt;JSONToken&amp;gt;, int index = 0);
std::tuple&amp;lt;JSONValue, std::string&amp;gt; parse(std::string);
std::string deparse(JSONValue, std::string whitespace = &amp;quot;&amp;quot;);
} // namespace json
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we're ready to start on the implementation.&lt;/p&gt;
&lt;h3 id="lexing"&gt;Lexing&lt;/h3&gt;&lt;p&gt;First up is lexing; turning a JSON string into an array of tokens: a
number, string, null keyword, boolean keyword, or syntax like comma or
colon.&lt;/p&gt;
&lt;p&gt;The main lex loop skips whitespace and calls helper functions for each
kind of token. If a token is found, we accumulate it and move to the
end of that token (some tokens like &lt;code&gt;:&lt;/code&gt; are a single
character, some tokens like &lt;code&gt;"my great string"&lt;/code&gt; are
multiple characters.)&lt;/p&gt;
&lt;p&gt;Each token we find gets a pointer to the original JSON source for use
in error messages if parsing fails. Again this will be the only time
we explicitly pass around pointers in this implementation. We don't do
any manual management because we're going to use
&lt;code&gt;std::shared_ptr&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;#include &amp;quot;json.hpp&amp;quot;

namespace json {
std::tuple&amp;lt;std::vector&amp;lt;JSONToken&amp;gt;, std::string&amp;gt; lex(std::string raw_json) {
  std::vector&amp;lt;JSONToken&amp;gt; tokens;
  // All tokens will embed a pointer to the raw JSON for debugging purposes
  auto original_copy = std::make_shared&amp;lt;std::string&amp;gt;(raw_json);

  auto generic_lexers = {lex_syntax, lex_string, lex_number, lex_null, lex_true, lex_false};
  for (int i = 0; i &amp;lt; raw_json.length(); i++) {
    // Skip past whitespace
    if (auto new_index = lex_whitespace(raw_json, i); i != new_index) {
      i = new_index - 1;
      continue;
    }

    auto found = false;
    for (auto lexer : generic_lexers) {
      if (auto [token, new_index, error] = lexer(raw_json, i); i != new_index) {
        // Error while lexing, return early
        if (error.length()) {
          return {{}, error};
        }

        // Store reference to the original source
        token.full_source = original_copy;
        tokens.push_back(token);
        i = new_index - 1;
        found = true;
        break;
      }
    }

    if (found) {
      continue;
    }

    return {{}, format_error(&amp;quot;Unable to lex&amp;quot;, raw_json, i)};
  }

  return {tokens, &amp;quot;&amp;quot;};
}
} // namespace json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two neat things you'll notice in there are tuple literal syntax
(&lt;code&gt;{tokens, ""}&lt;/code&gt;) and how easy it is to type a value
containing an array of function pointers using auto
(&lt;code&gt;generic_lexers&lt;/code&gt;).&lt;/p&gt;
&lt;h4 id="format_error"&gt;format_error&lt;/h4&gt;&lt;p&gt;Since we referenced &lt;code&gt;format_error&lt;/code&gt;, let's define it. This
needs to accept a message prefix, the full JSON string, and the index
offset where the error should point to.&lt;/p&gt;
&lt;p&gt;Inside the function we'll iterate over the string until we find the
entire line containing this index offset. We'll display that line and
a pointer to the character that is causing/starting the error.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;...

#include &amp;lt;sstream&amp;gt;

namespace json {
std::string format_error(std::string base, std::string source, int index) {
  std::ostringstream s;
  int counter = 0;
  int line = 1;
  int column = 0;
  std::string lastline = &amp;quot;&amp;quot;;
  std::string whitespace = &amp;quot;&amp;quot;;
  for (auto c : source) {
    if (counter == index) {
      break;
    }

    if (c == &amp;#39;\n&amp;#39;) {
      line++;
      column = 0;
      lastline = &amp;quot;&amp;quot;;
      whitespace = &amp;quot;&amp;quot;;
    } else if (c == &amp;#39;\t&amp;#39;) {
      column++;
      lastline += &amp;quot;  &amp;quot;;
      whitespace += &amp;quot;  &amp;quot;;
    } else {
      column++;
      lastline += c;
      whitespace += &amp;quot; &amp;quot;;
    }

    counter++;
  }

  // Continue accumulating the lastline for debugging
  while (counter &amp;lt; source.size()) {
    auto c = source[counter];
    if (c == &amp;#39;\n&amp;#39;) {
      break;
    }
    lastline += c;
    counter++;
  }

  s &amp;lt;&amp;lt; base &amp;lt;&amp;lt; &amp;quot; at line &amp;quot; &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &amp;quot;, column &amp;quot; &amp;lt;&amp;lt; column &amp;lt;&amp;lt; std::endl;
  s &amp;lt;&amp;lt; lastline &amp;lt;&amp;lt; std::endl;
  s &amp;lt;&amp;lt; whitespace &amp;lt;&amp;lt; &amp;quot;^&amp;quot;;

  return s.str();
}

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;printf&lt;/code&gt; API is annoying and Clang 12 (latest Clang on
latest Fedora) doesn't seem to support &lt;code&gt;std::format&lt;/code&gt;. So we
just use
&lt;code&gt;std::sstream&lt;/code&gt; to do string "formatting".&lt;/p&gt;
&lt;p&gt;But ok, back to lexing! Next up: whitespace.&lt;/p&gt;
&lt;h4 id="lex_whitespace"&gt;lex_whitespace&lt;/h4&gt;&lt;p&gt;This function's job is to skip past whitespace. Thankfully we've got
&lt;code&gt;std::isspace&lt;/code&gt; to help.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;int lex_whitespace(std::string raw_json, int index) {
  while (std::isspace(raw_json[index])) {
    if (index == raw_json.length()) {
      break;
    }

    index++;
  }

  return index;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's very simple!&lt;/p&gt;
&lt;h4 id="lex_syntax"&gt;lex_syntax&lt;/h4&gt;&lt;p&gt;All of the generic lexers follow the same pattern. They return either
a valid token and the index where the token ends, or they return an
error string.&lt;/p&gt;
&lt;p&gt;Since all the syntax elements in JSON (&lt;code&gt;,&lt;/code&gt;, &lt;code&gt;:&lt;/code&gt;,
&lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt; and , &lt;code&gt;]&lt;/code&gt;)
are single characters, we don't need to write a "longest substring"
helper function. We simply check if the current character is one of
these characters and return a syntax token if so.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_syntax(std::string raw_json, int index) {
  JSONToken token{&amp;quot;&amp;quot;, JSONTokenType::Syntax, index};
  std::string value = &amp;quot;&amp;quot;;
  auto c = raw_json[index];
  if (c == &amp;#39;[&amp;#39; || c == &amp;#39;]&amp;#39; || c == &amp;#39;{&amp;#39; || c == &amp;#39;}&amp;#39; || c == &amp;#39;:&amp;#39; || c == &amp;#39;,&amp;#39;) {
    token.value += c;
    index++;
  }

  return {token, index, &amp;quot;&amp;quot;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="lex_string"&gt;lex_string&lt;/h3&gt;&lt;p&gt;This one manages state so it's a little more complex. We need to check
if the current character is a double quote, then iterate over
characters until we find the ending quote.&lt;/p&gt;
&lt;p&gt;It's possible to hit EOF here so we need to handle that case. And
handling nested quotes is left as an exercise for the reader. :)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_string(std::string raw_json,
                                                   int original_index) {
  int index = original_index;
  JSONToken token{&amp;quot;&amp;quot;, JSONTokenType::String, index};
  std::string value = &amp;quot;&amp;quot;;
  auto c = raw_json[index];
  if (c != &amp;#39;&amp;quot;&amp;#39;) {
    return {token, original_index, &amp;quot;&amp;quot;};
  }
  index++;

  // TODO: handle nested quotes
  while (c = raw_json[index], c != &amp;#39;&amp;quot;&amp;#39;) {
    if (index == raw_json.length()) {
      return {token, index, format_error(&amp;quot;Unexpected EOF while lexing string&amp;quot;, raw_json, index)};
    }

    token.value += c;
    index++;
  }
  index++;

  return {token, index, &amp;quot;&amp;quot;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing too special to discuss here. So on to lexing numbers.&lt;/p&gt;
&lt;h3 id="lex_number"&gt;lex_number&lt;/h3&gt;&lt;p&gt;Since we're only supporting integers, this one has no internal
state. We check characters until we stop seeing digits.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_number(std::string raw_json,
                                                   int original_index) {
  int index = original_index;
  JSONToken token = {&amp;quot;&amp;quot;, JSONTokenType::Number, index};
  std::string value = &amp;quot;&amp;quot;;
  // TODO: handle not just integers
  while (true) {
    if (index == raw_json.length()) {
      break;
    }

    auto c = raw_json[index];
    if (!(c &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;9&amp;#39;)) {
      break;
    }

    token.value += c;
    index++;
  }

  return {token, index, &amp;quot;&amp;quot;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Done. On to keywords: &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="lex_keyword"&gt;lex_keyword&lt;/h3&gt;&lt;p&gt;This is a helper function that will check for a literal keyword.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_keyword(std::string raw_json,
                                                    std::string keyword,
                                                    JSONTokenType type,
                                                    int original_index) {
  int index = original_index;
  JSONToken token{&amp;quot;&amp;quot;, type, index};
  while (keyword[index - original_index] == raw_json[index]) {
    if (index == raw_json.length()) {
      break;
    }

    index++;
  }

  if (index - original_index == keyword.length()) {
    token.value = keyword;
  }
  return {token, index, &amp;quot;&amp;quot;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this defined we can now implement &lt;code&gt;lex_false&lt;/code&gt;,
&lt;code&gt;lex_true&lt;/code&gt;, and &lt;code&gt;lex_null&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_null(std::string raw_json,
                                                 int index) {
  return lex_keyword(raw_json, &amp;quot;null&amp;quot;, JSONTokenType::Null, index);
}

std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_true(std::string raw_json,
                                                 int index) {
  return lex_keyword(raw_json, &amp;quot;true&amp;quot;, JSONTokenType::Boolean, index);
}

std::tuple&amp;lt;JSONToken, int, std::string&amp;gt; lex_false(std::string raw_json,
                                                  int index) {
  return lex_keyword(raw_json, &amp;quot;false&amp;quot;, JSONTokenType::Boolean, index);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for lexing! And although we defined all of these
top-down, you'll want to write them mostly in reverse order or put in
forward declarations.&lt;/p&gt;
&lt;p&gt;If you wanted to you could now write a simple &lt;code&gt;main.cpp&lt;/code&gt;
like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;#include &amp;quot;json.hpp&amp;quot;

#include &amp;lt;iostream&amp;gt;

int main(int argc, char *argv[]) {
  if (argc == 1) {
    std::cerr &amp;lt;&amp;lt; &amp;quot;Expected JSON input argument to parse&amp;quot; &amp;lt;&amp;lt; std::endl;
    return 1;
  }

  std::string in{argv[1]};

  auto [tokens, error] = json::lex(in);
  if (error.size()) {
    std::cerr &amp;lt;&amp;lt; error &amp;lt;&amp;lt; std::endl;
    return 1;
  }

  for (auto t : tokens) {
    std::cout &amp;lt;&amp;lt; t.value &amp;lt;&amp;lt; std::endl;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Set up a Makefile:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs make"&gt;main: *.cpp ./include/*.hpp
        clang++ -g -Wall -std=c++2a -I./include *.cpp -o $@
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build with &lt;code&gt;make&lt;/code&gt; and run &lt;code&gt;./main '{"a": 1}'&lt;/code&gt;
to see the list of tokens printed out.&lt;/p&gt;
&lt;p&gt;Now let's move on to parsing from the array of tokens.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;This process takes the array of tokens and turns them into a tree
structure. The tree develops children as we spot &lt;code&gt;[&lt;/code&gt; or
&lt;code&gt;{&lt;/code&gt; tokens. The tree child ends when we spot &lt;code&gt;]&lt;/code&gt;
or &lt;code&gt;}&lt;/code&gt; tokens.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONValue, int, std::string&amp;gt; parse(std::vector&amp;lt;JSONToken&amp;gt; tokens,
                                              int index) {
  auto token = tokens[index];
  switch (token.type) {
  case JSONTokenType::Number: {
    auto n = std::stod(token.value);
    return {JSONValue{.number = n, .type = JSONValueType::Number}, index + 1, &amp;quot;&amp;quot;};
  }
  case JSONTokenType::Boolean:
    return {JSONValue{.boolean = token.value == &amp;quot;true&amp;quot;, .type = JSONValueType::Boolean}, index + 1, &amp;quot;&amp;quot;};
  case JSONTokenType::Null:
    return {JSONValue{.type = JSONValueType::Null}, index + 1, &amp;quot;&amp;quot;};
  case JSONTokenType::String:
    return {JSONValue{.string = token.value, .type = JSONValueType::String}, index + 1, &amp;quot;&amp;quot;};
  case JSONTokenType::Syntax:
    if (token.value == &amp;quot;[&amp;quot;) {
      auto [array, new_index, error] = parse_array(tokens, index + 1);
      return {JSONValue{.array = array, .type = JSONValueType::Array}, new_index, error};
    }

    if (token.value == &amp;quot;{&amp;quot;) {
      auto [object, new_index, error] = parse_object(tokens, index + 1);
      return {JSONValue{.object = std::optional(object), .type = JSONValueType::Object}, new_index, error};
    }
  }

  return {{}, index, format_parse_error(&amp;quot;Failed to parse&amp;quot;, token)};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This in turn reference &lt;code&gt;format_parse_error&lt;/code&gt; on failure
which is an error-string-maker similar to
&lt;code&gt;format_error&lt;/code&gt;. It actually calls &lt;code&gt;format_error&lt;/code&gt;
with more details specific to parsing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::string JSONTokenType_to_string(JSONTokenType jtt) {
  switch (jtt) {
  case JSONTokenType::String:
    return &amp;quot;String&amp;quot;;
  case JSONTokenType::Number:
    return &amp;quot;Number&amp;quot;;
  case JSONTokenType::Syntax:
    return &amp;quot;Syntax&amp;quot;;
  case JSONTokenType::Boolean:
    return &amp;quot;Boolean&amp;quot;;
  case JSONTokenType::Null:
    return &amp;quot;Null&amp;quot;;
  }
}

std::string format_parse_error(std::string base, JSONToken token) {
  std::ostringstream s;
  s &amp;lt;&amp;lt; &amp;quot;Unexpected token &amp;#39;&amp;quot; &amp;lt;&amp;lt; token.value &amp;lt;&amp;lt; &amp;quot;&amp;#39;, type &amp;#39;&amp;quot;
    &amp;lt;&amp;lt; JSONTokenType_to_string(token.type) &amp;lt;&amp;lt; &amp;quot;&amp;#39;, index &amp;quot;;
  s &amp;lt;&amp;lt; std::endl &amp;lt;&amp;lt; base;
  return format_error(s.str(), *token.full_source, token.location);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  This function depended on a helper for turning the
  &lt;code&gt;JSONTokenType&lt;/code&gt; enum into a string. As a user it's very
  annoying when langauges doesn't give you stringifier methods for enums
  by default for debugging. I know there's some ways to do this with
  reflection in C++ but it seemed hairy.

  But I digest.
&lt;/p&gt;&lt;h4 id="parse_array"&gt;parse_array&lt;/h4&gt;&lt;p&gt;This function was called by &lt;code&gt;parse&lt;/code&gt; when we found an
opening bracket. This function needs to recursively call parse and
then check for a comma and call parse again ... until it finds the
closing bracket.&lt;/p&gt;
&lt;p&gt;It will fail if it every finds something other than a comma or closing
bracket following a succesful call to &lt;code&gt;parse&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;std::vector&amp;lt;JSONValue&amp;gt;, int, std::string&amp;gt;
parse_array(std::vector&amp;lt;JSONToken&amp;gt; tokens, int index) {
  std::vector&amp;lt;JSONValue&amp;gt; children = {};
  while (index &amp;lt; tokens.size()) {
    auto t = tokens[index];
    if (t.type == JSONTokenType::Syntax) {
      if (t.value == &amp;quot;]&amp;quot;) {
        return {children, index + 1, &amp;quot;&amp;quot;};
      }

      if (t.value == &amp;quot;,&amp;quot;) {
        index++;
        t = tokens[index];
      } else if (children.size() &amp;gt; 0) {
        return {{},
                index,
                format_parse_error(&amp;quot;Expected comma after element in array&amp;quot;, t)};
      }
    }

    auto [child, new_index, error] = parse(tokens, index);
    if (error.size()) {
      return {{}, index, error};
    }

    children.push_back(child);
    index = new_index;
  }

  return {
      {},
      index,
      format_parse_error(&amp;quot;Unexpected EOF while parsing array&amp;quot;, tokens[index])};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally we need to implement &lt;code&gt;parse_object&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="parse_object"&gt;parse_object&lt;/h4&gt;&lt;p&gt;This function is similar to &lt;code&gt;parse_array&lt;/code&gt; but it needs to
find &lt;code&gt;$string COLON $parse() COMMA&lt;/code&gt; pattern pairs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;std::map&amp;lt;std::string, JSONValue&amp;gt;, int, std::string&amp;gt;
parse_object(std::vector&amp;lt;JSONToken&amp;gt; tokens, int index) {
  std::map&amp;lt;std::string, JSONValue&amp;gt; values = {};
  while (index &amp;lt; tokens.size()) {
    auto t = tokens[index];
    if (t.type == JSONTokenType::Syntax) {
      if (t.value == &amp;quot;}&amp;quot;) {
        return {values, index + 1, &amp;quot;&amp;quot;};
      }

      if (t.value == &amp;quot;,&amp;quot;) {
        index++;
        t = tokens[index];
      } else if (values.size() &amp;gt; 0) {
        return {
            {},
            index,
            format_parse_error(&amp;quot;Expected comma after element in object&amp;quot;, t)};
      } else {
        return {{},
                index,
                format_parse_error(
                    &amp;quot;Expected key-value pair or closing brace in object&amp;quot;, t)};
      }
    }

    auto [key, new_index, error] = parse(tokens, index);
    if (error.size()) {
      return {{}, index, error};
    }

    if (key.type != JSONValueType::String) {
      return {
          {}, index, format_parse_error(&amp;quot;Expected string key in object&amp;quot;, t)};
    }
    index = new_index;
    t = tokens[index];

    if (!(t.type == JSONTokenType::Syntax &amp;amp;&amp;amp; t.value == &amp;quot;:&amp;quot;)) {
      return {{},
              index,
              format_parse_error(&amp;quot;Expected colon after key in object&amp;quot;, t)};
    }
    index++;
    t = tokens[index];

    auto [value, new_index1, error1] = parse(tokens, index);
    if (error1.size()) {
      return {{}, index, error1};
    }

    values[key.string.value()] = value;
    index = new_index1;
  }

  return {values, index + 1, &amp;quot;&amp;quot;};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These parse functions are all slightly tedious but still very
simple. And thankfully, we're done!&lt;/p&gt;
&lt;p&gt;We can now implement the variation of &lt;code&gt;parse&lt;/code&gt; that ties
together lexing and parsing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;std::tuple&amp;lt;JSONValue, std::string&amp;gt; parse(std::string source) {
  auto [tokens, error] = json::lex(source);
  if (error.size()) {
    return {{}, error};
  }

  auto [ast, _, error1] = json::parse(tokens);
  return {ast, error1};
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're completely done the string to &lt;code&gt;JSONValue&lt;/code&gt; code.&lt;/p&gt;
&lt;h3 id="deparse"&gt;deparse&lt;/h3&gt;&lt;p&gt;The very last piece of the implementation is to do the reverse of the
past operations: generate a string from a &lt;code&gt;JSONValue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is a recursive function and the only mildly tricky part is
deciding how to do whitespace if we want a prettier output.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;
std::string deparse(JSONValue v, std::string whitespace) {
  switch (v.type) {
  case JSONValueType::String:
    return &amp;quot;\&amp;quot;&amp;quot; + v.string.value() + &amp;quot;\&amp;quot;&amp;quot;;
  case JSONValueType::Boolean:
    return (v.boolean.value() ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot;);
  case JSONValueType::Number:
    return std::to_string(v.number.value());
  case JSONValueType::Null:
    return &amp;quot;null&amp;quot;;
  case JSONValueType::Array: {
    std::string s = &amp;quot;[\n&amp;quot;;
    auto a = v.array.value();
    for (int i = 0; i &amp;lt; a.size(); i++) {
      auto value = a[i];
      s += whitespace + &amp;quot;  &amp;quot; + deparse(value, whitespace + &amp;quot;  &amp;quot;);
      if (i &amp;lt; a.size() - 1) {
        s += &amp;quot;,&amp;quot;;
      }

      s += &amp;quot;\n&amp;quot;;
    }

    return s + whitespace + &amp;quot;]&amp;quot;;
  }
  case JSONValueType::Object: {
    std::string s = &amp;quot;{\n&amp;quot;;
    auto values = v.object.value();
    auto i = 0;
    for (auto const &amp;amp;[key, value] : values) {
      s += whitespace + &amp;quot;  &amp;quot; + &amp;quot;\&amp;quot;&amp;quot; + key +
           &amp;quot;\&amp;quot;: &amp;quot; + deparse(value, whitespace + &amp;quot;  &amp;quot;);

      if (i &amp;lt; values.size() - 1) {
        s += &amp;quot;,&amp;quot;;
      }

      s += &amp;quot;\n&amp;quot;;
      i++;
    }

    return s + whitespace + &amp;quot;}&amp;quot;;
  }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Done. Done. Done.&lt;/p&gt;
&lt;h3 id="main.cpp"&gt;main.cpp&lt;/h3&gt;&lt;p&gt;This program will simply accept a JSON input, parse it, and pretty
print it right back out. Kind of like a simplified &lt;code&gt;jq&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;#include &amp;quot;json.hpp&amp;quot;

#include &amp;lt;iostream&amp;gt;

int main(int argc, char *argv[]) {
  if (argc == 1) {
    std::cerr &amp;lt;&amp;lt; &amp;quot;Expected JSON input argument to parse&amp;quot; &amp;lt;&amp;lt; std::endl;
    return 1;
  }

  std::string in{argv[1]};

  auto [ast, error] = json::parse(in);
  if (error.size()) {
    std::cerr &amp;lt;&amp;lt; error &amp;lt;&amp;lt; std::endl;
    return 1;
  }

  std::cout &amp;lt;&amp;lt; json::deparse(ast);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build it with &lt;code&gt;make&lt;/code&gt; that we already defined, and run it against
something big like
&lt;a href="https://github.com/eatonphil/cpp-json/blob/main/test/glossary.json"&gt;this&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cd cpp-json
$ make
$ ./main &amp;quot;$(cat ./test/glossary.json)&amp;quot;
{
  &amp;quot;glossary&amp;quot;: {
    &amp;quot;GlossDiv&amp;quot;: {
      &amp;quot;GlossList&amp;quot;: {
        &amp;quot;GlossEntry&amp;quot;: {
          &amp;quot;Abbrev&amp;quot;: &amp;quot;ISO 8879:1986&amp;quot;,
          &amp;quot;Acronym&amp;quot;: &amp;quot;SGML&amp;quot;,
          &amp;quot;GlossDef&amp;quot;: {
            &amp;quot;GlossSeeAlso&amp;quot;: [
              &amp;quot;GML&amp;quot;,
              &amp;quot;XML&amp;quot;
            ],
            &amp;quot;para&amp;quot;: &amp;quot;A meta-markup language, used to create markup languages such as DocBook.&amp;quot;
          },
          &amp;quot;GlossSee&amp;quot;: &amp;quot;markup&amp;quot;,
          &amp;quot;GlossTerm&amp;quot;: &amp;quot;Standard Generalized Markup Language&amp;quot;,
          &amp;quot;ID&amp;quot;: &amp;quot;SGML&amp;quot;,
          &amp;quot;SortAs&amp;quot;: &amp;quot;SGML&amp;quot;
        }
      },
      &amp;quot;title&amp;quot;: &amp;quot;S&amp;quot;
    },
    &amp;quot;title&amp;quot;: &amp;quot;example glossary&amp;quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or something incorrect like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./main &amp;#39;{&amp;quot;foo&amp;quot;: [{ 1: 2 }]}&amp;#39;
Unexpected token &amp;#39;1&amp;#39;, type &amp;#39;Number&amp;#39;, index
Expected string key in object at line 1, column 11
{&amp;quot;foo&amp;quot;: [{ 1: 2 }]}
           ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And give Valgrind the old try:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;valgrind ./main &amp;#39;{&amp;quot;a&amp;quot;: [1, 2, null, { &amp;quot;c&amp;quot;: 129 }]}&amp;#39;
==153027== Memcheck, a memory error detector
==153027== Copyright (C) 2002-2017, and GNU GPL&amp;#39;d, by Julian Seward et al.
==153027== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==153027== Command: ./main {&amp;quot;a&amp;quot;:\ [1,\ 2,\ null,\ {\ &amp;quot;c&amp;quot;:\ 129\ }]}
==153027==
{
  &amp;quot;a&amp;quot;: [
    1.000000,
    2.000000,
    null,
    {
      &amp;quot;c&amp;quot;: 129.000000
    }
  ]
}==153027==
==153027== HEAP SUMMARY:
==153027==     in use at exit: 0 bytes in 0 blocks
==153027==   total heap usage: 128 allocs, 128 frees, 105,386 bytes allocated
==153027==
==153027== All heap blocks were freed -- no leaks are possible
==153027==
==153027== For lists of detected and suppressed errors, rerun with: -s
==153027== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty sweet. Modern C++, I like it!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I don&amp;#39;t do a lot of C++ so I wanted to get a sense for what it can look like today.&lt;br&gt;&lt;br&gt;This post walks through a number of new-ish C++ features as we build a handwritten recursive descent parser for JSON using only the standard library.&lt;a href="https://t.co/cCN6nP0pDi"&gt;https://t.co/cCN6nP0pDi&lt;/a&gt; &lt;a href="https://t.co/0AZNEZv4Ss"&gt;pic.twitter.com/0AZNEZv4Ss&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1431000902710796292?ref_src=twsrc%5Etfw"&gt;August 26, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-a-simple-json-library-in-modern-cpp.html</guid><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate></item><item><title>Parser generators vs. handwritten parsers: surveying major language implementations in 2021</title><link>http://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html</link><description>&lt;p&gt;Developers often think parser generators are the sole legit way to
build programming language frontends, possibly because compiler
courses in university teach lex/yacc variants. But do any modern
programming languages actually use parser generators anymore?&lt;/p&gt;
&lt;p&gt;To find out, this post presents a non-definitive survey of the parsing
techniques used by various major programming language implementations.&lt;/p&gt;
&lt;h3 id="cpython:-peg-parser"&gt;CPython: PEG parser&lt;/h3&gt;&lt;p&gt;Until CPython 3.10 (which hasn't been released yet) the default parser
was built using &lt;a href="https://www.python.org/dev/peps/pep-0269/"&gt;pgen&lt;/a&gt;. The
team thought the PEG parser was a &lt;a href="https://www.python.org/dev/peps/pep-0617/"&gt;better fit for expressing the
language&lt;/a&gt;, and at the time
took a reported 10% speed and memory usage hit switching off pgen.&lt;/p&gt;
&lt;p&gt;The PEG grammar is defined
&lt;a href="https://github.com/python/cpython/blob/v3.9.6/Grammar/python.gram"&gt;here&lt;/a&gt;. (It
is getting renamed in 3.10 though so check the directory for a file of
a similar name if you browse 3.10+).&lt;/p&gt;
&lt;p class="note"&gt;
  This section was corrected
  by &lt;a href="https://www.reddit.com/r/ProgrammingLanguages/comments/p8vvcs/parser_generators_vs_handwritten_parsers/h9tbuve/?utm_source=reddit&amp;utm_medium=web2x&amp;context=3"&gt;MegaIng&lt;/a&gt; on Reddit. Originally
  I mistakenly claimed the previous parser was
  handwritten. It was not.
&lt;/p&gt;&lt;h3 id="gcc:-handwritten"&gt;GCC: Handwritten&lt;/h3&gt;&lt;p&gt;Source code for the C parser available
&lt;a href="https://github.com/gcc-mirror/gcc/blob/master/gcc/c/c-parser.c"&gt;here&lt;/a&gt;. It
used to use Bison until &lt;a href="The old Bison-based C and
Objective-C parser has been replaced by a new, faster hand-written
recursive-descent parser."&gt;GCC 4.1 in 2006&lt;/a&gt;. The C++ parser also switched from Bison
to a handwritten parser &lt;a href="https://gcc.gnu.org/gcc-3.4/changes.html"&gt;2 years
earlier&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="clang:-handwritten"&gt;Clang: Handwritten&lt;/h3&gt;&lt;p&gt;Not only handwritten but the same &lt;em&gt;file&lt;/em&gt; handles parsing C,
Objective-C and C++. Source code is available
&lt;a href="https://github.com/llvm/llvm-project/blob/llvmorg-12.0.1/clang/lib/Parse/Parser.cpp"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="ruby:-yacc-like-parser-generator"&gt;Ruby: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;Ruby uses Bison (thanks for the
&lt;a href="https://twitter.com/kddnewton/status/1430912896473739271"&gt;correction&lt;/a&gt;!). The
grammar for the language can be found
&lt;a href="https://github.com/ruby/ruby/blob/v3_0_2/parse.y"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="v8-javascript:-handwritten"&gt;V8 JavaScript: Handwritten&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/v8/v8/blob/9.5.38/src/parsing/parser.cc"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="zend-engine-php:-yacc-like-parser-generator"&gt;Zend Engine PHP: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/php/php-src/blob/php-8.0.9/Zend/zend_language_parser.y"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="typescript:-handwritten"&gt;TypeScript: Handwritten&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/microsoft/TypeScript/blob/v4.3.5/src/compiler/parser.ts"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="bash:-yacc-like-parser-generator"&gt;Bash: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;Source code for the grammar is available
&lt;a href="http://git.savannah.gnu.org/cgit/bash.git/tree/parse.y?h=bash-5.1"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="chromium-css-parser:-handwritten"&gt;Chromium CSS Parser: Handwritten&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/chromium/chromium/blob/95.0.4617.2/third_party/blink/renderer/core/css/parser/css_parser_impl.cc"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="java-(openjdk):-handwritten"&gt;Java (OpenJDK): Handwritten&lt;/h3&gt;&lt;p&gt;You can find the source code
&lt;a href="https://github.com/openjdk/jdk/blob/jdk-18%2B11/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some &lt;a href="https://openjdk.java.net/projects/compiler-grammar/"&gt;older
commentary&lt;/a&gt; calls
this implementation fragile. But a Java contributor &lt;a href="https://twitter.com/BrianGoetz/status/1429227723055042568"&gt;suggests the
situation has improved since Java
8&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="golang:-handwritten"&gt;Golang: Handwritten&lt;/h3&gt;&lt;p&gt;Until Go 1.6 the compiler used a yacc-based parser. The source code
for that grammar is available
&lt;a href="https://github.com/golang/go/blob/go1.5/src/cmd/compile/internal/gc/y.go"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In Go 1.6 they switched to a handwritten parser. You can find that
change &lt;a href="https://go-review.googlesource.com/c/go/+/16665/"&gt;here&lt;/a&gt;. There
was a reported 18% speed increase when parsing files and a reported 3%
speed increase in building the compiler itself when switching.&lt;/p&gt;
&lt;p&gt;You can find the source code for the compiler's parser
&lt;a href="https://github.com/golang/go/blob/go1.17/src/cmd/compile/internal/syntax/parser.go"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="roslyn:-handwritten"&gt;Roslyn: Handwritten&lt;/h3&gt;&lt;p&gt;The C# parser source code is available
&lt;a href="https://github.com/dotnet/roslyn/blob/Visual-Studio-2019-Version-16.11/src/Compilers/CSharp/Portable/Parser/LanguageParser.cs"&gt;here&lt;/a&gt;. The
Visual Basic parser source code is
&lt;a href="https://github.com/dotnet/roslyn/blob/Visual-Studio-2019-Version-16.11/src/Compilers/VisualBasic/Portable/Parser/Parser.vb"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A C# contributor mentioned a few key reasons for using a handwritten parser &lt;a href="https://news.ycombinator.com/item?id=13915150"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="lua:-handwritten"&gt;Lua: Handwritten&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/lua/lua/blob/v5.4.3/lparser.c"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="swift:-handwritten"&gt;Swift: Handwritten&lt;/h3&gt;&lt;p&gt;Source code available &lt;a href="https://github.com/apple/swift/blob/swift-5.4.2-RELEASE/lib/Parse/Parser.cpp"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="r:-yacc-like-parser-generator"&gt;R: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;I couldn't find it at first but
&lt;a href="https://www.reddit.com/r/programming/comments/p8vv1l/parser_generators_vs_handwritten_parsers/h9tl763/?utm_source=reddit&amp;amp;utm_medium=web2x&amp;amp;context=3"&gt;Liorithiel&lt;/a&gt;
showed me the parser source code is
&lt;a href="https://github.com/wch/r-source/blob/trunk/src/main/gram.y"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="julia:-handwritten-...-in-scheme"&gt;Julia: Handwritten ... in Scheme&lt;/h3&gt;&lt;p&gt;Julia's parser is handwritten but not in Julia. It's in Scheme! Source code available &lt;a href="https://github.com/JuliaLang/julia/blob/v1.6.2/src/julia-parser.scm"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="postgresql:-yacc-like-parser-generator"&gt;PostgreSQL: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;PostgreSQL uses Bison for parsing queries. Source code for the grammar
available
&lt;a href="https://github.com/postgres/postgres/blob/REL_13_STABLE/src/backend/parser/gram.y"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="mysql:-yacc-parser-generator"&gt;MySQL: Yacc Parser Generator&lt;/h3&gt;&lt;p&gt;Source code for the grammar available
&lt;a href="https://github.com/mysql/mysql-server/blob/8.0/sql/sql_yacc.yy"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="sqlite:-yacc-like-parser-generator"&gt;SQLite: Yacc-like Parser Generator&lt;/h3&gt;&lt;p&gt;SQLite uses its own parser generator called
&lt;a href="https://www.sqlite.org/lemon.html"&gt;Lemon&lt;/a&gt;. Source code for the
grammary is available
&lt;a href="https://github.com/sqlite/sqlite/blob/version-3.36.0/src/parse.y"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;&lt;p&gt;Of the &lt;a href="https://redmonk.com/sogrady/2021/03/01/language-rankings-1-21/"&gt;2021 Redmonk top 10
languages&lt;/a&gt;,
8 of them have a handwritten parser. Ruby and Python use parser generators.&lt;/p&gt;
&lt;p&gt;Although parser generators are still used in major language
implementations, maybe it's time for universities to start teaching
handwritten parsing?&lt;/p&gt;
&lt;p class="note"&gt;
  This tweet was published before I was corrected about Python's
  parser. It should say 8/10 but I cannot edit the tweet.
&lt;/p&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Let&amp;#39;s actually survey the parsing techniques used by major programming languages in 2021 (with links to code 👾).&lt;br&gt;&lt;br&gt;In this post we discover that 9/10 of the top languages by &lt;a href="https://twitter.com/redmonk?ref_src=twsrc%5Etfw"&gt;@redmonk&lt;/a&gt; use a handwritten parser as opposed to a parser generator. 😱&lt;a href="https://t.co/M69TqN78G5"&gt;https://t.co/M69TqN78G5&lt;/a&gt; &lt;a href="https://t.co/sGsdDmwshB"&gt;pic.twitter.com/sGsdDmwshB&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1429137493019045899?ref_src=twsrc%5Etfw"&gt;August 21, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/parser-generators-vs-handwritten-parsers-survey-2021.html</guid><pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate></item><item><title>Practical? Common Lisp on the JVM: A quick intro to ABCL for modern web apps</title><link>http://notes.eatonphil.com/practical-common-lisp-on-the-jvm.html</link><description>&lt;p&gt;In a ridiculous attempt to &lt;a href="https://news.ycombinator.com/item?id=28036679"&gt;prove an internet
wrong&lt;/a&gt; about the
practicality of Lisp (Common Lisp specifically), I tried to get a
simple (but realistic) web app running. After four days and &lt;a href="https://github.com/armedbear/abcl/pull/379"&gt;a patch
to ABCL&lt;/a&gt; I got something
working.&lt;/p&gt;
&lt;p&gt;The code I had in mind would look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(let* ((port 8080)
       (server (make-server port)))
  (route server &amp;quot;GET&amp;quot; &amp;quot;/&amp;quot; (lambda (ctx) &amp;quot;My index!&amp;quot;))
  (route server &amp;quot;GET&amp;quot; &amp;quot;/search&amp;quot;
    (lambda (ctx)
      (template &amp;quot;search.tmpl&amp;quot; &amp;#39;((&amp;quot;version&amp;quot; &amp;quot;0.1.0&amp;quot;)
                                (&amp;quot;results&amp;quot; (&amp;quot;cat&amp;quot; &amp;quot;dog&amp;quot; &amp;quot;mouse&amp;quot;)))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And &lt;code&gt;search.tmpl&lt;/code&gt; would be some Jinja-like text file:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs html"&gt;&amp;lt;html&amp;gt;
  &amp;lt;title&amp;gt;Version {{ version }}&amp;lt;/title&amp;gt;
  {% for item in results %}
    &amp;lt;h2&amp;gt;{{ item }}&amp;lt;/h2&amp;gt;
  {% endfor %}
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The source code for this post can be found &lt;a href="https://github.com/eatonphil/jvm-lisp-examples"&gt;on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="picking-a-language,-libraries"&gt;Picking a language, libraries&lt;/h3&gt;&lt;p&gt;&lt;a href="https://abcl.org"&gt;Armed Bear Common Lisp&lt;/a&gt; (ABCL) is the only Common Lisp
implementation I'm aware of that can hook into a major ecosystem of
libraries like the JVM or CLR has. In theory, this makes it a safe
suggestion for folks who want the stability and resources of the
ecosystem even if they aren't using its flagship language.&lt;/p&gt;
&lt;p&gt;I wanted to use some micro web framework like
&lt;a href="https://sparkjava.com/"&gt;Spark&lt;/a&gt; or &lt;a href="https://micronaut.io/"&gt;Micronaut&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem with libraries like Micronaut (and
&lt;a href="https://eclipse-ee4j.github.io/jersey/"&gt;Jersey&lt;/a&gt;) is that they do a
lot of dynamic inspection to figure out how to register controllers
and whatnot. This is certainly convenient for developers using the
library in Java. But it becomes an ordeal when you're trying to use
the library through a foreign function interface (FFI) in another
language. An example of this is if a framework scans all files in a
directory for a &lt;code&gt; @GET&lt;/code&gt; annotation.&lt;/p&gt;
&lt;p&gt;On the other hand, Spark had a seeming hard-requirement about bringing
in a Websocket library which caused some issues during
configuration. So I ended up going with &lt;a href="https://jooby.io/"&gt;Jooby&lt;/a&gt; and
&lt;a href="https://netty.io/"&gt;Netty&lt;/a&gt; (as the underlying server).&lt;/p&gt;
&lt;p&gt;Finally, I looked into a few Jinja-like template libraries and settled
on &lt;a href="https://pebbletemplates.io/"&gt;Pebble&lt;/a&gt; since
&lt;a href="https://github.com/HubSpot/jinjava"&gt;Jinjava&lt;/a&gt; &lt;a href="https://github.com/HubSpot/jinjava/issues/317"&gt;wouldn't load for
me&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="3rd-party-jars-and-foreign-function-calls"&gt;3rd-party jars and foreign function calls&lt;/h3&gt;&lt;p&gt;So you've got your maven dependencies and ran &lt;code&gt;mvn
install&lt;/code&gt;. Your &lt;code&gt;pom.xml&lt;/code&gt; looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;project&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;com.github.eatonphil&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;abcl-rest-api-hello-world&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1&amp;lt;/version&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.jooby&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jooby&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.jooby&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jooby-netty&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.10.0&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;io.pebbletemplates&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;pebble&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.1.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ABCL has a package called &lt;code&gt;abcl-asdf&lt;/code&gt; that helps you resolve dependencies through Maven and your filesystem. We'll import it and a package it depends on (&lt;code&gt;abcl-contrib&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(require :abcl-contrib)
(require :abcl-asdf)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All our code will go into a single &lt;code&gt;main.lisp&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;To import a specific package from Maven you
call &lt;code&gt;abcl-asdf:resolve&lt;/code&gt; with a colon-separated string
containing the Maven package group id and artifact id. Then you pass
that result to &lt;code&gt;abcl-asdf:as-classpath&lt;/code&gt; and pass that
result to &lt;code&gt;java:add-to-classpath&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(setf imports &amp;#39;(&amp;quot;io.jooby:jooby&amp;quot;
                &amp;quot;io.jooby:jooby-netty&amp;quot;
                &amp;quot;io.pebbletemplates:pebble&amp;quot;))
(loop for import in imports
      do (java:add-to-classpath
          (abcl-asdf:as-classpath (abcl-asdf:resolve import))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can call functions within these packages. If you want to call
a Java method using only builtins it looks like &lt;code&gt;(jcall "method"
"com.organization.package.Class" object arg1 arg2 ... argN)&lt;/code&gt;. If
you want to call a static Java method you use &lt;code&gt;(jstatic
...)&lt;/code&gt; instead of &lt;code&gt;(jcall ...)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It seems that ABCL will automatically convert simple types from their
Lisp representation to Java but it will not turn a list into an
array. If a Java function requires an array you'll have to do that
explicitly with a function like &lt;code&gt;(java:jnew-array-from-list
"java.lang.String" my-string-list)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When using the builtin Java FFI you always need to use the fully
qualified name for classes like &lt;code&gt;java.lang.Object&lt;/code&gt;
for &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;java.util.Array&lt;/code&gt;
for &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alternatively you can &lt;code&gt;(require :jss)&lt;/code&gt; to get access to a
simpler syntax for making Java calls. A method call looks
like &lt;code&gt;(#"method" object arg1 arg2 ... argN)&lt;/code&gt;. Creating a
new instance of an object is calling &lt;code&gt;(jss:jnew
'className)&lt;/code&gt;. When you use JSS you don't need to fully qualify a
class name unless there are more than one class with the same
name. For example to create a new Jooby application instance we can
call &lt;code&gt;(jss:jnew 'Jooby)&lt;/code&gt;. As long as the class can be found
in the class path JSS will resolve it.&lt;/p&gt;
&lt;h3 id="some-real-code"&gt;Some real code&lt;/h3&gt;&lt;p&gt;The real code will look similar to the pseudo-code at the top of this
article. We'll stub out the library-specific wrappers for rendering a
template and for registering a route.&lt;/p&gt;
&lt;p&gt;Fumbling around the &lt;a href="https://github.com/jooby-project/jooby/blob/2.x/jooby/src/main/java/io/jooby/Server.java#L35"&gt;Jooby source code&lt;/a&gt; we see this snippet of Java:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt; * Server server = new Netty(); // or Jetty or Utow
 *
 * App app = new App();
 *
 * server.start(app);
 *
 * ...
 *
 * server.stop();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Netty&lt;/code&gt; comes from the &lt;code&gt;jooby-netty&lt;/code&gt; artifact in
the &lt;code&gt;io.jooby&lt;/code&gt; group on Maven. And &lt;code&gt;App&lt;/code&gt; is some
object that extends &lt;code&gt;io.jooby.Jooby&lt;/code&gt;. Since we're not using
an OOP language though we're going to try avoiding classes as much as
possible. So we'll just create a new instance
of &lt;code&gt;io.jooby.Jooby&lt;/code&gt; and add routes directly to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun template (filename context)
  &amp;quot;&amp;quot;)

(defun route (app method path handler)
  nil)

(defun register-endpoints (app)
  (route app &amp;quot;GET&amp;quot; &amp;quot;/&amp;quot;
         (lambda (ctx) &amp;quot;An index!&amp;quot;))
  (route app &amp;quot;GET&amp;quot; &amp;quot;/search&amp;quot;
         (lambda (ctx)
             (template &amp;quot;search.tmpl&amp;quot; `((&amp;quot;version&amp;quot; &amp;quot;1.0.0&amp;quot;)
                                       (&amp;quot;results&amp;quot; ,(java:jarray-from-list &amp;#39;(&amp;quot;cat&amp;quot; &amp;quot;dog&amp;quot; &amp;quot;mouse&amp;quot;)))))))
  (route app &amp;quot;GET&amp;quot; &amp;quot;/hello-world&amp;quot;
         (lambda (ctx) &amp;quot;Hello world!&amp;quot;)))

(let* ((port 8080)
       (server (jss:new &amp;#39;Netty))
       (app (jss:new &amp;#39;Jooby)))
  (register-endpoints app)
  (#&amp;quot;setOptions&amp;quot; server (#&amp;quot;setPort&amp;quot; (jss:new &amp;#39;ServerOptions) port))
  (#&amp;quot;start&amp;quot; server app)
  (#&amp;quot;join&amp;quot; server))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Easy enough. Now we just need to implement &lt;code&gt;route&lt;/code&gt;
and &lt;code&gt;template&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="implementing-java-classes-in-abcl"&gt;Implementing Java classes in ABCL&lt;/h3&gt;&lt;p&gt;We are again not going the happy path with fancy Java syntax (which is
fine if you're using Java) like the Jooby documentation
suggests. Scouring the &lt;a href="https://github.com/jooby-project/jooby/blob/2.x/jooby/src/main/java/io/jooby/Jooby.java#L546"&gt;Jooby source code
again&lt;/a&gt;
it looks like we can call &lt;code&gt;route&lt;/code&gt; on the &lt;code&gt;Jooby&lt;/code&gt;
class with a method string, a path string, and an instance of an
object implementing the &lt;code&gt;io.jooby.Route.Handler&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;Since this handler argument is an interface, we cannot cheat again by
creating an instance of it we'll have to actually create a new class
in Lisp that extends it. Thankfully there's only one method we need to
implement to satisfy this interface,
&lt;a href="https://github.com/jooby-project/jooby/blob/2.x/jooby/src/main/java/io/jooby/Route.java#L256"&gt;apply&lt;/a&gt;. It
accepts a &lt;code&gt;io.jooby.Context&lt;/code&gt; object and returns
a &lt;code&gt;java.lang.Object&lt;/code&gt;. The framework then does introspection
to figure out what exactly the object is and if it needs to transform
it into a string to be returned as an HTTP response body.&lt;/p&gt;
&lt;p&gt;To create a new class in ABCL we call &lt;code&gt;(java:jnew-runtime-class
"classname" :interfaces '("an interface name") :methods '(("method
name 1" "return type" ("first parameter type" ...) (lambda (this arg1
  ...) body))))&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun route (app method path handler)
  (#&amp;quot;route&amp;quot;
   app
   method
   path
   (jss:new (java:jnew-runtime-class
             (substitute #\$ #\/ (substitute #\$ #\- path))
             :interfaces &amp;#39;(&amp;quot;io.jooby.Route$Handler&amp;quot;)
             :methods `(
                       (&amp;quot;apply&amp;quot; &amp;quot;java.lang.Object&amp;quot; (&amp;quot;io.jooby.Context&amp;quot;)
                        (lambda (this ctx)
                          (funcall ,handler ctx))))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One thing to note is that when referring to a subclass within a file
we need to address it with the &lt;code&gt;io.jooby.Route$Handler&lt;/code&gt;
syntax rather than as you might refer to it in Java
as &lt;code&gt;io.jooby.Route.Handler&lt;/code&gt;. In the latter case ABCL
thinks &lt;code&gt;Route&lt;/code&gt; is a package when in fact it's just a class.&lt;/p&gt;
&lt;p&gt;If you run this now with &lt;code&gt;abcl --load main.lisp&lt;/code&gt;. It will
work until you hit an endpoint. The problem is how Jooby tries to
figure out the real type of the returned object.&lt;/p&gt;
&lt;p&gt;The app will crash somewhere around
&lt;a href="https://github.com/jooby-project/jooby/blob/2.x/jooby/src/main/java/io/jooby/internal/RouterImpl.java#L560"&gt;here&lt;/a&gt;
calling &lt;code&gt;analyzer.returnType(route.getHandle())&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this case it tries to &lt;a href="https://github.com/jooby-project/jooby/blob/f47eda4500bc4b76b23d24d4d77aa2ab3cc19e95/jooby/src/main/java/io/jooby/internal/RouteAnalyzer.java#L44"&gt;open and parse the (Java) source
code&lt;/a&gt;
of our application to try to find the return type for
this &lt;code&gt;apply&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;That's a problem since our code isn't Java. Through trial and error I
realized we can trick Jooby/Java/somebody into figuring out the
correct return type by adding another implementation
of &lt;code&gt;apply&lt;/code&gt; that returns a &lt;code&gt;String&lt;/code&gt; to our class.&lt;/p&gt;
&lt;p&gt;The full &lt;code&gt;route&lt;/code&gt; code now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun route (app method path handler)
  (#&amp;quot;route&amp;quot;
   app
   method
   path
   (jss:new (java:jnew-runtime-class
             (substitute #\$ #\/ (substitute #\$ #\- path))
             :interfaces &amp;#39;(&amp;quot;io.jooby.Route$Handler&amp;quot;)
             :methods `(
                       ;; Need to define this one to make Jooby figure out the return type
                       ;; Otherwise it tries to read &amp;quot;this file&amp;quot; which isn&amp;#39;t a Java file so cannot be parsed
                       (&amp;quot;apply&amp;quot; &amp;quot;java.lang.String&amp;quot; (&amp;quot;io.jooby.Context&amp;quot;)
                        (lambda (this ctx) nil))
                       ;; This one actually gets called
                       (&amp;quot;apply&amp;quot; &amp;quot;java.lang.Object&amp;quot; (&amp;quot;io.jooby.Context&amp;quot;)
                        (lambda (this ctx)
                          (funcall ,handler ctx))))))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You may wonder, why keep the original method around? Well it's because
during reflection, ABCL says no such method that
returns &lt;code&gt;String&lt;/code&gt; exists in the &lt;code&gt;Handler&lt;/code&gt;
interface. That's fair I guess.&lt;/p&gt;
&lt;h3 id="implementing-the-template"&gt;Implementing the template&lt;/h3&gt;&lt;p&gt;The Java example on the &lt;a href="https://pebbletemplates.io/"&gt;Pebble homepage&lt;/a&gt;
is perfect:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;PebbleEngine engine = new PebbleEngine.Builder().build();
PebbleTemplate compiledTemplate = engine.getTemplate(&amp;quot;home.html&amp;quot;);

Map&amp;lt;String, Object&amp;gt; context = new HashMap&amp;lt;&amp;gt;();
context.put(&amp;quot;name&amp;quot;, &amp;quot;Mitchell&amp;quot;);

Writer writer = new StringWriter();
compiledTemplate.evaluate(writer, context);

String output = writer.toString();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can easily translate this into Lisp:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun hashmap (alist)
  (let ((map (jss:new &amp;#39;HashMap)))
    (loop for el in alist
         do (#&amp;quot;put&amp;quot; map (car el) (cadr el)))
    map))

(defun template (filename context-alist)
  (let* ((ctx (hashmap context-alist))
         (path (java:jstatic &amp;quot;of&amp;quot; &amp;quot;java.nio.file.Path&amp;quot; filename))
         (file (#&amp;quot;readString&amp;quot; &amp;#39;java.nio.file.Files path))
         (engine (#&amp;quot;build&amp;quot; (jss:new &amp;#39;PebbleEngine$Builder)))
         (compiledTmpl (#&amp;quot;getTemplate&amp;quot; engine filename))
         (writer (jss:new &amp;#39;java.io.StringWriter)))
    (#&amp;quot;evaluate&amp;quot; compiledTmpl writer ctx)
    (#&amp;quot;toString&amp;quot; writer)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if you run this &lt;code&gt;abcl --load main.lisp&lt;/code&gt; and hit this
&lt;code&gt;/search&lt;/code&gt; endpoint, it will blow up saying "no such method"
exists at the call to &lt;code&gt;Path.of(filename)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After digging around I saw it was because
&lt;a href="https://docs.oracle.com/en/java/javase/16/docs/api/java.base/java/nio/file/Path.html#of(java.lang.String,java.lang.String...%29"&gt;Path.of&lt;/a&gt;
is a variadic function.&lt;/p&gt;
&lt;p&gt;And while there are &lt;a href="https://abcl.org/trac/changeset/15234"&gt;examples
of&lt;/a&gt; using variadic functions
when the function only has a single parameter like
&lt;code&gt;java.util.Arrays.asList(T ...)&lt;/code&gt;, employing that same
technique here continued to result in "no such method":&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;         (path (java:jstatic "of" "java.nio.file.Path" filename (jnew-array "java.lang.String" 0)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Eventually I found an &lt;a href="https://stackoverflow.com/questions/20440839/cant-invoke-method-with-varargs-parameters-with-reflection-nosuchmethodexcept"&gt;example of someone doing reflect/invoke on this
kind of a function
call&lt;/a&gt;
and tried this logic on a local copy of the ABCL source code.&lt;/p&gt;
&lt;p&gt;It worked. So I opened a &lt;a href="https://github.com/armedbear/abcl/pull/379"&gt;pull request&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So the full working code for &lt;code&gt;template&lt;/code&gt; is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun template (filename context-alist)
  (let* ((ctx (hashmap context-alist))
         (path (java:jstatic &amp;quot;of&amp;quot; &amp;quot;java.nio.file.Path&amp;quot; filename (java:jnew-array &amp;quot;java.lang.String&amp;quot; 0)))
         (file (#&amp;quot;readString&amp;quot; &amp;#39;java.nio.file.Files path))
         (engine (#&amp;quot;build&amp;quot; (jss:new &amp;#39;PebbleEngine$Builder)))
         (compiledTmpl (#&amp;quot;getTemplate&amp;quot; engine filename))
         (writer (jss:new &amp;#39;java.io.StringWriter)))
    (#&amp;quot;evaluate&amp;quot; compiledTmpl writer ctx)
    (#&amp;quot;toString&amp;quot; writer)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to get this diff running locally:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ mkdir ~/vendor
$ cd ~/vendor
$ git clone https://github.com/eatonphil/abcl
$ cd abcl
$ git checkout pe/more-variadic
$ sudo {dnf/brew/apt} install ant maven
$ ant -f build.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to run &lt;code&gt;main.lisp&lt;/code&gt; using this diff:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ~/vendor/abcl/abcl --load main.lisp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to hit the API:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl localhost:8080/search
&amp;lt;html&amp;gt;
&amp;lt;title&amp;gt;Version 1.0.0&amp;lt;/title&amp;gt;
  &amp;lt;h2&amp;gt;cat&amp;lt;/h2&amp;gt;
  &amp;lt;h2&amp;gt;dog&amp;lt;/h2&amp;gt;
  &amp;lt;h2&amp;gt;mouse&amp;lt;/h2&amp;gt;
&amp;lt;/html&amp;gt;
$ curl localhost:8080/hello-world
Hello world!%
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Phew! Easy peasy.&lt;/p&gt;
&lt;h3 id="next-up"&gt;Next up&lt;/h3&gt;&lt;p&gt;I'm porting this example to Kawa to see how it fares. Blog post to come.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;In a ridiculous attempt to prove an internet wrong about the practicality of Lisp (Common Lisp specifically), I tried to get a simple (but realistic) web app running. After four days and a patch to ABCL I got something working.&lt;a href="https://t.co/5UUWNR8Wnn"&gt;https://t.co/5UUWNR8Wnn&lt;/a&gt; &lt;a href="https://t.co/cZsx32IlKD"&gt;pic.twitter.com/cZsx32IlKD&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1423345414279942150?ref_src=twsrc%5Etfw"&gt;August 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/practical-common-lisp-on-the-jvm.html</guid><pubDate>Thu, 05 Aug 2021 00:00:00 +0000</pubDate></item><item><title>Writing an efficient object previewer for JavaScript</title><link>http://notes.eatonphil.com/writing-an-efficient-javascript-object-previewer.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-07-15-writing-an-efficient-javascript-object-previewer.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-07-15-writing-an-efficient-javascript-object-previewer.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-an-efficient-javascript-object-previewer.html</guid><pubDate>Thu, 15 Jul 2021 00:00:00 +0000</pubDate></item><item><title>React without webpack: fast path to a working app from scratch</title><link>http://notes.eatonphil.com/react-without-webpack.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-07-08-react-without-webpack.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-07-08-react-without-webpack.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/react-without-webpack.html</guid><pubDate>Thu, 08 Jul 2021 00:00:00 +0000</pubDate></item><item><title>Controlled HTML select element in React has weird default UX</title><link>http://notes.eatonphil.com/controlled-select-element-in-react-has-weird-ux.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-06-25-select-in-react-broken-by-default.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-06-25-select-in-react-broken-by-default.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/controlled-select-element-in-react-has-weird-ux.html</guid><pubDate>Fri, 25 Jun 2021 00:00:00 +0000</pubDate></item><item><title>Leaders, you need to share organization success stories more frequently</title><link>http://notes.eatonphil.com/leaders-share-company-success-stories.html</link><description>&lt;p&gt;This post goes out to anyone who leads a team: managers, directors,
VPs, executives. You need to share organization success stories with
your organization on a regular and frequent basis. Talk about sales
wins, talk about new services released, talk about the positive impact
of a recent organizational change. Just get in front of your entire
organization and tell them how the organization is making a positive
difference.&lt;/p&gt;
&lt;p&gt;Do this at least every other week.&lt;/p&gt;
&lt;p&gt;And in case it's not clear, by "success stories" I don't mean bullshit,
or opinions. I mean concrete, measurable things that moved the
organization forward.&lt;/p&gt;
&lt;p&gt;Everyone in your organization is contributing to these stories and
it's your job to feed the stories back.&lt;/p&gt;
&lt;p&gt;Leaders have a tendency to hear about successes but don't always
remember to propagate the stories down. I've been guilty of this
myself. This post is your (and my own) friendly reminder.&lt;/p&gt;
&lt;p&gt;If you don't keep reminding your folks their organization is making a
positive impact, they're going to forget it. You'll miss out on the
freely available chance to give reassurance to your best people.&lt;/p&gt;
&lt;p&gt;Talented folks want to be invested in an organization that is
succeeding.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Wrote a post for all the people managers, directors, VPs out there: you need to regularly share success stories with your whole organization. Everyone wants to be part of an organization that is doing good work.&lt;a href="https://t.co/XgaY5Ri1tA"&gt;https://t.co/XgaY5Ri1tA&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1407451413156929537?ref_src=twsrc%5Etfw"&gt;June 22, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/leaders-share-company-success-stories.html</guid><pubDate>Tue, 22 Jun 2021 00:00:00 +0000</pubDate></item><item><title>Languages you can run in the browser, part 1: Python, JavaScript, SQLite</title><link>http://notes.eatonphil.com/languages-you-can-run-in-the-browser.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://datastation.multiprocess.io/blog/2021-06-16-languages-you-can-run-in-the-browser.html'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://datastation.multiprocess.io/blog/2021-06-16-languages-you-can-run-in-the-browser.html"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/languages-you-can-run-in-the-browser.html</guid><pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate></item><item><title>Coolest hard-tech companies in NYC 2021</title><link>http://notes.eatonphil.com/coolest-tech-companies-in-nyc-2021.html</link><description>&lt;p&gt;For years I've kept a private list of really cool tech companies in
NYC. Now that I'm funemployed it's the perfect time to publish. This
list is influenced by 1) my perception of the difficulty of the
engineering behind the product and 2) the company's educational and
OSS presence.&lt;/p&gt;
&lt;p&gt;With no further ado and in no particular order, here's my list!&lt;/p&gt;
&lt;h3 id="backtrace"&gt;Backtrace&lt;/h3&gt;&lt;p&gt;This company builds a product for debugging
mobile crashes. Your app produces a crash dump and their debugger will
help you figure out what went wrong. That's freaking awesome.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://backtrace.io"&gt;https://backtrace.io&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="equinix-metal-(previously-packet)"&gt;Equinix Metal (previously Packet)&lt;/h3&gt;&lt;p&gt;This company provides an API around scheduling hardware servers in
their datacenters, not virtual machines. That's nuts.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://packet.com"&gt;https://packet.com&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="digital-ocean"&gt;Digital Ocean&lt;/h3&gt;&lt;p&gt;Ok I used to work for Linode and am still a massive fan but I love all
the clouds and this post is about NYC not Philly. If you want to learn
how Linux works you have to work here.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.digitalocean.com/"&gt;https://www.digitalocean.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="ns1"&gt;NS1&lt;/h3&gt;&lt;p&gt;This company does DNS. Seeing as &lt;a href="https://www.cyberciti.biz/humour/a-haiku-about-dns/"&gt;it was
DNS&lt;/a&gt;, if you want
to understand how the internet works go work for this group.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ns1.com/"&gt;https://ns1.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="squarespace"&gt;SquareSpace&lt;/h3&gt;&lt;p&gt;The first program I made in 7th grade was a Java program that
generated HTML from terminal prompts in my first attempt at a
CMS. Stuff that builds stuff is amazing and SquareSpace is kinda OG.&lt;/p&gt;
&lt;p&gt;They also just IPO-ed so the comp won't be imaginary!&lt;/p&gt;
&lt;p&gt;Disclosure: my wife works here, but they've been on my list longer
than that.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.squarespace.com/"&gt;https://www.squarespace.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="grafana"&gt;Grafana&lt;/h3&gt;&lt;p&gt;Amazing platform. Everyone who can't afford Splunk or doesn't want to
buy competitor's products uses ElasticSearch and Grafana. I didn't
realize until double-checking my research that Grafana is even based
in NYC. Let's hope they're hiring developers here.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://grafana.com/"&gt;https://grafana.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="frame.io"&gt;Frame.io&lt;/h3&gt;&lt;p&gt;It's like Figma for video. Clearly the future.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.frame.io/"&gt;https://www.frame.io/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="datadog"&gt;DataDog&lt;/h3&gt;&lt;p&gt;DataDog feels like the only real competitor in the hosted server analytics.&lt;/p&gt;
&lt;p&gt;Their stock has been doing surprisingly well, or maybe I'm just tired
from WeWork, Uber, et al.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.datadoghq.com/"&gt;https://www.datadoghq.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="chronosphere"&gt;Chronosphere&lt;/h3&gt;&lt;p&gt;I'm a sucker for startups doing hosted data and search because that's
really hard. Chronosphere does Uber-scale log storage/analysis.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://chronosphere.io/"&gt;https://chronosphere.io/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="cockroach-labs"&gt;Cockroach Labs&lt;/h3&gt;&lt;p&gt;Worst company name but maybe one of the single coolest products in
NYC. They built a PostgreSQL compatible scalable platform in
Go. Everything about that is amazing.&lt;/p&gt;
&lt;p&gt;They've also turned down my application like 5 times now though so
maybe they're very picky. :)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.cockroachlabs.com/"&gt;https://www.cockroachlabs.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="mongodb"&gt;MongoDB&lt;/h3&gt;&lt;p&gt;It's cloud scale! Need more be said.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.mongodb.com/"&gt;https://www.mongodb.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="trail-of-bits"&gt;Trail of Bits&lt;/h3&gt;&lt;p&gt;I don't actually understand what they do or if they have a product but
their &lt;a href="https://github.com/trailofbits"&gt;Github presence&lt;/a&gt; is amazing and
they're dedicated to educating the community which is one of the most
important things I think a company can do.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.trailofbits.com/"&gt;https://www.trailofbits.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="capsule8"&gt;Capsule8&lt;/h3&gt;&lt;p&gt;I moved to NYC for this company because the founders and product are
insane. If you want to learn how compilers and Linux don't work,
you've got to come here.&lt;/p&gt;
&lt;p&gt;Disclosure: I own stock.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://capsule8.com/"&gt;https://capsule8.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="two-sigma"&gt;Two Sigma&lt;/h3&gt;&lt;p&gt;Algorithmic trading? Maybe the smartest guys in NYC? They don't accept
candidates without bachelor's degrees or they just don't like me. ;)
They also host the only good tech meetups in NYC: Linux User Group and
Papers We Love.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.twosigma.com/"&gt;https://www.twosigma.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="jane-street"&gt;Jane Street&lt;/h3&gt;&lt;p&gt;Another algorithmic trading company but this time with OCaml. They're
so crazy &lt;a href="https://blog.janestreet.com/what-the-interns-have-wrought-2018/"&gt;you should see what the intern
built&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.janestreet.com/"&gt;https://www.janestreet.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="vimeo"&gt;Vimeo&lt;/h3&gt;&lt;p&gt;Everybody loves an underdog story. And the &lt;a href="https://www.linkedin.com/pulse/now-shes-ceo-vimeo-after-rejected-dozens-companies-mamta-shah-/"&gt;CEO seems really
cool&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://vimeo.com/"&gt;https://vimeo.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="etsy"&gt;Etsy&lt;/h3&gt;&lt;p&gt;Their blog posts and engineering organization philosophy are widely
regarded. And they've got a sweet headquarters in Brooklyn.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.etsy.com/"&gt;https://www.etsy.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="sisense"&gt;Sisense&lt;/h3&gt;&lt;p&gt;If you're not using ElasticSearch and you're not using Splunk, you
might be using Sisense. Again, I'm a big sucker for data and analytics
platforms.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.sisense.com/"&gt;https://www.sisense.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="codeacademy"&gt;CodeAcademy&lt;/h3&gt;&lt;p&gt;I am 100% on board with giving people opportunities in tech.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.codecademy.com/"&gt;https://www.codecademy.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="stack-overflow"&gt;Stack Overflow&lt;/h3&gt;&lt;p&gt;They were just bought! But they still exist I suppose. If you love
.NET you've got to work here.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/"&gt;https://stackoverflow.com/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="that's-it!"&gt;That's it!&lt;/h3&gt;&lt;p&gt;Tell me what you think and if I'm missing any hard-tech companies in
NYC. I'm sure I am.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Here&amp;#39;s my light-hearted take on some of the coolest tech companies in NYC in 2021&lt;a href="https://twitter.com/Frame_io?ref_src=twsrc%5Etfw"&gt;@Frame_io&lt;/a&gt; &lt;a href="https://twitter.com/equinixmetal?ref_src=twsrc%5Etfw"&gt;@equinixmetal&lt;/a&gt; &lt;a href="https://twitter.com/digitalocean?ref_src=twsrc%5Etfw"&gt;@digitalocean&lt;/a&gt; &lt;a href="https://twitter.com/capsule8?ref_src=twsrc%5Etfw"&gt;@capsule8&lt;/a&gt; &lt;a href="https://twitter.com/NS1?ref_src=twsrc%5Etfw"&gt;@NS1&lt;/a&gt; &lt;a href="https://twitter.com/grafana?ref_src=twsrc%5Etfw"&gt;@grafana&lt;/a&gt; &lt;a href="https://twitter.com/CockroachDB?ref_src=twsrc%5Etfw"&gt;@CockroachDB&lt;/a&gt; &lt;a href="https://twitter.com/squarespace?ref_src=twsrc%5Etfw"&gt;@squarespace&lt;/a&gt; &lt;a href="https://twitter.com/chronosphereio?ref_src=twsrc%5Etfw"&gt;@chronosphereio&lt;/a&gt; &lt;a href="https://twitter.com/datadoghq?ref_src=twsrc%5Etfw"&gt;@datadoghq&lt;/a&gt; &lt;a href="https://twitter.com/MongoDB?ref_src=twsrc%5Etfw"&gt;@MongoDB&lt;/a&gt; &lt;a href="https://twitter.com/trailofbits?ref_src=twsrc%5Etfw"&gt;@trailofbits&lt;/a&gt; &lt;a href="https://twitter.com/twosigma?ref_src=twsrc%5Etfw"&gt;@twosigma&lt;/a&gt; &lt;a href="https://twitter.com/Vimeo?ref_src=twsrc%5Etfw"&gt;@Vimeo&lt;/a&gt; &lt;a href="https://twitter.com/Etsy?ref_src=twsrc%5Etfw"&gt;@Etsy&lt;/a&gt; and more&lt;a href="https://t.co/ZAcvptvLbZ"&gt;https://t.co/ZAcvptvLbZ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1400815765117353989?ref_src=twsrc%5Etfw"&gt;June 4, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/coolest-tech-companies-in-nyc-2021.html</guid><pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate></item><item><title>Writing a Jinja-inspired template library in Python</title><link>http://notes.eatonphil.com/writing-a-template-library-in-python.html</link><description>&lt;p&gt;In this post we'll build a minimal text templating library in Python
inspired by Jinja. It will be able to display variables and iterate
over arrays.&lt;/p&gt;
&lt;p&gt;By the end of this article, with around 300 lines of code, we'll be
able to create this program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;from pytemplate import eval_template

template = &amp;#39;&amp;#39;&amp;#39;
&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
  {% for-in(post, posts) %}
  &amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;{{ get(post, &amp;#39;title&amp;#39;) }}&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;
      {{ get(post, &amp;#39;body&amp;#39;) }}
    &amp;lt;/p&amp;gt;
  &amp;lt;/article&amp;gt;
  {% endfor-in %}
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&amp;#39;&amp;#39;&amp;#39;

env = {
    &amp;#39;posts&amp;#39;: [
        {
            &amp;#39;title&amp;#39;: &amp;#39;Hello world!&amp;#39;,
            &amp;#39;body&amp;#39;: &amp;#39;This is my first post!&amp;#39;,
        },
        {
            &amp;#39;title&amp;#39;: &amp;#39;Take two&amp;#39;,
            &amp;#39;body&amp;#39;: &amp;#39;This is a second post.&amp;#39;,
        },
    ],
}

print(eval_template(template, env))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That runs and produces what we expect:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ python3 test.py

&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;

  &amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;
      This is my first post!
    &amp;lt;/p&amp;gt;
  &amp;lt;/article&amp;gt;

  &amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;Take two&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;
      This is a second post.
    &amp;lt;/p&amp;gt;
  &amp;lt;/article&amp;gt;

  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All code is available on
&lt;a href="https://github.com/eatonphil/pytemplate"&gt;Github&lt;/a&gt;. Let's dig in.&lt;/p&gt;
&lt;h3 id="specification"&gt;Specification&lt;/h3&gt;&lt;p&gt;In this templating language, pytemplate, &lt;code&gt;{% $function () %}
... {% end$function %}&lt;/code&gt; blocks are specially evaluated depending
on the particular function being called. For example, the &lt;code&gt;for-in
($iter_name, $array)&lt;/code&gt; function will duplicate its children for
every element in &lt;code&gt;$array&lt;/code&gt;. Within the body of the loop, the
variable &lt;code&gt;$iter_name&lt;/code&gt; will exist and be set to the current
element in the array.&lt;/p&gt;
&lt;p&gt;While we won't implement it here, you can imagine what the &lt;code&gt;if
($test)&lt;/code&gt; block function might do.&lt;/p&gt;
&lt;h3 id="arguments,-expressions,-function-calls:-nodes"&gt;Arguments, expressions, function calls: nodes&lt;/h3&gt;&lt;p&gt;Function arguments are expressions (or &lt;code&gt;nodes&lt;/code&gt; as we'll
call them). They can be strings (surrounded by single quotes),
identifiers found in a provided dictionary (or
&lt;code&gt;environment&lt;/code&gt; as we'll call it), or nested function calls
(also called nodes).&lt;/p&gt;
&lt;h3 id="non-blocks:-tags"&gt;Non-blocks: tags&lt;/h3&gt;&lt;p&gt;The non-block syntax &lt;code&gt;{{ ... }}&lt;/code&gt; are just called tags. The
inside of a tag is a node and is evaluated the same way a function
argument is.&lt;/p&gt;
&lt;h3 id="architecture"&gt;Architecture&lt;/h3&gt;&lt;p&gt;We'll break up the library into a few main parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lexer for the node language&lt;/li&gt;
&lt;li&gt;Parser for the node language&lt;/li&gt;
&lt;li&gt;Lexer for blocks, tags, and text&lt;/li&gt;
&lt;li&gt;Parser for blocks, tags, and text&lt;/li&gt;
&lt;li&gt;Interpreter that takes an AST and an environment dictionary and produces text&lt;/li&gt;
&lt;li&gt;An entrypoint to tie all the above together&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll tackle these aspects in roughly reverse order.&lt;/p&gt;
&lt;h3 id="entrypoint"&gt;Entrypoint&lt;/h3&gt;&lt;p&gt;When we call the library we want to be able to just accept a template
string and an environment dictionary. The result of the entrypoint
will be the evaluated template.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;import io


def eval_template(template: str, env: dict) -&amp;gt; str:
    tokens = lex(template)
    ast, _ = parse(tokens)
    with io.StringIO() as memfd:
        interpret(memfd, ast, env)
        return memfd.getvalue()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where lex, parse, and interpret have to do with the block- and
tag-level language.&lt;/p&gt;
&lt;h3 id="block,-tag-and-text-lexing"&gt;Block, tag and text lexing&lt;/h3&gt;&lt;p&gt;This process is responsible for turning the template string into an
array of tokens. To make the code simpler, lexing for the function
call and expression language is done separately. At this stage all
we'll look for is tokens consisting of block and tag end and beginning
markers. So
just &lt;code&gt;{%&lt;/code&gt;, &lt;code&gt;%}&lt;/code&gt;, &lt;code&gt;{{&lt;/code&gt;, &lt;code&gt;}}&lt;/code&gt;. If
a token is not one of these, it is regular text.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;BLOCK_OPEN = &amp;#39;{%&amp;#39;
BLOCK_CLOSE = &amp;#39;%}&amp;#39;

TAG_OPEN = &amp;#39;{{&amp;#39;
TAG_CLOSE = &amp;#39;}}&amp;#39;


def getelement(source, cursor):
    if cursor &amp;lt; 0:
        return None
    if cursor &amp;lt; len(source):
        return source[cursor]
    return None


def lex(source):
    tokens = []
    current = &amp;#39;&amp;#39;
    cursor = 0
    while cursor &amp;lt; len(source):
        char = getelement(source, cursor)
        if char == &amp;#39;{&amp;#39;:
            # Handle escaping {
            if getelement(source, cursor-1) == &amp;#39;{&amp;#39;:
                cursor += 1
                continue

            next_char = getelement(source, cursor+1)
            if next_char in [&amp;#39;%&amp;#39;, &amp;#39;{&amp;#39;]:
                if current:
                    tokens.append({
                        &amp;#39;value&amp;#39;: current,
                        &amp;#39;cursor&amp;#39;: cursor - len(current),
                    })
                    current = &amp;#39;&amp;#39;

                tokens.append({
                    &amp;#39;value&amp;#39;: BLOCK_OPEN if next_char == &amp;#39;%&amp;#39; else TAG_OPEN,
                    &amp;#39;cursor&amp;#39;: cursor,
                })
                cursor += 2
                continue

        if char in [&amp;#39;%&amp;#39;, &amp;#39;}&amp;#39;]:
            # Handle escaping % and }
            if getelement(source, cursor-1) == char:
                cursor += 1
                continue

            if getelement(source, cursor+1) != &amp;#39;}&amp;#39;:
                cursor += 1
                continue

            if current:
                tokens.append({
                    &amp;#39;value&amp;#39;: current,
                    &amp;#39;cursor&amp;#39;: cursor - len(current),
                })
                current = &amp;#39;&amp;#39;

            tokens.append({
                &amp;#39;value&amp;#39;: BLOCK_CLOSE if char == &amp;#39;%&amp;#39; else TAG_CLOSE,
                &amp;#39;cursor&amp;#39;: cursor,
            })
            cursor += 2
            continue

        current += getelement(source, cursor)
        cursor += 1

    if current:
        tokens.append({
            &amp;#39;value&amp;#39;: current,
            &amp;#39;cursor&amp;#39;: cursor - len(current),
        })

    return tokens
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it for lexing!&lt;/p&gt;
&lt;h3 id="block,-tag-and-text-parsing"&gt;Block, tag and text parsing&lt;/h3&gt;&lt;p&gt;Next up is a matter of finding the ending/closing patterns in the array of tokens. There are a few main rules we'll look for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every open tag symbol &lt;code&gt;{{&lt;/code&gt; must be followed by a text token then a closing tag symbol &lt;code&gt;}}&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;The text within the open and close tag must parse into a valid expression (we'll define this logic later)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every block symbol &lt;code&gt;{%&lt;/code&gt; must be followed by a text token then an end of block symbol &lt;code&gt;%}&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;The text token within the open and close block must parse into a valid function call (we'll define this logic later)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Every block must have a matching end block where the text in the end block is &lt;code&gt;end&lt;/code&gt; concatenated to the beginning of the function being called in the start block&lt;ul&gt;
&lt;li&gt;The text between two blocks can contain nested blocks or tags&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let's codify that:&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse(tokens, end_of_block_marker=None):
    cursor = 0
    ast = []
    while cursor &amp;lt; len(tokens):
        t = getelement(tokens, cursor)
        value = t[&amp;#39;value&amp;#39;]
        if value == TAG_OPEN:
            if getelement(tokens, cursor+2)[&amp;#39;value&amp;#39;] != TAG_CLOSE:
                raise Exception(&amp;#39;Expected closing tag&amp;#39;)

            node_tokens = lex_node(getelement(tokens, cursor+1)[&amp;#39;value&amp;#39;])
            node_ast = parse_node(node_tokens)
            ast.append({
                &amp;#39;type&amp;#39;: &amp;#39;tag&amp;#39;,
                &amp;#39;value&amp;#39;: node_ast,
            })
            cursor += 3
            continue

        if value == TAG_CLOSE:
            raise Exception(&amp;#39;Expected opening tag&amp;#39;)

        if value == BLOCK_OPEN:
            if getelement(tokens, cursor+2)[&amp;#39;value&amp;#39;] != BLOCK_CLOSE:
                raise Exception(&amp;#39;Expected end of block open&amp;#39;)

            block = getelement(tokens, cursor+1)
            node_tokens = lex_node(block[&amp;#39;value&amp;#39;])
            node_ast = parse_node(node_tokens)
            if end_of_block_marker and &amp;#39;end&amp;#39;+end_of_block_marker == node_ast[&amp;#39;value&amp;#39;]:
                return ast, cursor+3

            child, cursor_offset = parse(tokens[cursor+3:], node_ast[&amp;#39;value&amp;#39;])
            if cursor_offset == 0:
                raise Exception(&amp;#39;Failed to find end of block&amp;#39;)

            ast.append({
                &amp;#39;type&amp;#39;: &amp;#39;block&amp;#39;,
                &amp;#39;value&amp;#39;: node_ast,
                &amp;#39;child&amp;#39;: child,
            })
            cursor += cursor_offset + 3
            continue

        if value == BLOCK_CLOSE:
            raise Exception(&amp;#39;Expected start of block open&amp;#39;)

        ast.append({
            &amp;#39;type&amp;#39;: &amp;#39;text&amp;#39;,
            &amp;#39;value&amp;#39;: t,
        })
        cursor += 1

    return ast, cursor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for parsing blocks and tags. Now we have to get into the
node language.&lt;/p&gt;
&lt;h3 id="node-lexing"&gt;Node lexing&lt;/h3&gt;&lt;p&gt;In the node language, everything is either a literal or a function
call. Whitespace is ignored. The only special symbols in the node
language are commas and parentheses.&lt;/p&gt;
&lt;p&gt;So to break the text into tokens we just iterate over all characters
until we find whitespace or a symbol. Accumulate the characters that
are not either. Add everything but whitespace to the list of tokens.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex_node(source):
    tokens = []
    cursor = 0
    current = &amp;#39;&amp;#39;
    while cursor &amp;lt; len(source):
        char = getelement(source, cursor)
        if char in [&amp;#39;\r&amp;#39;, &amp;#39;\t&amp;#39;, &amp;#39;\n&amp;#39;, &amp;#39; &amp;#39;]:
            if current:
                tokens.append({
                    &amp;#39;value&amp;#39;: current,
                    &amp;#39;type&amp;#39;: &amp;#39;literal&amp;#39;,
                })
                current = &amp;#39;&amp;#39;

            cursor += 1
            continue

        if char in [&amp;#39;(&amp;#39;, &amp;#39;)&amp;#39;, &amp;#39;,&amp;#39;]:
            if current:
                tokens.append({
                    &amp;#39;value&amp;#39;: current,
                    &amp;#39;type&amp;#39;: &amp;#39;literal&amp;#39;,
                })
                current = &amp;#39;&amp;#39;

            tokens.append({
                &amp;#39;value&amp;#39;: char,
                &amp;#39;type&amp;#39;: &amp;#39;syntax&amp;#39;,
            })
            cursor += 1
            continue

        current += char
        cursor +=1

    return tokens
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for node lexing.&lt;/p&gt;
&lt;h3 id="node-parsing"&gt;Node parsing&lt;/h3&gt;&lt;p&gt;We'll break this up into two functions. The first is just for parsing
literals and function calls.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse_node(tokens):
    cursor = 0
    ast = None
    while cursor &amp;lt; len(tokens):
        t = getelement(tokens, cursor)
        if t[&amp;#39;type&amp;#39;] != &amp;#39;literal&amp;#39;:
            raise Exception(&amp;#39;Expected literal&amp;#39;)
        cursor += 1

        next_t = getelement(tokens, cursor)
        if not next_t:
            ast = t
            break

        if next_t[&amp;#39;value&amp;#39;] != &amp;#39;(&amp;#39;:
            ast = t
            break

        cursor += 1

        if next_t[&amp;#39;value&amp;#39;] == &amp;#39;(&amp;#39;:
            args, cursor = parse_node_args(tokens[cursor:])
            ast = {
                &amp;#39;type&amp;#39;: &amp;#39;function&amp;#39;,
                &amp;#39;value&amp;#39;: t[&amp;#39;value&amp;#39;].strip(),
                &amp;#39;args&amp;#39;: args,
            }
            cursor += 2

        break

    if cursor != len(tokens):
        raise Exception(&amp;#39;Failed to parse node: &amp;#39; + tokens[cursor][&amp;#39;value&amp;#39;])

    return ast
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second is for parsing function call arguments.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse_node_args(tokens):
    args = []
    cursor = 0
    while cursor &amp;lt; len(tokens):
        t = getelement(tokens, cursor)
        if t[&amp;#39;value&amp;#39;] == &amp;#39;)&amp;#39;:
            return args, cursor + 1

        if len(args) and t[&amp;#39;value&amp;#39;] == &amp;#39;,&amp;#39;:
            cursor += 1
        elif len(args) and t[&amp;#39;value&amp;#39;] != &amp;#39;,&amp;#39;:
            raise Exception(&amp;#39;Expected comma to separate args&amp;#39;)

        args.append(getelement(tokens, cursor))
        cursor += 1

    return args, cursor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for parsing and lexing the entire whole template and
node language!&lt;/p&gt;
&lt;h3 id="interpreting"&gt;Interpreting&lt;/h3&gt;&lt;p&gt;Interpreting is a matter of iterating over the AST recursively,
writing out literal text, evaluating the contents of tags, and doing
special processing for blocks.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python3"&gt;def interpret(outfd, ast, env):
    for item in ast:
        item_type = item[&amp;#39;type&amp;#39;]
        node = item[&amp;#39;value&amp;#39;]

        if item_type == &amp;#39;text&amp;#39;:
            outfd.write(node[&amp;#39;value&amp;#39;])
            continue

        if item_type == &amp;#39;tag&amp;#39;:
            tag_value = interpret_node(node, env)
            outfd.write(tag_value)
            continue

        if item_type == &amp;#39;block&amp;#39;:
            interpret_block(outfd, node, item[&amp;#39;child&amp;#39;], env)
            continue

        raise Exception(&amp;#39;Unknown type: &amp;#39; + item_type)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="intepreting-nodes"&gt;Intepreting nodes&lt;/h4&gt;&lt;p&gt;A node is one of two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A literal which is either a&lt;ul&gt;
&lt;li&gt;String if surrounded by single quotes&lt;/li&gt;
&lt;li&gt;Otherwise an identifier to be looked up in the environment dictionary&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Or a function call&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def interpret_node(node, env):
    if node[&amp;#39;type&amp;#39;] == &amp;#39;literal&amp;#39;:
        # Is a string
        if node[&amp;#39;value&amp;#39;][0] == &amp;quot;&amp;#39;&amp;quot; and node[&amp;#39;value&amp;#39;][-1] == &amp;quot;&amp;#39;&amp;quot;:
            return node[&amp;#39;value&amp;#39;][1:-1]

        # Default to an env lookup
        return env[node[&amp;#39;value&amp;#39;]]

    function = node[&amp;#39;value&amp;#39;]
    args = node[&amp;#39;args&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's define &lt;code&gt;==&lt;/code&gt; which checks if all args are equal. First
we have to interpret all args and then we return True if they are all
equal.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;    if function == &amp;#39;==&amp;#39;:
        arg_vals = [interpret_node(arg, env) for arg in args]
        if arg_vals.count(arg_vals[0]) == len(arg_vals):
            return True

        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let's define a helper for retrieving an entry from a dictionary,
called &lt;code&gt;get&lt;/code&gt;. This will evaluate its first arg and assume
it is a dictionary. Then it will evaluate its second arg and assume it
is a key in the dictionary. Then it will return the result of looking
up the key in the dictionary.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;    if function == &amp;#39;get&amp;#39;:
        arg_vals = [interpret_node(arg, env) for arg in args]
        return arg_vals[0][arg_vals[1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if its neither of these supported functions, just raise an error.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;    raise Exception(&amp;#39;Unknown function: &amp;#39; + function)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-blocks"&gt;Interpreting blocks&lt;/h4&gt;&lt;p&gt;Blocks are just a little different than a generic node. In addition to
being evaluated they act on a child AST within the start and end of
the block.&lt;/p&gt;
&lt;p&gt;For example, in an &lt;code&gt;if&lt;/code&gt; block we will evaluate its argument
and recursively call &lt;code&gt;interpret&lt;/code&gt; on the child AST if the argument is
truthy.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def interpret_block(outfd, node, child, env):
    function = node[&amp;#39;value&amp;#39;]
    args = node[&amp;#39;args&amp;#39;]
    if function == &amp;#39;if&amp;#39; and interpret_node(node, env):
        interpret(outfd, child, env)
        return
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And for &lt;code&gt;for-in&lt;/code&gt; we will use the first argument as the name
of an identifier to be copied into a child environment
dictionary. We'll interpret the second argument and then iterate over
it, calling &lt;code&gt;interpret&lt;/code&gt; recursively for each item in the
array and passing the child environment dictionary so it has access to
the current element.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;    if function == &amp;#39;for-in&amp;#39;:
        loop_variable = args[1]
        loop_iter_variable = args[0][&amp;#39;value&amp;#39;]

        for elem in interpret_node(loop_variable, env):
            child_env = env.copy()
            child_env[loop_iter_variable] = elem
            interpret(outfd, child, child_env)

        return
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just like before, if we see a block we don't support yet, throw an
error.&lt;/p&gt;
&lt;p&gt;&lt;span class="code-caption"&gt;pytemplate.py&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;    raise Exception(&amp;#39;Unsupported block node function: &amp;#39; + function)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's that. :)&lt;/p&gt;
&lt;h3 id="run-it"&gt;Run it&lt;/h3&gt;&lt;p&gt;Now we can give the example from the beginning a shot.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ python3 test.py

&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;

  &amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;
      This is my first post!
    &amp;lt;/p&amp;gt;
  &amp;lt;/article&amp;gt;

  &amp;lt;article&amp;gt;
    &amp;lt;h1&amp;gt;Take two&amp;lt;/h1&amp;gt;
    &amp;lt;p&amp;gt;
      This is a second post.
    &amp;lt;/p&amp;gt;
  &amp;lt;/article&amp;gt;

  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty sweet for only 300 lines of Python!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Been wanting to write a Python template library ever since I failed trying to do so years ago in Standard ML. Here&amp;#39;s my take on a Jinja-like library!&lt;a href="https://t.co/P1nAV6fSxk"&gt;https://t.co/P1nAV6fSxk&lt;/a&gt; &lt;a href="https://t.co/DbXQt1JYx8"&gt;pic.twitter.com/DbXQt1JYx8&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1396535283190046722?ref_src=twsrc%5Etfw"&gt;May 23, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-a-template-library-in-python.html</guid><pubDate>Sun, 23 May 2021 00:00:00 +0000</pubDate></item><item><title>Learning a new codebase: hacking on nginx</title><link>http://notes.eatonphil.com/learning-a-new-codebase-hacking-nginx.html</link><description>&lt;p&gt;I have never contributed to nginx. My C skills are 1/10. But
downloading the source, hacking it up, compiling it, and running it
doesn't scare me. This post is to help you overcome your own fears
about doing so. Not necessarily because you should be running
out-of-tree diffs in production but because I see a lot of developers
never even consider looking at the source of a big tool or dependency
they use.&lt;/p&gt;
&lt;p&gt;Most of all, studying mature software projects is one of the best ways
to grow as a programmer.&lt;/p&gt;
&lt;h3 id="source-and-build"&gt;Source and build&lt;/h3&gt;&lt;p&gt;At a high-level, the steps for hacking on software projects are always
the same:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find/download the source code&lt;/li&gt;
&lt;li&gt;Install necessary dependency libraries/compilers&lt;/li&gt;
&lt;li&gt;Start grepping around based on something you see in the output or capabilities you know exist&lt;/li&gt;
&lt;li&gt;Make a change&lt;/li&gt;
&lt;li&gt;Run some variation of &lt;code&gt;./configure &amp;&amp; make&lt;/code&gt; to build&lt;/li&gt;
&lt;li&gt;Run the program&lt;/li&gt;
&lt;li&gt;Go back to step 4 until you're happy&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="nginx"&gt;nginx&lt;/h3&gt;&lt;p&gt;Let's follow these steps for nginx. We google &lt;code&gt;nginx github&lt;/code&gt;
to learn that there's a read-only copy of the source on
&lt;a href="https://github.com/nginx/nginx"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ mkdir ~/vendor
$ cd ~/vendor
$ git clone https://github.com/nginx/nginx
$ cd nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There's no readme, bummer. We google &lt;code&gt;nginx build from
source&lt;/code&gt; and find
&lt;a href="http://nginx.org/en/docs/configure.html"&gt;this&lt;/a&gt;. We see it's a typical
C project that builds exactly as guessed: &lt;code&gt;./configure &amp;&amp;
make&lt;/code&gt;. And it doesn't look like it has any third-party
dependencies besides my C compiler.&lt;/p&gt;
&lt;p&gt;Install autoconf, gmake, and a C compiler. There's no &lt;code&gt;./configure&lt;/code&gt;
file in this directory but notice there is a &lt;code&gt;configure&lt;/code&gt; file in
&lt;code&gt;auto&lt;/code&gt;. Trying &lt;code&gt;cd auto &amp;amp;&amp;amp; ./configure&lt;/code&gt; crashes so let's try
&lt;code&gt;./auto/configure&lt;/code&gt;. That seems to do it except for the warning:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./auto/configure
...
./auto/configure: error: the HTTP rewrite module requires the PCRE library.
You can either disable the module by using --without-http_rewrite_module
option, or install the PCRE library into the system, or build the PCRE library
statically from the source with nginx by using --with-pcre=&amp;lt;path&amp;gt; option.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;./auto/configure --without-http_rewrite_module&lt;/code&gt;. And then again
when that fails but also omitting &lt;code&gt;http_gzip_module&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ok autoconfigure is done. Now we've got a Makefile. Run &lt;code&gt;make -j&lt;/code&gt; to
compile using all cores.&lt;/p&gt;
&lt;p&gt;Run &lt;code&gt;git status&lt;/code&gt; to see where the binary was placed. Run &lt;code&gt;ls objs&lt;/code&gt; and
there it is, great:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ls objs
autoconf.err  nginx    ngx_auto_config.h   ngx_modules.c  src
Makefile      nginx.8  ngx_auto_headers.h  ngx_modules.o
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="the-hack"&gt;The hack&lt;/h3&gt;&lt;p&gt;We want a simple &lt;code&gt;dump&lt;/code&gt; command that will return a literal string in a
&lt;code&gt;location&lt;/code&gt; block. So something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs diff"&gt;$ diff --git a/conf/nginx.conf b/conf/nginx.conf
index 29bc085f..e96e817f 100644
--- a/conf/nginx.conf
+++ b/conf/nginx.conf

@@ -41,8 +41,7 @@ http {
#access_log  logs/host.access.log  main;

location / {
-            root   html;
-            index  index.html index.htm;
+            dump &amp;#39;It was a good Thursday.&amp;#39;;
         }

         #error_page  404              /404.html;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we've built nginx we can use the &lt;code&gt;-t&lt;/code&gt; flag to test the
validity of this config:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ./objs/nginx -t -c $(pwd)/conf/nginx.conf
nginx: [alert] could not open error log file: open() &amp;quot;/usr/local/nginx/logs/error.log&amp;quot; failed (2: No such file or directory)
2021/04/04 21:24:09 [emerg] 1030951#0: unknown directive &amp;quot;dump&amp;quot; in /home/phil/vendor/nginx/conf/nginx.conf:44
nginx: configuration file /home/phil/vendor/nginx/conf/nginx.conf test failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we've got something to go on! Clearly we have to register this
directive and the log gives us enough info to start grepping:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager grep &amp;#39;unknown directive&amp;#39;
src/core/ngx_conf_file.c:                       &amp;quot;unknown directive \&amp;quot;%s\&amp;quot;&amp;quot;, name-&amp;gt;data);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The case that has this failing comes from line 463: &lt;code&gt;rv = cmd-&amp;gt;set(cf, cmd, conf)&lt;/code&gt;. So let's see what this &lt;code&gt;set&lt;/code&gt; does. &lt;code&gt;git grep set&lt;/code&gt; is useless. Let's try finding out what &lt;code&gt;cmd&lt;/code&gt; is so we can locate the struct that has &lt;code&gt;set&lt;/code&gt; on it. Ah it's an &lt;code&gt;ngx_command_t&lt;/code&gt;. Since it doesn't have &lt;code&gt;struct&lt;/code&gt; behind it it means it's typedef-ed and will likely have a &lt;code&gt;;&lt;/code&gt; after it. So &lt;code&gt;git grep ngx_command_t\;&lt;/code&gt; finds us:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git --no-pager grep ngx_command_t\;
src/core/ngx_core.h:typedef struct ngx_command_s         ngx_command_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which means the implementation is hidden, so grep for ngx_command_s:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager grep ngx_command_s
src/core/ngx_conf_file.h:struct ngx_command_s {
src/core/ngx_core.h:typedef struct ngx_command_s         ngx_command_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok this is going nowhere. Different approach. What command did we remove?&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff
diff --git a/conf/nginx.conf b/conf/nginx.conf
index 29bc085f..e96e817f 100644
--- a/conf/nginx.conf
+++ b/conf/nginx.conf
@@ -41,8 +41,7 @@ http {
         #access_log  logs/host.access.log  main;

         location / {
-            root   html;
-            index  index.html index.htm;
+            dump &amp;#39;It was a good Thursday.&amp;#39;;
         }

         #error_page  404              /404.html;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt; is a command. Maybe we can copy that.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager grep \&amp;quot;root\&amp;quot;
docs/xml/nginx/changes.xml:in the &amp;quot;root&amp;quot; or &amp;quot;auth_basic_user_file&amp;quot; directives.
docs/xml/nginx/changes.xml:a request was handled incorrectly, if a &amp;quot;root&amp;quot; directive used variables;
docs/xml/nginx/changes.xml:the $document_root variable usage in the &amp;quot;root&amp;quot; and &amp;quot;alias&amp;quot; directives
docs/xml/nginx/changes.xml:the $document_root variable did not support the variables in the &amp;quot;root&amp;quot;
docs/xml/nginx/changes.xml:if a &amp;quot;root&amp;quot; was specified by variable only, then the root was relative
src/http/ngx_http_core_module.c:    { ngx_string(&amp;quot;root&amp;quot;),
src/http/ngx_http_core_module.c:                           &amp;amp;cmd-&amp;gt;name, clcf-&amp;gt;alias ? &amp;quot;alias&amp;quot; : &amp;quot;root&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That looks more promising. Let's copy that:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff src/http/
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c             index 9b94b328..17a64e80 100644                                                            --- a/src/http/ngx_http_core_module.c                                                      +++ b/src/http/ngx_http_core_module.c                                                      @@ -331,6 +331,14 @@ static ngx_command_t  ngx_http_core_commands[] = {
       0,
       NULL },
+    { ngx_string(&amp;quot;dump&amp;quot;),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF
+                        |NGX_CONF_TAKE1,
+      ngx_http_core_dump,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
     { ngx_string(&amp;quot;alias&amp;quot;),
       NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_http_core_root,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok so this is how a command is registered. It obviously won't build without &lt;code&gt;ngx_http_core_dump&lt;/code&gt; so let's implement that by copying/renaming &lt;code&gt;ngx_http_core_root&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff src
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 9b94b328..c184dab5 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -4402,6 +4410,16 @@ ngx_http_core_root(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
}


+static char *
+ngx_http_core_dump(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    ngx_http_core_loc_conf_t *clcf = conf;
+    ngx_str_t *value = cf-&amp;gt;args-&amp;gt;elts;
+    clcf-&amp;gt;dump = value[1];
+    return NGX_CONF_OK;
+}
+
+
static ngx_http_method_name_t  ngx_methods_names[] = {
     { (u_char *) &amp;quot;GET&amp;quot;,       (uint32_t) ~NGX_HTTP_GET },
     { (u_char *) &amp;quot;HEAD&amp;quot;,      (uint32_t) ~NGX_HTTP_HEAD },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The goal here is to just store the dump string on this conf
object. Then while serving the request we can check if this is set and
if so, respond to the request with this string.&lt;/p&gt;
&lt;p&gt;This still clearly won't build because we didn't modify this conf
object. But let's run &lt;code&gt;make&lt;/code&gt; anyway.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ make -f objs/Makefile
make[1]: Entering directory &amp;#39;/home/phil/vendor/nginx&amp;#39;
cc -c -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g  -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules \
        -o objs/src/http/ngx_http_core_module.o \
        src/http/ngx_http_core_module.c
src/http/ngx_http_core_module.c:337:7: error: ngx_http_core_dump undeclared here (not in a function); did you mean ngx_http_core_type?
337 |       ngx_http_core_dump,
    |       ^~~~~~~~~~~~~~~~~~~~~
    |       ngx_http_core_type
src/http/ngx_http_core_module.c: In function ngx_http_core_dump:
src/http/ngx_http_core_module.c:4418:9: error: ngx_http_core_loc_conf_t {aka struct ngx_http_core_loc_conf_s} has no member named dump
4418 |     clcf-&amp;gt;dump = value[1];
     |         ^~
src/http/ngx_http_core_module.c:4418:5: error: statement with no effect [-Werror=unused-value]
4418 |     clcf-&amp;gt;dump = value[1];
     |     ^~~~
At top level:
src/http/ngx_http_core_module.c:4414:1: error: ngx_http_core_dump defined but not used [-Werror=unused-function]
4414 | ngx_http_core_dump(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
     | ^~~~~~~~~~~~~~~~~~~~~
cc1: all warnings being treated as errors
make[1]: *** [objs/Makefile:834: objs/src/http/ngx_http_core_module.o] Error 1
make[1]: Leaving directory &amp;#39;/home/phil/vendor/nginx&amp;#39;
make: *** [Makefile:10: build] Error 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The dump handler is undeclared. While copying &lt;code&gt;ngx_http_core_root&lt;/code&gt; earlier I saw that there was a forward declaration toward the top. Let's copy that as well and see if that fixes anything.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 9b94b328..430e1256 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -56,6 +56,7 @@ static char *ngx_http_core_listen(ngx_conf_t *cf, ngx_command_t *cmd,
static char *ngx_http_core_server_name(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);
static char *ngx_http_core_root(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+static char *ngx_http_core_dump(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
 static char *ngx_http_core_limit_except(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);
 static char *ngx_http_core_set_aio(ngx_conf_t *cf, ngx_command_t *cmd,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And build:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ make
make -f objs/Makefile
make[1]: Entering directory &amp;#39;/home/phil/vendor/nginx&amp;#39;
cc -c -pipe  -O -W -Wall -Wpointer-arith -Wno-unused-parameter -Werror -g  -I src/core -I src/event -I src/event/modules -I src/os/unix -I objs -I src/http -I src/http/modules \
        -o objs/src/http/ngx_http_core_module.o \
src/http/ngx_http_core_module.c
src/http/ngx_http_core_module.c: In function ngx_http_core_dump:
src/http/ngx_http_core_module.c:4419:9: error: ngx_http_core_loc_conf_t {aka struct ngx_http_core_loc_conf_s} has no member named dump
4419 |     clcf-&amp;gt;dump = value[1];
     |         ^~
make[1]: *** [objs/Makefile:834: objs/src/http/ngx_http_core_module.o] Error 1
make[1]: Leaving directory &amp;#39;/home/phil/vendor/nginx&amp;#39;
make: *** [Makefile:10: build] Error 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perfect. Now let's add &lt;code&gt;dump&lt;/code&gt; as a member to this conf object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager grep ngx_http_core_loc_conf_t\;
src/http/ngx_http_core_module.h:typedef struct ngx_http_core_loc_conf_s  ngx_http_core_loc_conf_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's just clone the &lt;code&gt;root&lt;/code&gt; member:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ diff --git a/src/http/ngx_http_core_module.h b/src/http/ngx_http_core_module.h
index 2aadae7f..6b1b178b 100644
--- a/src/http/ngx_http_core_module.h
+++ b/src/http/ngx_http_core_module.h
@@ -333,6 +333,7 @@ struct ngx_http_core_loc_conf_s {
/* location name length for inclusive location with inherited alias */
     size_t        alias;
     ngx_str_t     root;                    /* root, alias */
+    ngx_str_t     dump;
     ngx_str_t     post_action;

     ngx_array_t  *root_lengths;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; and it succeeds!&lt;/p&gt;
&lt;p&gt;Now we spend a few hours looking around for a good place to add a hook
during a request. Ultimately, &lt;code&gt;ngx_http_core_find_config_phase&lt;/code&gt; seems
like a good place since only then will we be dealing with the struct
we added &lt;code&gt;dump&lt;/code&gt; to.&lt;/p&gt;
&lt;p&gt;Next step is figuring out how to send a response. Grepping for
&lt;code&gt;response&lt;/code&gt; isn't super useful, neither is &lt;code&gt;write&lt;/code&gt;. But &lt;code&gt;send&lt;/code&gt; has some
pretty low-level but obvious behavior.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager grep send\(
src/mail/ngx_mail.h:void ngx_mail_send(ngx_event_t *wev);
src/mail/ngx_mail_auth_http_module.c:    n = ngx_send(c, ctx-&amp;gt;request-&amp;gt;pos, size);)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That second result looks promising. Looking at that file it looks like
we need an object that has a &lt;code&gt;-&amp;gt;data&lt;/code&gt; member. In
&lt;code&gt;src/http/ngx_http_core_module.c&lt;/code&gt; I noticed that the request object
has a member that looks interesting: &lt;code&gt;r-&amp;gt;connection-&amp;gt;write-&amp;gt;data&lt;/code&gt;. And
if we look up the signature we just need to also send &lt;code&gt;ngx_send&lt;/code&gt; a
string and a length.&lt;/p&gt;
&lt;p&gt;Thankfully we already have that from our &lt;code&gt;dump&lt;/code&gt; member. So let's try something simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 9b94b328..bd58788b 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -989,6 +996,11 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,
         ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);
         return NGX_OK;
}
+
+    if (clcf-&amp;gt;dump.len) {
+      ngx_send(r-&amp;gt;connection-&amp;gt;write-&amp;gt;data, clcf-&amp;gt;dump.data, clcf-&amp;gt;dump.len);
+      return NGX_OK;
+    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run &lt;code&gt;make&lt;/code&gt; and it's good! Let's turn off the nginx daemon and worker processes so it's easier to quit as we're iterating.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff conf/
diff --git a/conf/nginx.conf b/conf/nginx.conf
index 29bc085f..7cce7d65 100644
--- a/conf/nginx.conf
+++ b/conf/nginx.conf
@@ -1,4 +1,5 @@
-
+daemon off;
+master_process off;
 #user  nobody;
 worker_processes  1;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now run &lt;code&gt;./objs/nginx -c $(pwd)/conf/nginx.conf&lt;/code&gt;. Try to curl:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl localhost:2020
curl: (1) Received HTTP/0.9 when not allowed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Huh, that's unexpected. Let's try using telnet to get the whole raw
response:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ telnet localhost 2020
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is &amp;#39;^]&amp;#39;.
GET /
It was a good Thursday.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Oh man. That's super cool. Unfortunately it's also not valid HTTP. It
seems like if we're using &lt;code&gt;ngx_send&lt;/code&gt; we'll have to set the HTTP
response headers manually.&lt;/p&gt;
&lt;p&gt;If we're going to pass a literal string to &lt;code&gt;ngx_send&lt;/code&gt; we'll have to
convert it to an &lt;code&gt;ngx_str_t&lt;/code&gt;. Judging from &lt;code&gt;src/core/ngx_string.h&lt;/code&gt; the
&lt;code&gt;ngx_string&lt;/code&gt; macro should be able to do this.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff src
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 9b94b328..1a1baccd 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -989,6 +996,13 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,
         ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);
         return NGX_OK;
     }
+
+    static ngx_str_t header = ngx_string(&amp;quot;HTTP/1.0 200 OK\r\n\r\n&amp;quot;);
+    if (clcf-&amp;gt;dump.len) {
+      ngx_send(r-&amp;gt;connection-&amp;gt;write-&amp;gt;data, header.data, header.len);
+      ngx_send(r-&amp;gt;connection-&amp;gt;write-&amp;gt;data, clcf-&amp;gt;dump.data, clcf-&amp;gt;dump.len);
+      return NGX_OK;
+    }

     if (rc == NGX_DONE) {
         ngx_http_clear_location(r);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile, run and curl:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl localhost:2020
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Huh. It's no longer complaining about HTTP/0.9 but it's now
hanging. Let's try verbose curling.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl -vvv localhost:2020
*   Trying ::1:2020...
* connect to ::1 port 2020 failed: Connection refused
*   Trying 127.0.0.1:2020...
* Connected to localhost (127.0.0.1) port 2020 (#0)
&amp;gt; GET / HTTP/1.1
&amp;gt; Host: localhost:2020
&amp;gt; User-Agent: curl/7.71.1
&amp;gt; Accept: */*
&amp;gt;
* Mark bundle as not supporting multiuse
* HTTP 1.0, assume close after body
&amp;lt; HTTP/1.0 200 OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's really weird. But I noticed there was a
&lt;code&gt;ngx_http_request_finalize&lt;/code&gt; function that other parts of the code were
calling. Let's try adding that.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git --no-pager diff src
diff --git a/src/http/ngx_http_core_module.c b/src/http/ngx_http_core_module.c
index 9b94b328..1a1baccd 100644
--- a/src/http/ngx_http_core_module.c
+++ b/src/http/ngx_http_core_module.c
@@ -989,6 +996,14 @@ ngx_http_core_find_config_phase(ngx_http_request_t *r,
         ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);
         return NGX_OK;
     }
+
+    static ngx_str_t header = ngx_string(&amp;quot;HTTP/1.0 200 OK\r\n\r\n&amp;quot;);
+    if (clcf-&amp;gt;dump.len) {
+      ngx_send(r-&amp;gt;connection-&amp;gt;write-&amp;gt;data, header.data, header.len);
+      ngx_send(r-&amp;gt;connection-&amp;gt;write-&amp;gt;data, clcf-&amp;gt;dump.data, clcf-&amp;gt;dump.len);
+      ngx_http_finalize_request(r, NGX_DONE);
+      return NGX_OK;
+    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build, run, curl. Still hanging. Looking into the source code of
&lt;code&gt;ngx_http_finalize_request&lt;/code&gt; it seems like there's a case where the
connection is completely closed if you pass in &lt;code&gt;NGX_HTTP_CLOSE&lt;/code&gt;. Let's
try that.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl localhost:2020
It was a good Thursday.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well hot dog, it works.&lt;/p&gt;
&lt;h3 id="reflection"&gt;Reflection&lt;/h3&gt;&lt;p&gt;Is this a good way to implement commands in nginx? No. While I knew a
bit about nginx modules as a user it's clear that as a developer this
command could have been implemented much more cleanly as a module too.&lt;/p&gt;
&lt;p&gt;There also has to be higher-level tooling for returning constructing
responses rather than writing out headers manually.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Been wanting to write some posts like this for a long time showing some techniques for hacking on an unfamiliar project using very basic programming/Linux tools. In this post it&amp;#39;s nginx&lt;a href="https://t.co/t7Y43Zmxhk"&gt;https://t.co/t7Y43Zmxhk&lt;/a&gt; &lt;a href="https://t.co/EOatURm5wx"&gt;pic.twitter.com/EOatURm5wx&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1378906317004361732?ref_src=twsrc%5Etfw"&gt;April 5, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/learning-a-new-codebase-hacking-nginx.html</guid><pubDate>Sun, 04 Apr 2021 00:00:00 +0000</pubDate></item><item><title>How to get better at recursion</title><link>http://notes.eatonphil.com/practicing-recursion.html</link><description>&lt;p&gt;tldr; reimplement standard library functions in your favorite
language &lt;em&gt;without loops&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id="background"&gt;Background&lt;/h3&gt;&lt;p&gt;For a few years after college I spent a lot of free time doing
projects in Standard ML and Scheme. As a result I got really
comfortable doing recursion. The two big reasons for this are 1)
neither Standard ML or Scheme have loops and 2) they both have very
small standard libraries. (Ok, they have loops. They're just so
limited as to be useless.)&lt;/p&gt;
&lt;p&gt;I ended up building &lt;a href="https://github.com/eatonphil/ponyo"&gt;a standard
library&lt;/a&gt; for Standard ML including
string functions (contains, indexOf, count, replace, etc.), an HTTP
server and client, a hash table, a binary search tree, parts of a
Standard ML parser, and &lt;a href="https://ponyo.org/reference"&gt;so on&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;All of this without loops.&lt;/p&gt;
&lt;h3 id="strategy"&gt;Strategy&lt;/h3&gt;&lt;p&gt;The good news (if you don't want to learn a new language) is that you
don't have to take up Standard ML or Scheme to get better at
recursion. But you do need to dedicate some time to &lt;em&gt;practicing
recursion&lt;/em&gt; to get better at it.&lt;/p&gt;
&lt;p&gt;My recommendation would be to pick 10-20 string or array functions out
of your favorite language's standard library and reimplement them
without loops. (Obviously, start simple and just pick one. But
don't stop there.)&lt;/p&gt;
&lt;h3 id="some-examples"&gt;Some examples&lt;/h3&gt;&lt;p&gt;Here's an example reimplementation of &lt;code&gt;indexOf&lt;/code&gt; in
JavaScript:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function indexOf(input, toMatch) {
  function helper(index, offset, test) {
    if (index === input.length) {
      return -1;
    }

    if (toMatch === test) {
      return index;
    }

    if (input[index+offset] !== toMatch[offset] || test.length &amp;gt; toMatch.length) {
      return helper(index+1, 0, &amp;quot;&amp;quot;);
    }

    return helper(index, offset+1, test+input[index+offset]);
  }

  return helper(0, 0, &amp;quot;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or here's an example immutable reimplementation of &lt;code&gt;insert&lt;/code&gt;
in Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def insert(arr, index, item):
  def helper(currentIndex, accum):
    if currentIndex == len(arr):
      return accum

    if currentIndex &amp;lt; index:
      return helper(currentIndex+1, accum + [arr[currentIndex]])

    if currentIndex == index:
      return helper(currentIndex+1, accum + [item, arr[currentIndex]])

    return helper(currentIndex+1, accum + [arr[currentIndex]])

  return helper(0, [])
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  You're going to find an edge case and that's alright. The
  important part at the moment is practicing recursion.
&lt;/p&gt;&lt;p&gt;For bonus points, avoid all mutation in your implementations and use
only tail recursion.&lt;/p&gt;
&lt;p&gt;Happy recursion!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Reimplementing standard library functions without for loops is a great way to get better at recursion and you don&amp;#39;t need to use a functional programming language to do so&lt;a href="https://t.co/JiPnXMQW3l"&gt;https://t.co/JiPnXMQW3l&lt;/a&gt; &lt;a href="https://t.co/MHwX5t70HT"&gt;pic.twitter.com/MHwX5t70HT&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1368602496168497154?ref_src=twsrc%5Etfw"&gt;March 7, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/practicing-recursion.html</guid><pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate></item><item><title>Four books professional developers should read (and a few you don't need to)</title><link>http://notes.eatonphil.com/books-developers-should-read.html</link><description>&lt;p&gt;These are the books I recommend to developers wanting to improve their
skills as professional programmers because of high information
density, believable premises/examples, and being well edited.&lt;/p&gt;
&lt;p&gt;You don't need to read books to improve as a developer but
they are unparalleled in quickly helping you gain depth in a subject.&lt;/p&gt;
&lt;h3 id="effective-python:-90-specific-ways-to-write-better-python"&gt;Effective Python: 90 Specific Ways to Write Better Python&lt;/h3&gt;&lt;p&gt;If you're a Python developer wanting to improve your craft you should
read this. Good Python starts with a deep understanding of the
standard library and language.&lt;/p&gt;
&lt;h3 id="high-performance-browser-networking"&gt;High Performance Browser Networking&lt;/h3&gt;&lt;p&gt;If your code is triggered by a desktop or mobile browser you should
read this. It is a thorough high level introduction to mobile
networks, browser network protocols, and fundementals of networking.&lt;/p&gt;
&lt;h3 id="designing-data-intensive-applications"&gt;Designing Data-Intensive Applications&lt;/h3&gt;&lt;p&gt;If your databases and APIs are a bottleneck you should read this. A
solid introduction to distributed computing, data transfer, indexing,
etc.&lt;/p&gt;
&lt;h3 id="site-reliability-engineering:-how-google-runs-production-services"&gt;Site Reliability Engineering: How Google Runs Production Services&lt;/h3&gt;&lt;p&gt;If you are responsible for services in production you should read
this. It's Google specific but is an excellent background on practices
for monitoring and maintaining production environments.&lt;/p&gt;
&lt;h3 id="that's-it!"&gt;That's it!&lt;/h3&gt;&lt;p&gt;Generic software books conspicuously not on this list for
me:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clean Code&lt;/li&gt;
&lt;li&gt;JavaScript the Good Parts&lt;/li&gt;
&lt;li&gt;Design Patterns/Gang of Four&lt;/li&gt;
&lt;li&gt;Structure and Interpretation of Computer Programs&lt;/li&gt;
&lt;li&gt;A Philosophy of Software Design&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;They're not all bad but give nowhere near as much return for the
investment of your time.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Four books I recommend to professional developers wanting to improve their craft, and a few I&amp;#39;d not&lt;a href="https://t.co/1aTrfqZ9bd"&gt;https://t.co/1aTrfqZ9bd&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1356391931274756096?ref_src=twsrc%5Etfw"&gt;February 2, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/books-developers-should-read.html</guid><pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate></item><item><title>Extending gosql to supporting LIMIT and OFFSET</title><link>http://notes.eatonphil.com/extending-gosql-to-support-limit-and-offset.html</link><description>&lt;p&gt;It's been a few months since I picked up
&lt;a href="https://github.com/eatonphil/gosql"&gt;gosql&lt;/a&gt; and I wanted to use it to
prototype a SQL interface for data stored in S3. But one missing
critical feature in gosql is &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; support. This post walks
through the few key changes to gosql to support &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can find &lt;a href="https://github.com/eatonphil/gosql/commit/9405e433ec51f8f1d72c9b2e8f45109d738edec4"&gt;this commit in full on
Github&lt;/a&gt;.&lt;/p&gt;
&lt;p class="note"&gt;
  This post builds on top of a series on building a SQL database from scratch in Golang.
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/database-basics.html"&gt;1. SELECT, INSERT, CREATE and a REPL&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-expressions-and-where.html"&gt;2. binary expressions and WHERE filters&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-indexes.html"&gt;3. indexes&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-a-database-sql-driver.html"&gt;4. a database/sql driver&lt;/a&gt;
&lt;/p&gt;&lt;h3 id="lexing"&gt;Lexing&lt;/h3&gt;&lt;p&gt;The first step is to update the lexer to know about the
&lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; keywords. Since we already
have a generalized method of lexing any keywords from an array (see
&lt;code&gt;lexer.go:lexKeyword&lt;/code&gt;), this is really easy. Just add a new
&lt;code&gt;Keyword&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -37,6 +37,8 @@ const (
        OnKeyword         Keyword = &amp;quot;on&amp;quot;
        PrimarykeyKeyword Keyword = &amp;quot;primary key&amp;quot;
        NullKeyword       Keyword = &amp;quot;null&amp;quot;
+       LimitKeyword      Keyword = &amp;quot;limit&amp;quot;
+       OffsetKeyword     Keyword = &amp;quot;offset&amp;quot;
 )
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then add these two new enums to the list of &lt;code&gt;Keyword&lt;/code&gt;s
to lex:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -261,6 +263,8 @@ func lexKeyword(source string, ic cursor) (*Token, cursor, bool) {
                OnKeyword,
                PrimarykeyKeyword,
                NullKeyword,
+               LimitKeyword,
+               OffsetKeyword,
        }

        var options []string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it for the lexer.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;Before we can parse limit and offset into the AST, we have to modify
our AST struct to support these two fields in ast.go:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -54,9 +54,11 @@ type SelectItem struct {
 }

 type SelectStatement struct {
-       Item  *[]*SelectItem
-       From  *Token
-       Where *Expression
+       Item   *[]*SelectItem
+       From   *Token
+       Where  *Expression
+       Limit  *Expression
+       Offset *Expression
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And to be a good citizen, we'll fix up the &lt;code&gt;GenerateCode&lt;/code&gt;
helper function (for pretty-printing the AST) to
show &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -73,17 +75,24 @@ func (ss SelectStatement) GenerateCode() string {
                item = append(item, s)
        }

-       from := &amp;quot;&amp;quot;
+       code := &amp;quot;SELECT\n&amp;quot; + strings.Join(item, &amp;quot;,\n&amp;quot;)
        if ss.From != nil {
-               from = fmt.Sprintf(&amp;quot;\nFROM\n\t\&amp;quot;%s\&amp;quot;&amp;quot;, ss.From.Value)
+               code += fmt.Sprintf(&amp;quot;\nFROM\n\t\&amp;quot;%s\&amp;quot;&amp;quot;, ss.From.Value)
        }

-       where := &amp;quot;&amp;quot;
        if ss.Where != nil {
-               where = fmt.Sprintf(&amp;quot;\nWHERE\n\t%s&amp;quot;, ss.Where.GenerateCode())
+               code += &amp;quot;\nWHERE\n\t&amp;quot; + ss.Where.GenerateCode()
        }

-       return fmt.Sprintf(&amp;quot;SELECT\n%s%s%s;&amp;quot;, strings.Join(item, &amp;quot;,\n&amp;quot;), from, where)
+       if ss.Limit != nil {
+               code += &amp;quot;\nLIMIT\n\t&amp;quot; + ss.Limit.GenerateCode()
+       }
+
+       if ss.Offset != nil {
+               code += &amp;quot;\nOFFSET\n\t&amp;quot; + ss.Limit.GenerateCode()
+       }
+
+       return code + &amp;quot;;&amp;quot;
 }

 type ColumnDefinition struct {
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it for modifying the AST itself. Now we can modify the select
statement parser to look for these two new sections. It's pretty
simple: for both &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; first
check if they exist in the current statement and then try to parse the
expression after them, in parser.go:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -285,6 +288,30 @@ func (p Parser) parseSelectStatement(tokens []*Token, initialCursor uint, delimi
                cursor = newCursor
        }

+       _, cursor, ok = p.parseToken(tokens, cursor, limitToken)
+       if ok {
+               limit, newCursor, ok := p.parseExpression(tokens, cursor, []Token{offsetToken, delimiter}, 0)
+               if !ok {
+                       p.helpMessage(tokens, cursor, &amp;quot;Expected LIMIT value&amp;quot;)
+                       return nil, initialCursor, false
+               }
+
+               slct.Limit = limit
+               cursor = newCursor
+       }
+
+       _, cursor, ok = p.parseToken(tokens, cursor, offsetToken)
+       if ok {
+               offset, newCursor, ok := p.parseExpression(tokens, cursor, []Token{delimiter}, 0)
+               if !ok {
+                       p.helpMessage(tokens, cursor, &amp;quot;Expected OFFSET value&amp;quot;)
+                       return nil, initialCursor, false
+               }
+
+               slct.Offset = offset
+               cursor = newCursor
+       }
+
        return &amp;amp;slct, cursor, true
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the last tricky bit is to make sure that previous
optional &lt;code&gt;parseExpression&lt;/code&gt; know that they can be delimited
by &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; (this delimiter
awareness is just how the parser works):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -273,9 +273,12 @@ func (p Parser) parseSelectStatement(tokens []*Token, initialCursor uint, delimi
                cursor = newCursor
        }

+       limitToken := tokenFromKeyword(LimitKeyword)
+       offsetToken := tokenFromKeyword(OffsetKeyword)
+
        _, cursor, ok = p.parseToken(tokens, cursor, whereToken)
        if ok {
-               where, newCursor, ok := p.parseExpression(tokens, cursor, []Token{delimiter}, 0)
+               where, newCursor, ok := p.parseExpression(tokens, cursor, []Token{limitToken, offsetToken, delimiter}, 0)
                if !ok {
                        p.helpMessage(tokens, cursor, &amp;quot;Expected WHERE conditionals&amp;quot;)
                        return nil, initialCursor, false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it for parsing!&lt;/p&gt;
&lt;h3 id="runtime"&gt;Runtime&lt;/h3&gt;&lt;p&gt;Gosql has just one storage backend currently: an in-memory store. To
support &lt;code&gt;LIMIT&lt;/code&gt; and &lt;code&gt;OFFSET&lt;/code&gt; we need to evaluate
both expressions if they exist. Then while we're iterating through
table rows, after testing whether each row passes
the &lt;code&gt;WHERE&lt;/code&gt; filter, we'll check if the number of rows
passing the &lt;code&gt;WHERE&lt;/code&gt; filter falls within the range
of &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT + OFFSET&lt;/code&gt; otherwise we'll
skip the row, in memory.go:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;@@ -587,6 +587,33 @@ func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
                }
        }

+       limit := len(t.rows)
+       if slct.Limit != nil {
+               v, _, _, err := t.evaluateCell(0, *slct.Limit)
+               if err != nil {
+                       return nil, err
+               }
+
+               limit = int(*v.AsInt())
+       }
+       if limit &amp;lt; 0 {
+               return nil, fmt.Errorf(&amp;quot;Invalid, negative limit&amp;quot;)
+       }
+
+       offset := 0
+       if slct.Offset != nil {
+               v, _, _, err := t.evaluateCell(0, *slct.Offset)
+               if err != nil {
+                       return nil, err
+               }
+
+               offset = int(*v.AsInt())
+       }
+       if offset &amp;lt; 0 {
+               return nil, fmt.Errorf(&amp;quot;Invalid, negative limit&amp;quot;)
+       }
+
+       rowIndex := -1
        for i := range t.rows {
                result := []Cell{}
                isFirstRow := len(results) == 0
@@ -602,6 +629,13 @@ func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
                        }
                }

+               rowIndex++
+               if rowIndex &amp;lt; offset {
+                       continue
+               } else if rowIndex &amp;gt; offset+limit-1 {
+                       break
+               }
+
                for _, col := range finalItems {
                        value, columnName, columnType, err := t.evaluateCell(uint(i), *col.Exp)
                        if err != nil {
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  Just to call out explicitly, with &lt;code&gt;LIMIT&lt;/code&gt;
  and &lt;code&gt;OFFSET&lt;/code&gt; we still have to check every single row in
  the table (at least until we've reached the offset). This should
  clearly illustrate why paginating based on &lt;code&gt;LIMIT&lt;/code&gt;
  and &lt;code&gt;OFFSET&lt;/code&gt; is not a great idea for big datasets
  &lt;a href="https://use-the-index-luke.com/sql/partial-results/fetch-next-page"&gt;compared
  to index-based pagination&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;That's all!&lt;/p&gt;
&lt;h3 id="trying-it-out"&gt;Trying it out&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build cmd/main.go
$ ./main
Welcome to gosql.
# create table user (name text, age int);
ok
# insert into user values (&amp;#39;meg&amp;#39;, 2);
ok
# insert into user values (&amp;#39;jerry&amp;#39;, 2);
ok
# insert into user values (&amp;#39;phil&amp;#39;, 1);
ok
# select * from user;
  name  | age
--------+------
  meg   |   2
  jerry |   2
  phil  |   1
(3 results)
ok
# select * from user limit 1;
  name | age
-------+------
  meg  |   2
(1 result)
ok
# select * from user where age=1 limit 1;
  name | age
-------+------
  phil |   1
(1 result)
ok
# select * from user where age=1 limit 4;
  name | age
-------+------
  phil |   1
(1 result)
ok
# select * from user where age=2 limit 1;
  name | age
-------+------
  meg  |   2
(1 result)
ok
# select * from user where age=2 limit 1 offset 1;
  name  | age
--------+------
  jerry |   2
(1 result)
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not so hard to hack is it? Make sure to include some tests!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Working on a prototype SQL-based explorer for data stored in S3 and I needed OFFSET/LIMIT support in the gosql parser. Wrote up a short post on how you can hack in additional syntax and functionality into this SQL engine written in Go.&lt;a href="https://t.co/PyVozTPZ5S"&gt;https://t.co/PyVozTPZ5S&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1353372050023456768?ref_src=twsrc%5Etfw"&gt;January 24, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/extending-gosql-to-support-limit-and-offset.html</guid><pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate></item><item><title>The year in books: 20 to recommend in 2020</title><link>http://notes.eatonphil.com/year-in-books-2020.html</link><description>&lt;p&gt;This year I finished 47 books, up from last year but not a personal
best. The breakdown was 17 non-fiction and 30 fiction. Another 20-30
remain started but unfinished this year.&lt;/p&gt;
&lt;h3 id="non-fiction"&gt;Non-fiction&lt;/h3&gt;&lt;p&gt;The 8 non-fiction books I most recommend are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/51034048-fashionopolis"&gt;Fashionapolis: The Price of Fast Fashion and the Future of Clothes&lt;/a&gt; (Must read)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/48566725-effective-python"&gt;Effective Python: 90 Specific Ways to Write Better Python&lt;/a&gt; (Must read; truly excellent for Python programmers, I recommend this to anyone I work with)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/93904.The_Machine_That_Changed_the_World"&gt;The Machine that Changed the World&lt;/a&gt; (Must read)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/16043511-europe"&gt;Europe: The Struggle for Supremacy from 1453 to the Present&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/19606799-wind-sand-and-stars"&gt;Wind, Sand and Stars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/11169043-american-colossus"&gt;American Colussus: The Triumph of Capitalism, 1865-1900&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/2360599.Making_Common_Sense_of_Japan"&gt;Making Common Sense of Japan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/8155672-the-german-genius"&gt;The German Genius&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The 3 books I recommend you not to waste time on are: "The Two
Koreas", "The Price of Inequality", and "Ninety Percent of Everything:
Inside Shipping".&lt;/p&gt;
&lt;h4 id="the-whole-list"&gt;The whole list&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/235560.The_Two_Koreas"&gt;The Two Koreas&lt;/a&gt; by Don Oberdorfer&lt;ul&gt;
&lt;li&gt;Interesting but not a huge fan, seemed pretty biased against South Korea somehow&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/88546.Forbidden_Nation"&gt;Forbidden Nation: A History of Taiwan&lt;/a&gt; by Jonathan Manthorpe&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/48566725-effective-python"&gt;Effective Python: 90 Specific Ways to Write Better Python&lt;/a&gt; by Brett Slatkin&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/43701534-a-philosophy-of-software-design"&gt;A Philosophy of Software Design&lt;/a&gt; by John Ousterhout&lt;ul&gt;
&lt;li&gt;Came as a recommendation from someone on Twitter, ultimately not a huge fan. Still looking for high quality books on software design&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/16031130-the-price-of-inequality"&gt;The Price of Inequality&lt;/a&gt; by Joseph E. Stiglitz&lt;ul&gt;
&lt;li&gt;Agreed with the premise but the book was incoherent and too self-assuring&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18930203-paris-reborn"&gt;Paris Reborn: Napoléon III, Baron Haussmann, and the Quest to Build a Modern City&lt;/a&gt; by Stephane Kirkland&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/51034048-fashionopolis"&gt;Fashionapolis: The Price of Fast Fashion and the Future of Clothes&lt;/a&gt; by Dana Thomas&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/6603103-a-moveable-feast"&gt;A Moveable Feast&lt;/a&gt; by Ernest Hemingway&lt;ul&gt;
&lt;li&gt;I normally love Hemingway's writing but this particular book was not very coherent&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/16043511-europe"&gt;Europe: The Struggle for Supremacy from 1453 to the Present&lt;/a&gt; by Brendan Simms&lt;ul&gt;
&lt;li&gt;Such an excellent introduction to the continent for Americans who otherwise don't have great background&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/19606799-wind-sand-and-stars"&gt;Wind, Sand and Stars&lt;/a&gt; by Antoine de Saint-Exupéry&lt;ul&gt;
&lt;li&gt;A beautiful memoir of flights by the author of The Little Prince, very similar in style to Hemingway&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/11169043-american-colossus"&gt;American Colussus: The Triumph of Capitalism, 1865-1900&lt;/a&gt; by H.W. Brands&lt;ul&gt;
&lt;li&gt;Baby's first primer on unions, (I need more recommendations on the history of unions)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/2360599.Making_Common_Sense_of_Japan"&gt;Making Common Sense of Japan&lt;/a&gt; by Steven R. Reed&lt;ul&gt;
&lt;li&gt;It can be difficult to find English translations of Korean, Japanese history by Korean and Japanese authors; this is a good one by an American professor&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/93904.The_Machine_That_Changed_the_World"&gt;The Machine that Changed the World&lt;/a&gt; by James P. Womack&lt;ul&gt;
&lt;li&gt;An excellent, well-researched history of automobile manufacturing in the US, Europe and Japan from the 1900s to 1990; how Japan ate everyone's lunch&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/40620.The_United_States_of_Europe"&gt;The United States of Europe&lt;/a&gt; by T.R. Reid&lt;ul&gt;
&lt;li&gt;Very light introduction to the European Union&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/7090.The_Soul_of_a_New_Machine"&gt;The Soul of a New Machine&lt;/a&gt; by Tracy Kidder&lt;ul&gt;
&lt;li&gt;Overhyped by the internets, but not bad&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/8155672-the-german-genius"&gt;The German Genius&lt;/a&gt; by Peter Watson&lt;ul&gt;
&lt;li&gt;Dense but excellent introduction to many famous Germans in many fields throughout time&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18626537-ninety-percent-of-everything"&gt;Ninety Percent of Everything: Inside Shipping&lt;/a&gt; by Rose George&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="fiction"&gt;Fiction&lt;/h3&gt;&lt;p&gt;I'm trying to read more from non-English authors. If you see
non-English authors in the vein of these here that you can recommend,
I'd love to hear from you.&lt;/p&gt;
&lt;p&gt;The 12 fiction books I most recommend are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/11607290-planet-of-the-apes"&gt;Planet of the Apes&lt;/a&gt; (Must read, yes even if you've seen the film)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18882869-all-quiet-on-the-western-front"&gt;All Quiet on the Western Front&lt;/a&gt; (Must read)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/26167126-the-mouse-that-roared"&gt;The Mouse That Roared&lt;/a&gt; (Must read)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/25171354-the-dead-mountaineer-s-inn"&gt;The Dead Mountaineer's Inn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/17406654-the-golem-and-the-jinni"&gt;The Golem and the Jinni&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/38886181-neverwhere"&gt;Neverwhere&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/35901747-dubliners"&gt;Dubliners&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/36510196-old-man-s-war"&gt;Old Man's War&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/38453346-the-inspector-barlach-mysteries"&gt;The Inspector Barlach Mysteries: The Judge and His Hangman and Suspicion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18842344-fant-mas"&gt;Fantômas&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/40793127-foundation"&gt;Foundation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/13380806-out-of-the-silent-planet"&gt;Out of the Silent Planet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The only book I really didn't like was "Invisible Cities".&lt;/p&gt;
&lt;h4 id="the-whole-list"&gt;The whole list&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18782460-march-violets"&gt;March Violets&lt;/a&gt; by Philip Kerr (Scottish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/25299696-liberty-bar"&gt;Liberty Bar&lt;/a&gt; by Georges Simenon (Belgian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/20018218-the-late-monsieur-gallet"&gt;The Late Monsieur Gallet&lt;/a&gt; by Georges Simenon (Belgian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/35901747-dubliners"&gt;Dubliners&lt;/a&gt; by James Joyce (Irish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/11580940-tales-of-the-city"&gt;Tales of the City&lt;/a&gt; by Amistead Maupin (American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/52971537-the-third-policeman"&gt;The Third Policeman&lt;/a&gt; by Flann O'Brien (Irish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/6522120-44-scotland-street"&gt;44 Scotland Street&lt;/a&gt; by Alexander McCall Smith (British-African)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/23209197-knots-and-crosses"&gt;Knots and Crosses&lt;/a&gt; by Ian Rankin (Scottish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/35598044-i-hear-your-voice"&gt;I Hear Your Voice&lt;/a&gt; by Kim Young Ha (South Korean)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/17406654-the-golem-and-the-jinni"&gt;The Golem and the Jinni&lt;/a&gt; by Helene Wecker (American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/25541152-the-tokyo-zodiac-murders"&gt;The Tokyo Zodiac Murders&lt;/a&gt; by Shimada Sōji (Japanese)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/8130077-the-screwtape-letters"&gt;The Screwtape Letters&lt;/a&gt; by C.S. Lewis (English)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/38886181-neverwhere"&gt;Neverwhere&lt;/a&gt; by Neil Gaiman (English)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/36510196-old-man-s-war"&gt;Old Man's War&lt;/a&gt; by John Scalzi (American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/9285319-tales-from-earthsea"&gt;Tales from Earthsea&lt;/a&gt; by Ursula K. Le Guin (American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/23632478-solaris"&gt;Solaris&lt;/a&gt; by Stanisław Lem (Polish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/16029682-a-wizard-of-earthsea"&gt;A Wizard of Earthsea&lt;/a&gt; by Ursula K. Le Guin (American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/11607290-planet-of-the-apes"&gt;Planet of the Apes&lt;/a&gt; by Pierre Boulle (French)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/25171354-the-dead-mountaineer-s-inn"&gt;The Dead Mountaineer's Inn&lt;/a&gt; by Arkady Strugatsky (Russian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/49605492-invisible-cities"&gt;Invisible Cities&lt;/a&gt; by Italo Calvino (Cuban-born Italian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/38453346-the-inspector-barlach-mysteries"&gt;The Inspector Barlach Mysteries: The Judge and His Hangman and Suspicion&lt;/a&gt; by Friedrich Dürrenmatt (Swiss)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18842344-fant-mas"&gt;Fantômas&lt;/a&gt; by Marcel Allain (French)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/18882869-all-quiet-on-the-western-front"&gt;All Quiet on the Western Front&lt;/a&gt; by Erich Maria Remarque (Germany)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/22346782-a-crime-in-holland"&gt;A Crime in Holland&lt;/a&gt; by Georges Simenon (Belgian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/32076294-the-wonderful-adventure-of-nils-holgersson"&gt;The Wonderful Adventure of Nils Holversson&lt;/a&gt; by Selma Lagerlöf (Swedish)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/40793127-foundation"&gt;Foundation&lt;/a&gt; by Isaac Asimov (Russian-born American)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/13380806-out-of-the-silent-planet"&gt;Out of the Silent Planet&lt;/a&gt; by C.S. Lewis (English)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/19847968-the-spy-who-came-in-from-the-cold"&gt;The Spy Who Came in from the Cold&lt;/a&gt; by John le Carré (English)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/19792871-the-bat"&gt;The Bat&lt;/a&gt; by Jo Nesbø (Norwegian)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/26167126-the-mouse-that-roared"&gt;The Mouse That Roared&lt;/a&gt; by Leonard Wibberley (Irish-born American)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Out of 47 books read this year, here&amp;#39;s the 20 I recommend to you (gave them 4/5 stars or better). I&amp;#39;m trying to read more non-English authors so I&amp;#39;d love to hear if there are authors with similar style on this list you&amp;#39;d recommend!&lt;a href="https://t.co/FjHcvHpRSr"&gt;https://t.co/FjHcvHpRSr&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1343242325791805447?ref_src=twsrc%5Etfw"&gt;December 27, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/year-in-books-2020.html</guid><pubDate>Sun, 27 Dec 2020 00:00:00 +0000</pubDate></item><item><title>Static analysis with semgrep: practical examples using Docker</title><link>http://notes.eatonphil.com/static-analysis-with-semgrep.html</link><description>&lt;p&gt;In this post we'll get a basic semgrep environment set up in Docker
running some custom rules against our code.&lt;/p&gt;
&lt;h3 id="existing-linters"&gt;Existing linters&lt;/h3&gt;&lt;p&gt;Linters like &lt;a href="https://www.pylint.org/"&gt;pylint&lt;/a&gt; for Python or
&lt;a href="https://eslint.org/"&gt;eslint&lt;/a&gt; for JavaScript are great for general,
broad language standards. But what about common nits in code review
like using print statements instead of a logger, or using a defer
statement inside a for loop (Go specific), or the existence of
multiple nested loops.&lt;/p&gt;
&lt;p&gt;Most developers don't have experience working with language
parsing. So it's fairly uncommon in small- and medium-sized teams to
see custom linting rules. And while no single linter or language is
that much more complex than the other (it's all just AST operations),
there is a small penalty to learning the AST and framework for each
language linter.&lt;/p&gt;
&lt;h3 id="semgrep"&gt;Semgrep&lt;/h3&gt;&lt;p&gt;&lt;a href="https://semgrep.dev/"&gt;Semgrep&lt;/a&gt; is a generic tool for finding patterns
in source code. Unlike traditional regex (and traditional grep) it can
find recursive patterns. This makes it especially useful as a tool to
learn for finding patterns in any language.&lt;/p&gt;
&lt;p&gt;An advantage of semgrep rules is that you can learn the semgrep
pattern matching syntax (which is surprisingly easy) and then you can
write rules for any language you'd like to write rules for.&lt;/p&gt;
&lt;p&gt;And while the &lt;a href="https://semgrep.dev/editor"&gt;online rule tester&lt;/a&gt; is
awesome, I had a hard time going from that to a working sample on my
own laptop with Docker. We'll do just that.&lt;/p&gt;
&lt;h3 id="catching-print-statements-in-python"&gt;Catching print statements in Python&lt;/h3&gt;&lt;p&gt;Let's say we want a script to fail on any use of print statements in
Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;$ cat test/python/simple-print.py
def main():
  print(&amp;quot;DEBUG: here&amp;quot;)
  print(&amp;quot;DEBUG: &amp;quot;, &amp;quot;now here&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The current &lt;a href="https://semgrep.dev/editor"&gt;default example&lt;/a&gt; shown in the
online editor happens to be for just this. Click the Advanced tab and
you'll see the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;rules:
- id: fail-on-print
  pattern: |
    print(&amp;quot;...&amp;quot;)
  message: |
    Semgrep found a match
  severity: WARNING
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Copy this into &lt;code&gt;config.yml&lt;/code&gt;. Let's modify the pattern to
warn on all print calls, not just print calls with a single string
argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;rules:
- id: fail-on-print
  pattern: |
    print(...)
  message: |
    Semgrep found a match
  severity: WARNING
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The editor doesn't mention it (nor do any docs I can find) but we also
need to include two keys in the individual rule
object: &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;languages&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;rules:
- id: fail-on-print
  pattern: |
    print(...)
  message: |
    Semgrep found a match
  severity: WARNING
  mode: search
  languages: [&amp;quot;generic&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Semgrep fails really weirdly if you set &lt;code&gt;mode&lt;/code&gt; to
anything other than &lt;code&gt;search&lt;/code&gt;, but it won't warn you that
what you set is garbage. The &lt;code&gt;languages&lt;/code&gt; setting is
similarly fickle and doesn't give you much feedback if you set it
incorrectly.&lt;/p&gt;
&lt;p class="note"&gt;
  Also, I'm using the "generic" language here because I don't
  understand the difference between languages and as far as I'm
  concerned the syntax I'm using here is already pretty generic.
&lt;/p&gt;&lt;p&gt;We run the semgrep Docker image:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ docker run -v &amp;quot;${PWD}:/src&amp;quot; returntocorp/semgrep --config=config.yml test/python
A new version of Semgrep is available. Please see https://github.com/returntocorp/semgrep#upgrading for more information.
running 1 rules...
test/python/simple-print.py
severity:warning rule:fail-on-print: Semgrep found a match

2:print(&amp;quot;DEBUG: here&amp;quot;)
ran 1 rules on 1 files: 1 findings&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And there we've got our warning!&lt;/p&gt;
&lt;p class="note"&gt;
  Not completely clear to me why we're getting warned about a new
  version when we've pulled &lt;code&gt;latest&lt;/code&gt; as the linked docs
  suggest. Maybe there's a newer version that hasn't made it into a
  Docker image yet.
&lt;/p&gt;&lt;h3 id="catching-fmt.print*-statements-in-go"&gt;Catching fmt.Print* statements in Go&lt;/h3&gt;&lt;p&gt;Let's say we also want to fail on print statements in Go (because we
should use a logger instead):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;$ cat test/golang/simple-print.go
package main

import &amp;quot;fmt&amp;quot;

func main() {
  a := fmt.Sprintf(&amp;quot;here&amp;quot;)
  fmt.Println(a)
  fmt.Printf(&amp;quot;%s\n&amp;quot;, a)
  e := fmt.Errorf(&amp;quot;My crazy error&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could try to look for any &lt;code&gt;import "fmt"&lt;/code&gt; code in a file
but that would fail on uses of &lt;code&gt;fmt.Sprintf&lt;/code&gt;
or &lt;code&gt;fmt.Errorf&lt;/code&gt; which are fine. Instead we'll just focus on
uses of &lt;code&gt;fmt.Printf&lt;/code&gt; or &lt;code&gt;fmt.Println&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;$ cat go-config.yml
rules:
- id: fail-on-print
  pattern-either:
    - pattern: fmt.Printf(...)
    - pattern: fmt.Println(...)
  message: |
    Semgrep found a match
  severity: WARNING
  mode: search
  languages: [&amp;quot;generic&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run the Go config against the Go files:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ docker run -v &amp;quot;${PWD}:/src&amp;quot; returntocorp/semgrep --config=go-config.yml test/golang
A new version of Semgrep is available. Please see https://github.com/returntocorp/semgrep#upgrading for more information.
running 1 rules...
test/golang/simple-print.go
severity:warning rule:fail-on-print: Semgrep found a match

8:fmt.Printf(&amp;quot;%s\n&amp;quot;, a)
--------------------------------------------------------------------------------
7:fmt.Println(a)
ran 1 rules on 1 files: 2 findings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool! Making some sense. Now let's try a harder pattern.&lt;/p&gt;
&lt;h3 id="catching-triple-nested-for-loops"&gt;Catching triple-nested for loops&lt;/h3&gt;&lt;p&gt;Let's try to warn on the triple-nested loop in this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;$ cat test/golang/loopy.go
package main

import &amp;quot;log&amp;quot;

func main() {
  doneFirst := false
  for i := 0; i &amp;lt; 10; i++ {
    log.Print(i)

    for j := 0; j &amp;lt; 100; j++ {
      c := i * j

      going := true
      k := 0
      for going {
        if k == c {
          break
        }

        k++
        log.Print(k)
      }
    }

    doneFirst = true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to catch the use of nested for loops here then we'll need
to search for the loops surrounded by arbitrary
syntax. Semgrep's &lt;code&gt;...&lt;/code&gt; syntax makes this easy.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;$ cat go-config2.yml
rules:
- id: fail-on-3-loop
  pattern: |
    for ... {
      ...
      for ... {
        ...

        for ... {
          ...
        }
        ...
      }
      ...
    }
  message: |
    Semgrep found a match
  severity: WARNING
  mode: search
  languages: [&amp;quot;generic&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And run semgrep:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ docker run -v &amp;quot;${PWD}:/src&amp;quot; returntocorp/semgrep --config=go-config2.yml test/golang
A new version of Semgrep is available. Please see https://github.com/returntocorp/semgrep#upgrading for more information.
running 1 rules...
test/golang/loopy.go
severity:warning rule:fail-on-3-loop: Semgrep found a match

7:for i := 0; i &amp;lt; 10; i++ {
8:              log.Print(i)
9:
10:             for j := 0; j &amp;lt; 100; j++ {
11:                     c := i * j
12:
13:                     going := true
14:                     k := 0
15:                     for going {
16:                             if k == c {
-------- [hid 10 additional lines, adjust with --max-lines-per-finding] --------
ran 1 rules on 2 files: 1 findings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's just swell.&lt;/p&gt;
&lt;h3 id="limits-of-static-analysis"&gt;Limits of static analysis&lt;/h3&gt;&lt;p&gt;Now let's say we refactor one of the inner loops into its own
function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;$ cat test/golang/loopy.go
package main

import &amp;quot;log&amp;quot;

func inner(i, j int) {
  c := i * j

  going := true
  k := 0
  for going {
    if k == c {
      break
    }

    k++
    log.Print(k)
  }
}

func main() {
  doneFirst := false
  for i := 0; i &amp;lt; 10; i++ {
    log.Print(i)

    for j := 0; j &amp;lt; 100; j++ {
      inner(i, j)
    }

    doneFirst = true
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And run semgrep again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ docker run -v &amp;quot;${PWD}:/src&amp;quot; returntocorp/semgrep --config=go-config2.yml test/golang
 A new version of Semgrep is available. Please see https://github.com/returntocorp/semgrep#upgrading for more information.
 running 1 rules...
 ran 1 rules on 2 files: 0 findings
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well great. The 3-nested loop still exists but we can't find it
anymore because it's not syntactically obvious anymore.&lt;/p&gt;
&lt;p&gt;At this point we'd need to start getting into linting based on runtime
analysis. If you know of a tool that does this and lets you write
rules like semgrep for it, please tell me!&lt;/p&gt;
&lt;h3 id="in-summary"&gt;In summary&lt;/h3&gt;&lt;p&gt;In the end though, it's still very useful to be able to learn a single
language for writing syntax rules at a high level to enforce behavior
in code. Furthermore, a generic syntax matcher helps you write easily
write rules for things that don't already have linters like YAML
or JSON configuration or Vagrantfiles.&lt;/p&gt;
&lt;p&gt;It can be annoying to work around some missing docs in semgrep but
overall it's a great tool for the kit.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;&lt;a href="https://twitter.com/hashtag/semgrep?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#semgrep&lt;/a&gt; is a really neat tool for syntactic analysis. Here are a few simple examples (catch print statements, triple nested loops, etc.) using Docker. Includes some necessary info the docs don&amp;#39;t get into&lt;a href="https://t.co/UDHEH5JmOa"&gt;https://t.co/UDHEH5JmOa&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1340785372364738562?ref_src=twsrc%5Etfw"&gt;December 20, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/static-analysis-with-semgrep.html</guid><pubDate>Sun, 20 Dec 2020 00:00:00 +0000</pubDate></item><item><title>Emulating linux/AMD64 userland: interpreting an ELF binary</title><link>http://notes.eatonphil.com/emulating-amd64-starting-with-elf.html</link><description>&lt;p&gt;In this post we'll stumble toward a working emulator for a barebones C
program compiled for linux/AMD64. The approach will be slightly more
so based on observation than by following a spec; a great way
to quickly become familiar with a topic, and a bad way to guarantee
correctness.&lt;/p&gt;
&lt;p&gt;The goal:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat tests/simple.c
int main() {
  return 4;
}
$ gcc tests/simple.c
$ go build -o main
$ ./main a.out &amp;amp;&amp;amp; echo $?
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may look ridiculously simple but when you don't know how to deal
with a binary or how instructions are encoded, it will take a few
hours to write an emulator that can generally handle this program!&lt;/p&gt;
&lt;p&gt;Code for this project is &lt;a href="https://github.com/eatonphil/go-amd64-emulator"&gt;available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="background"&gt;Background&lt;/h3&gt;&lt;p&gt;AMD64, x86_64 or x64 are different names for AMD's widely adopted
64-bit extension to Intel's x86 instruction set (i.e. the encoding and
semantics of x86 binaries). AMD64 is a superset of x86 (introducing
64-bit registers and operations) and thus backwards compatible with
x86 programs.&lt;/p&gt;
&lt;p class="note"&gt;
  A year and a half ago I first got into emulation with
  an &lt;a href="https://notes.eatonphil.com/emulator-basics-a-stack-and-register-machine.html"&gt;AMD64
  emulator in JavaScript&lt;/a&gt;. The JavaScript emulator interpreted the
  textual representation of AMD64 programs (e.g. &lt;code&gt;MOV RBP,
  RSP&lt;/code&gt;, Intel's assembly syntax). A C program had to be compiled
  with &lt;code&gt;-S&lt;/code&gt; to produce an assembly file that the JavaScript
  emulator could read (i.e. &lt;code&gt;gcc -S tests/simple.c&lt;/code&gt;) This
  was a great way to get started with emulation by ignoring the
  complexity of encoded instructions and executable formats.
&lt;/p&gt;&lt;p&gt;If we dig into the binary file produced by gcc on Linux we learn that
it is an &lt;a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format"&gt;ELF
file&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ gcc test/simple.c
$ file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d0b5c742b9fbcbcca4dfa9438a8437a8478a51bb, for GNU/Linux 3.2.0, not stripped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ELF is responsible for surrounding the actual binary-encoded program
instructions with metadata on exported and imported C identifiers and
program entrypoint. But for simple programs like this initial
emulator, we can ignore export/imports. We'll only use the ELF
metadata to find out where the instructions for our &lt;code&gt;main&lt;/code&gt;
function start.&lt;/p&gt;
&lt;h3 id="where-is-main?"&gt;Where is main?&lt;/h3&gt;&lt;p&gt;If we use an ELF reader+disassembler on the binary generated by gcc
and search for &lt;code&gt;main&lt;/code&gt; we can find its address.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ objdump -d a.out | grep -A10 &amp;#39;&amp;lt;main&amp;gt;&amp;#39;
0000000000401106 &amp;lt;main&amp;gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
  40110f:       5d                      pop    %rbp
  401110:       c3                      retq
  401111:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  401118:       00 00 00
  40111b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000401120 &amp;lt;__libc_csu_init&amp;gt;:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that the function, &lt;code&gt;main&lt;/code&gt;, starts at
address &lt;code&gt;0x401106&lt;/code&gt; in memory. Furthermore, this implies
that the binary must be loaded into CPU memory such that the CPU can
jump here to execute our program.&lt;/p&gt;
&lt;p&gt;In truth, &lt;code&gt;main&lt;/code&gt; is not this program's entrypoint. If we
run &lt;code&gt;objdump -x a.out&lt;/code&gt; we can see that the ELF entrypoint
is &lt;code&gt;0x401020&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ objdump -x a.out
a.out:     file format elf64-x86-64
a.out
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401020

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
             filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because the actual entrypoint gcc sets up is a function called
&lt;code&gt;_start&lt;/code&gt;. The libc prelude beginning
with &lt;code&gt;_start&lt;/code&gt; is responsible for initializing the libc
runtime, calling our &lt;code&gt;main&lt;/code&gt; function and executing the exit
syscall with the return value of &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;objdump -d a.out | grep -A10 &amp;#39;&amp;lt;_start&amp;gt;&amp;#39;
0000000000401020 &amp;lt;_start&amp;gt;:
  401020:       f3 0f 1e fa             endbr64
  401024:       31 ed                   xor    %ebp,%ebp
  401026:       49 89 d1                mov    %rdx,%r9
  401029:       5e                      pop    %rsi
  40102a:       48 89 e2                mov    %rsp,%rdx
  40102d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  401031:       50                      push   %rax
  401032:       54                      push   %rsp
  401033:       49 c7 c0 90 11 40 00    mov    $0x401190,%r8
  40103a:       48 c7 c1 20 11 40 00    mov    $0x401120,%rcx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But because all this libc initialization is relatively complicated
we're just going to skip the actual ELF entrypoint for now. Our
emulator will locate &lt;code&gt;main&lt;/code&gt;, load the binary into memory,
jump to the start of &lt;code&gt;main&lt;/code&gt;, and set the exit code of the
emulator to the result of main.&lt;/p&gt;
&lt;p class="note"&gt;
  As you can see, this ELF binary has its own hard-coded view of where
  it will be in memory. What if our CPU were to run multiple process
  at once? We might give each process its own virtual memory space
  and map back to a real memory space so each process (and by
  extension, compilers) doesn't have to think about how they fit into
  memory relative to other processes.
&lt;/p&gt;&lt;p&gt;The last question to figure out is where to load the ELF binary into
emulator memory so that addresses in memory are where the program
expects.&lt;/p&gt;
&lt;p&gt;As it turns out, there is a piece of metadata called section
headers that contain an address and a offset from the start of the ELF
file. By subtracting this we can get the location the file expects to
be in memory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ objdump -x a.out
a.out:     file format elf64-x86-64
a.out
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401020

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
             filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is: &lt;code&gt;0x400040 (vaddr) - 0x40 (off) = 0x400000&lt;/code&gt;.
Judging from a Google search this seems to be a pretty common address
where ELF binaries are loaded into memory.&lt;/p&gt;
&lt;h3 id="elf-and-go"&gt;ELF and Go&lt;/h3&gt;&lt;p&gt;Binary file formats tend to be a pain to work with because, to enable
greater compression, everything ends up being a pointer to something
else. So you end up jumping all around the file just to stitch
information back together.&lt;/p&gt;
&lt;p&gt;So the one third-party-ish library we'll use is Go's builtin
&lt;code&gt;debug/elf&lt;/code&gt; package. With this library we can load an ELF
binary and iterate over symbols and sections to discover the location
of &lt;code&gt;main&lt;/code&gt; and the start address for the binary in memory.&lt;/p&gt;
&lt;p&gt;Editing in &lt;code&gt;main.go&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;debug/elf&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;log&amp;quot;
    &amp;quot;os&amp;quot;
)

type process struct {
    startAddress uint64
    entryPoint   uint64
    bin          []byte
}

func readELF(filename, entrySymbol string) (*process, error) {
    bin, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }

    elffile, err := elf.NewFile(bytes.NewReader(bin))
    if err != nil {
        return nil, err
    }

    symbols, err := elffile.Symbols()
    if err != nil {
        return nil, err
    }

    var entryPoint uint64
    for _, sym := range symbols {
        if sym.Name == entrySymbol &amp;amp;&amp;amp; elf.STT_FUNC == elf.ST_TYPE(sym.Info) &amp;amp;&amp;amp; elf.STB_GLOBAL == elf.ST_BIND(sym.Info) {
            entryPoint = sym.Value
        }
    }

    if entryPoint == 0 {
        return nil, fmt.Errorf(&amp;quot;Could not find entrypoint symbol: %s&amp;quot;, entrySymbol)
    }

    var startAddress uint64
    for _, sec := range elffile.Sections {
        if sec.Type != elf.SHT_NULL {
            startAddress = sec.Addr - sec.Offset
            break
        }
    }

    if startAddress == 0 {
        return nil, fmt.Errorf(&amp;quot;Could not determine start address&amp;quot;)
    }

    return &amp;amp;process{
        startAddress: startAddress,
        entryPoint:   entryPoint,
        bin:          bin,
    }, nil
}

func main() {
    if len(os.Args) &amp;lt; 2 {
        log.Fatal(&amp;quot;Binary not provided&amp;quot;)
    }

    proc, err := readELF(os.Args[1], &amp;quot;main&amp;quot;)
    if err != nil {
        panic(err)
    }

    fmt.Printf(&amp;quot;Start: 0x%x\nEntry: 0x%x\n&amp;quot;, proc.startAddress, proc.entryPoint)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can test on a basic compiled C program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat tests/simple.c
int main() {
  return 4;
}
$ gcc tests/simple.c
$ go build -o main
$ ./main a.out
Start: 0x400000
Entry: 0x401106
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And verify against &lt;code&gt;objdump&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ objdump -d a.out | grep -A10 &amp;#39;&amp;lt;main&amp;gt;&amp;#39;
0000000000401106 &amp;lt;main&amp;gt;:
  401106:       55                      push   %rbp&amp;#39;&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for dealing with ELF. Now we can sketch out a virtual
CPU and how we deal with interpreting instructions starting at this
address.&lt;/p&gt;
&lt;h3 id="the-cpu"&gt;The CPU&lt;/h3&gt;&lt;p&gt;AMD64 counts on being able to store values in registers and memory,
sometimes through direct addressing and sometimes indirectly using
stack operations (push and pop). And userland processes count on being
loaded into CPU memory so the CPU can jump to the process entrypoint
and process.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type cpu struct {
    proc    *process
    mem     []byte
    regfile *registerFile
    tick    chan bool
}

func newCPU(memory uint64) cpu {
    return cpu{
        mem:     make([]byte, memory),
        regfile: &amp;amp;registerFile{},
        tick:    make(chan bool, 1),
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;tick&lt;/code&gt; channel is so that later on we can wrap the
emulator in a terminal debugger. But by default we'll just set up a
goroutine to tick forever.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func repl(c *cpu) {
  // TODO
}

func main() {
    if len(os.Args) &amp;lt; 2 {
        log.Fatal(&amp;quot;Binary not provided&amp;quot;)
    }

    proc, err := readELF(os.Args[1], &amp;quot;main&amp;quot;)
    if err != nil {
        panic(err)
    }

    debug := false
    for _, arg := range os.Args[1:] {
        switch arg {
        case &amp;quot;--debug&amp;quot;:
            fallthrough
        case &amp;quot;-d&amp;quot;:
            debug = true
        }
    }

    // 10 MB
    cpu := newCPU(0x400000 * 10)

    go cpu.run(proc)
    if debug {
        repl(&amp;amp;cpu)
    } else {
        for {
            cpu.tick &amp;lt;- true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="registers"&gt;Registers&lt;/h3&gt;&lt;p&gt;To emulate a simple program like our &lt;code&gt;tests/simple.c&lt;/code&gt;,
we'll only need to support a few common registers. The order is
important so that we can use the Go identifiers when we want to refer
to the &lt;a href="https://wiki.osdev.org/X86-64_Instruction_Encoding#Registers"&gt;encoded integer value of the
register&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type register int

const (
    // These are in order of encoding value (i.e. rbp is 5)
    rax register = iota
    rcx
    rdx
    rbx
    rsp
    rbp
    rsi
    rdi
    r8
    r9
    r10
    r11
    r12
    r13
    r14
    r15
    rip
    rflags
)

var registerMap = map[register]string{
    rax:    &amp;quot;rax&amp;quot;,
    rcx:    &amp;quot;rcx&amp;quot;,
    rdx:    &amp;quot;rdx&amp;quot;,
    rbx:    &amp;quot;rbx&amp;quot;,
    rsp:    &amp;quot;rsp&amp;quot;,
    rbp:    &amp;quot;rbp&amp;quot;,
    rsi:    &amp;quot;rsi&amp;quot;,
    rdi:    &amp;quot;rdi&amp;quot;,
    r8:     &amp;quot;r8&amp;quot;,
    r9:     &amp;quot;r9&amp;quot;,
    r10:    &amp;quot;r10&amp;quot;,
    r11:    &amp;quot;r11&amp;quot;,
    r12:    &amp;quot;r12&amp;quot;,
    r13:    &amp;quot;r13&amp;quot;,
    r14:    &amp;quot;r14&amp;quot;,
    r15:    &amp;quot;r15&amp;quot;,
    rip:    &amp;quot;rip&amp;quot;,
    rflags: &amp;quot;rflags&amp;quot;,
}

type registerFile [18]uint64

func (regfile *registerFile) get(r register) uint64 {
    return regfile[r]
}

func (regfile *registerFile) set(r register, v uint64) {
    regfile[r] = v
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of immediate importance will be &lt;code&gt;rip&lt;/code&gt;, &lt;code&gt;rsp&lt;/code&gt;,
and &lt;code&gt;rax&lt;/code&gt; registers. &lt;code&gt;rip&lt;/code&gt; is used to track the
current instruction to process. It will generally be incremented
except for when dealing with function calls and
returns. &lt;code&gt;rsp&lt;/code&gt; is used as a pointer to the top of a stack
in memory. It is incremented and decremented as values are pushed and
popped on this stack. Finally, &lt;code&gt;rax&lt;/code&gt; is used to pass
function return values.&lt;/p&gt;
&lt;h3 id="loading-a-program"&gt;Loading a program&lt;/h3&gt;&lt;p&gt;Running a program is a matter of loading the program into memory,
setting the stack pointer to the last address of memory (in x86 the
stack grows down), pointing &lt;code&gt;rip&lt;/code&gt; at the entrypoint, and
looping until the entrypoint function returns.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func writeBytes(to []byte, start uint64, bytes int, val uint64) {
    for i := 0; i &amp;lt; bytes; i++ {
        to[start+uint64(i)] = byte(val &amp;gt;&amp;gt; (8 * i) &amp;amp; 0xFF)
    }
}

func (c *cpu) loop(entryReturnAddress uint64) {
    for {
        &amp;lt;-c.tick

        ip := c.regfile.get(rip)
        if ip == entryReturnAddress {
            break
        }

        inb1 := c.mem[ip]

        // TODO: deal with instructions

        // move to next instruction
        c.regfile.set(rip, ip+1)
    }
}

func (c *cpu) run(proc *process) {
    copy(c.mem[proc.startAddress:proc.startAddress+uint64(len(proc.bin))], proc.bin)
    c.regfile.set(rip, proc.entryPoint)
    initialStackPointer := uint64(len(c.mem)-8)
    writeBytes(c.mem, initialStackPointer, 8, initialStackPointer)
    c.regfile.set(rsp, initialStackPointer)
    c.loop(initialStackPointer)
    os.Exit(int(c.regfile.get(rax)))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We write the initial stack pointer address into the stack so that when
the program final returns, it will return to this address at which
pointer we can exit the program.&lt;/p&gt;
&lt;p&gt;And now we're ready to start interpreting instructions.&lt;/p&gt;
&lt;h3 id="instruction-decoding"&gt;Instruction decoding&lt;/h3&gt;&lt;p&gt;Using &lt;code&gt;objdump&lt;/code&gt; we get a sense for what the program decodes
to.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ objdump -d a.out | grep -A10 &amp;#39;&amp;lt;main&amp;gt;&amp;#39;
0000000000401106 &amp;lt;main&amp;gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
  40110f:       5d                      pop    %rbp
  401110:       c3                      retq
  401111:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  401118:       00 00 00
  40111b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000401120 &amp;lt;__libc_csu_init&amp;gt;:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see that &lt;code&gt;0x55&lt;/code&gt; means &lt;code&gt;push
%rbp&lt;/code&gt;. And we also see that instructions aren't a fixed number
of bytes. Some are one byte, some are seven. Some (not shown) are &lt;a href="https://stackoverflow.com/questions/14698350/x86-64-asm-maximum-bytes-for-an-instruction"&gt;even
longer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thankfully instructions follow some fairly simple patterns. There are
a set of prefix instructions and a set of real instructions. So far we
should be able to tell on the first byte whether the instruction is a
prefix instruction and, if not, how many bytes the instruction will
take up on the whole.&lt;/p&gt;
&lt;h4 id="push"&gt;push&lt;/h4&gt;&lt;p&gt;To support a new instruction, we'll look up &lt;code&gt;0x55&lt;/code&gt; in an
opcode table like &lt;a href="http://ref.x86asm.net/coder64.html"&gt;this&lt;/a&gt;. Clicking
on &lt;a href="http://ref.x86asm.net/coder64.html#x50"&gt;55&lt;/a&gt; in the opcode index we
see that this is indeed a push instruction. &lt;code&gt;50+r&lt;/code&gt; means
that we have to subtract &lt;code&gt;0x50&lt;/code&gt; from the opcode to
determine the register we should push.&lt;/p&gt;
&lt;p&gt;The register will be &lt;code&gt;0x55 - 0x50 = 5&lt;/code&gt; which if we look up
in a &lt;a href="https://wiki.osdev.org/X86-64_Instruction_Encoding#Registers"&gt;register
table&lt;/a&gt;
is &lt;code&gt;rbp&lt;/code&gt;. Since we set up our register enum in code in this
order, we'll be able to just use the constant &lt;code&gt;rbp&lt;/code&gt; in Go
code.&lt;/p&gt;
&lt;p&gt;Finally, since the next instruction numerically is &lt;code&gt;0x58&lt;/code&gt;
we know that this instruction is identified by being between
&lt;code&gt;0x50&lt;/code&gt; and &lt;code&gt;0x57&lt;/code&gt; inclusive. This is all the
info we need to handle this instruction.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;// helper for dumping byte arrays as hex
func hbdebug(msg string, bs []byte) {
    str := &amp;quot;%s:&amp;quot;
    args := []interface{}{msg}
    for _, b := range bs {
        str = str + &amp;quot; %x&amp;quot;
        args = append(args, b)
    }
    fmt.Printf(str+&amp;quot;\n&amp;quot;, args...)
}

func (c *cpu) loop(entryReturnAddress uint64) {
    for {
        &amp;lt;-c.tick

        ip := c.regfile.get(rip)
        if ip == entryReturnAddress {
            break
        }

        inb1 := c.mem[ip]

        if inb1 &amp;gt;= 0x50 &amp;amp;&amp;amp; inb1 &amp;lt; 0x58 { // push
            regvalue := c.regfile.get(register(inb1 - 0x50))
            sp := c.regfile.get(rsp)
            writeBytes(c.mem, sp-8, 8, regvalue)
            c.regfile.set(rsp, uint64(sp-8))
        } else {
            hbdebug(&amp;quot;prog&amp;quot;, c.mem[ip:ip+10])
            panic(&amp;quot;Unknown instruction&amp;quot;)
        }

        c.regfile.set(rip, ip+1)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we try this out now we should expect it to panic on the second
byte, &lt;code&gt;0x48&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build -o main
$ ./main a.out
prog: 48 89 e5 b8 4 0 0 0 5d c3
panic: Unknown instruction

goroutine 19 [running]:
main.(*cpu).loop(0xc000086c30, 0x2800000)
        /home/phil/tmp/goamd/main.go:168 +0x16d
main.(*cpu).run(0xc000086c30, 0xc000086c00)
        /home/phil/tmp/goamd/main.go:180 +0xac
created by main.main
        /home/phil/tmp/goamd/main.go:211 +0x286
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking good.&lt;/p&gt;
&lt;h4 id="mov"&gt;mov&lt;/h4&gt;&lt;p&gt;Taking a look at the next two instructions with &lt;code&gt;objdump&lt;/code&gt;
we see &lt;code&gt;mov&lt;/code&gt; encoded two different ways.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ objdump -d a.out | grep -A4 &amp;#39;&amp;lt;main&amp;gt;&amp;#39;
0000000000401106 &amp;lt;main&amp;gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking up &lt;a href="http://ref.x86asm.net/coder64.html#x48"&gt;0x48&lt;/a&gt; we see that
this is a prefix instruction that turns on 64-bit mode for the
instruction. Some instructions like &lt;code&gt;pop&lt;/code&gt; and
&lt;code&gt;push&lt;/code&gt; don't need this prefix to be in 64-bit mode. In any
case, this just means we'll have to have a size flag that switches
from 32-bit to 64-bit mode on seeing this instruction. This flag will
be reset each time we start reading an instruction.&lt;/p&gt;
&lt;p&gt;To deal with prefixes in general we'll loop through bytes when
processing an instruction until we no longer see a prefix bytes. As we
see prefix bytes we'll handle them accordingly.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;var prefixBytes = []byte{0x48}

func (c *cpu) loop(entryReturnAddress uint64) {
    for {
        &amp;lt;-c.tick

        ip := c.regfile.get(rip)
        if ip == entryReturnAddress {
            break
        }

        inb1 := c.mem[ip]

        widthPrefix := 32
        for {
            isPrefixByte := false
            for _, prefixByte := range prefixBytes {
                if prefixByte == inb1 {
                    isPrefixByte = true
                    break
                }
            }

            if !isPrefixByte {
                break
            }

            // 64 bit prefix signifier
            if inb1 == 0x48 {
                widthPrefix = 64
            } else {
                hbdebug(&amp;quot;prog&amp;quot;, c.mem[ip:ip+10])
                panic(&amp;quot;Unknown prefix instruction&amp;quot;)
            }

            ip++
            inb1 = c.mem[ip]
        }

        if inb1 &amp;gt;= 0x50 &amp;amp;&amp;amp; inb1 &amp;lt; 0x58 { // push

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moving past this prefix we get to
&lt;a href="http://ref.x86asm.net/coder64.html#x89"&gt;0x89&lt;/a&gt;. This instruction is
for copying one register into another. The register operands are
&lt;a href="http://www.c-jump.com/CIS77/CPU/x86/X77_0270_modrm_byte.htm"&gt;encoded in the second
byte&lt;/a&gt;,
&lt;code&gt;0xe5&lt;/code&gt;, called the ModR/M byte. Pulling out the two
registers is just a matter of shifting and bitmasking the right 3 bits
for each.&lt;/p&gt;
&lt;p&gt;With this knowledge we can expand the instruction handling code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;        if inb1 &amp;gt;= 0x50 &amp;amp;&amp;amp; inb1 &amp;lt; 0x58 { // push
            regvalue := c.regfile.get(register(inb1 - 0x50))
            sp := c.regfile.get(rsp)
            writeBytes(c.mem, sp-8, 8, regvalue)
            c.regfile.set(rsp, uint64(sp-8))
        }  else if inb1 == 0x89 { // mov r/m16/32/64, r/m16/32/64
            ip++
            inb2 := c.mem[ip]
            rhs := register((inb2 &amp;amp; 0b00111000) &amp;gt;&amp;gt; 3)
            lhs := register(inb2 &amp;amp; 0b111)
            c.regfile.set(lhs, c.regfile.get(rhs))
        } else {
            hbdebug(&amp;quot;prog&amp;quot;, c.mem[ip:ip+10])
            panic(&amp;quot;Unknown instruction&amp;quot;)
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Try emulating &lt;code&gt;a.out&lt;/code&gt; again now. It will panic on the next
unknown instruction, &lt;code&gt;0xb8&lt;/code&gt;. From &lt;code&gt;objdump&lt;/code&gt;
disassembly we see this is another &lt;code&gt;mov&lt;/code&gt; instruction.&lt;/p&gt;
&lt;p&gt;Hurray! There are apparently multiple ways the same instruction can be
encoded. Looking it up in the opcode table, we see
&lt;a href="http://ref.x86asm.net/coder64.html#xB8"&gt;0xB8&lt;/a&gt; is for when the value
to be copied is a literal number. The operand will be 32-bits, or four
bytes, presumably because it doesn't have the &lt;code&gt;0x48&lt;/code&gt;
prefix.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;// helper for converting up to 8 bytes into a single integer
func readBytes(from []byte, start uint64, bytes int) uint64 {
    val := uint64(0)
    for i := 0; i &amp;lt; bytes; i++ {
        val |= uint64(from[start+uint64(i)]) &amp;lt;&amp;lt; (8 * i)
    }

    return val
}

func (c *cpu) loop(entryReturnAddress uint64) {

    ...

    for {

        ...

        } else if inb1 &amp;gt;= 0xB8 &amp;amp;&amp;amp; inb1 &amp;lt; 0xC0 { // mov r16/32/64, imm16/32/64
            lreg := register(inb1 - 0xB8)
            val := readBytes(c.mem, ip+uint64(1), widthPrefix/8)
            ip += uint64(widthPrefix / 8)
            c.regfile.set(lreg, val)
        }

        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Two more instructions to go: &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;ret&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="a-terminal-debugger"&gt;A terminal debugger&lt;/h3&gt;&lt;p&gt;Taking a break for a moment, our system is already too complex to
understand. It would be helpful to have a REPL so we can step through
instructions and print register and memory values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (c *cpu) resolveDebuggerValue(dval string) (uint64, error) {
    for reg, val := range registerMap {
        if val == dval {
            return c.regfile.get(reg), nil
        }
    }

    if len(dval) &amp;gt; 2 &amp;amp;&amp;amp; (dval[:2] == &amp;quot;0x&amp;quot; || dval[:2] == &amp;quot;0X&amp;quot;) {
        return strconv.ParseUint(dval[2:], 16, 64)
    }

    return strconv.ParseUint(dval, 10, 64)
}

func repl(c *cpu) {
    fmt.Println(&amp;quot;go-amd64-emulator REPL&amp;quot;)
    help := `commands:
    s/step:             continue to next instruction
    r/registers [$reg]:     print all register values or just $reg
    d/decimal:          toggle hex/decimal printing
    m/memory $from $count:      print memory values starting at $from until $from+$count
    h/help:             print this`
    fmt.Println(help)
    scanner := bufio.NewScanner(os.Stdin)

    intFormat := &amp;quot;%d&amp;quot;
    for {
        fmt.Printf(&amp;quot;&amp;gt; &amp;quot;)
        if !scanner.Scan() {
            break
        }
        input := scanner.Text()
        parts := strings.Split(input, &amp;quot; &amp;quot;)

        switch parts[0] {
        case &amp;quot;h&amp;quot;:
            fallthrough
        case &amp;quot;help&amp;quot;:
            fmt.Println(help)

        case &amp;quot;m&amp;quot;:
            fallthrough
        case &amp;quot;memory&amp;quot;:
            msg := &amp;quot;Invalid arguments: m/memory $from $to; use hex (0x10), decimal (10), or register name (rsp)&amp;quot;
            if len(parts) != 3 {
                fmt.Println(msg)
                continue
            }

            from, err := c.resolveDebuggerValue(parts[1])
            if err != nil {
                fmt.Println(msg)
                continue
            }

            to, err := c.resolveDebuggerValue(parts[2])
            if err != nil {
                fmt.Println(msg)
                continue
            }

            hbdebug(fmt.Sprintf(&amp;quot;memory[&amp;quot;+intFormat+&amp;quot;:&amp;quot;+intFormat+&amp;quot;]&amp;quot;, from, from+to), c.mem[from:from+to])

        case &amp;quot;d&amp;quot;:
            fallthrough
        case &amp;quot;decimal&amp;quot;:
            if intFormat == &amp;quot;%d&amp;quot; {
                intFormat = &amp;quot;0x%x&amp;quot;
                fmt.Println(&amp;quot;Numbers displayed as hex&amp;quot;)
            } else {
                intFormat = &amp;quot;%d&amp;quot;
                fmt.Println(&amp;quot;Numbers displayed as decimal&amp;quot;)
            }

        case &amp;quot;r&amp;quot;:
            fallthrough
        case &amp;quot;registers&amp;quot;:
            filter := &amp;quot;&amp;quot;
            if len(parts) &amp;gt; 1 {
                filter = parts[1]
            }

            for i := 0; i &amp;lt; len(registerMap); i++ {
                reg := register(i)
                name := registerMap[reg]
                if filter != &amp;quot;&amp;quot; &amp;amp;&amp;amp; filter != name {
                    continue
                }

                fmt.Printf(&amp;quot;%s:\t&amp;quot;+intFormat+&amp;quot;\n&amp;quot;, name, c.regfile.get(reg))
            }

        case &amp;quot;s&amp;quot;:
            fallthrough
        case &amp;quot;step&amp;quot;:
            c.tick &amp;lt;- true
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's try it out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build -o main
$ ./main a.out --debug
go-amd64-emulator REPL
commands:
        s/step:                         continue to next instruction
        r/registers [$reg]:             print all register values or just $reg
        d/decimal:                      toggle hex/decimal printing
        m/memory $from $count:          print memory values starting at $from until $from+$count
        h/help:                         print this
&amp;gt; r
rax:    0
rcx:    0
rdx:    0
rbx:    0
rsp:    41943040
rbp:    0
rsi:    0
rdi:    0
r8:     0
r9:     0
r10:    0
r11:    0
r12:    0
r13:    0
r14:    0
r15:    0
rip:    4198662
rflags: 0
&amp;gt; m rip 10
memory[4198662:4198672]: 55 48 89 e5 b8 4 0 0 0 5d
&amp;gt; s
&amp;gt; m rip 10
memory[4198663:4198673]: 48 89 e5 b8 4 0 0 0 5d c3
&amp;gt; r
rax:    0
rcx:    0
rdx:    0
rbx:    0
rsp:    41943032
rbp:    0
rsi:    0
rdi:    0
r8:     0
r9:     0
r10:    0
r11:    0
r12:    0
r13:    0
r14:    0
r15:    0
rip:    4198663
rflags: 0
&amp;gt; ^D
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can inspect the system interactively.&lt;/p&gt;
&lt;h3 id="pop"&gt;pop&lt;/h3&gt;&lt;p&gt;Reemersing in the state of things, we now panic on &lt;code&gt;0x5D&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./main a.out
prog: 5d c3 66 2e f 1f 84 0 0 0
panic: Unknown instruction

goroutine 5 [running]:
main.(*cpu).loop(0xc000098ae0, 0x2800000)
        /home/phil/tmp/goamd/main.go:219 +0x2c5
main.(*cpu).run(0xc000098ae0, 0xc000098ab0)
        /home/phil/tmp/goamd/main.go:231 +0xac
created by main.main
        /home/phil/tmp/goamd/main.go:358 +0x286
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking &lt;a href="http://ref.x86asm.net/coder64.html#x5D"&gt;this up&lt;/a&gt; we see this
is part of &lt;code&gt;58+r&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;. Similar to
&lt;code&gt;push&lt;/code&gt; we subtract &lt;code&gt;0x58&lt;/code&gt; from the byte to get
the register to pop onto. The stack operation is the reverse of
&lt;code&gt;push&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (c *cpu) loop(entryReturnAddress uint64) {

    ...

    for {

        ...

        } else if inb1 &amp;gt;= 0x58 &amp;amp;&amp;amp; inb1 &amp;lt; 0x60 { // pop
            lhs := register(inb1 - 0x58)
            sp := c.regfile.get(rsp)
            c.regfile.set(lhs, readBytes(c.mem, sp, 8))
            c.regfile.set(rsp, uint64(sp+8))
        }
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build and run for the final panic:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build -o main
$ ./main a.out
prog: c3 66 2e f 1f 84 0 0 0 0
panic: Unknown instruction

goroutine 8 [running]:
main.(*cpu).loop(0xc000060c30, 0x2800000)
        /home/phil/tmp/goamd/main.go:224 +0x345
main.(*cpu).run(0xc000060c30, 0xc000060c00)
        /home/phil/tmp/goamd/main.go:236 +0xac
created by main.main
        /home/phil/tmp/goamd/main.go:363 +0x286
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ret"&gt;ret&lt;/h3&gt;&lt;p&gt;Looking up &lt;a href="http://ref.x86asm.net/coder64.html#xC3"&gt;0xC3&lt;/a&gt; we see that
it is indeed &lt;code&gt;ret&lt;/code&gt;. This function's responsibilty is to pop
the stack onto rip, jumping back to caller.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;        } else if inb1 == 0xC3 { // ret
            sp := c.regfile.get(rsp)
            retAddress := readBytes(c.mem, sp, 8)
            c.regfile.set(rsp, uint64(sp+8))
            c.regfile.set(rip, retAddress)
            continue
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build and run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build -o main
$ ./main a.out
$ echo $?
4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we modify &lt;code&gt;tests/simple.c&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat tests/simple.c
int main() {
  return 254;
}
$ gcc tests/simple.c
$ ./main a.out &amp;amp;&amp;amp; echo $?
254
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not bad!&lt;/p&gt;
&lt;h3 id="process-and-next-steps"&gt;Process and next steps&lt;/h3&gt;&lt;p&gt;Getting this far took a lot of trial and error, much of it hidden in
this post. Setting up the REPL was critical to debugging mistakes. But
aggressively unit testing would probably have been similarly
fruitful. In the end, the most bug-prone aspects are basic arithmetic
(off by one errors and converting bytes to/from integers). The part
that's not terribly hard is actually interpreting instructions! But
it's made easier by greatly simplifying the problem and ignoring
legion cases.&lt;/p&gt;
&lt;p&gt;Along the way it would have been helpful to also disassemble so that
instead of just dumping memory at the instruction pointer we print the
instructions we thought we were going to process. That may be a next
goal.&lt;/p&gt;
&lt;p&gt;Otherwise the typical goals are around getting syscall support,
function call support, and porting these simple examples to Windows
and macOS for the experience.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Here&amp;#39;s take two on writing an emulator for linux/amd64 in Go.  This time we&amp;#39;re starting with ELF binaries, but still ignoring libc and jumping straight to main.&lt;a href="https://t.co/A87r2RY21c"&gt;https://t.co/A87r2RY21c&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1332111601814691840?ref_src=twsrc%5Etfw"&gt;November 26, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/emulating-amd64-starting-with-elf.html</guid><pubDate>Thu, 26 Nov 2020 00:00:00 +0000</pubDate></item><item><title>The impact of management teams as a decision-making group, in startups and enterprise</title><link>http://notes.eatonphil.com/the-impact-of-management-teams-on-startups-and-enterprises.html</link><description>&lt;p&gt;Ambitious companies form management teams at every level above you,
sometimes including you. Management teams meet periodically and have
private chat rooms. They discuss customers, product and organizational
direction. Sometimes discussions are well documented and periodically
public. Sometimes decisions are poorly telegraphed out.&lt;/p&gt;
&lt;p&gt;Management teams do no inherent harm in a company with customers;
employees outside of the management team can unearth customer usage
data to discover meaningful places to contribute. For example,
graphing historic server logs to discover slowest requests, figure out
why and how to fix. Or even just paying attention to the most frequent
questions sales asks and finding ways to clarify. (All of this under
the assumption that even when there is solid product direction, good
employees tend to have extra time at work and want to make good use of
it.)&lt;/p&gt;
&lt;p&gt;For the first few years even in a well-funded startup with solid
founders, there are few customers. Even under a solid product team,
the product direction is not yet completely clear. The management team
includes founders and non-engineering executives. As a decision making
group they are opaque. Employees outside the management team face a
barrier in finding ways to meaningful contribute. Ambitious, dedicated
folks outside the team leave.&lt;/p&gt;
&lt;h3 id="so-what?"&gt;So what?&lt;/h3&gt;&lt;p&gt;It is not clear to me how the natural (and not inherently bad) concept
of management teams attracts and retains ambitious, dedicated
non-founders at small companies. Maybe disenfranchisement is not
important, or even necessary.&lt;/p&gt;
&lt;p&gt;Or maybe management teams as a decision-making group are too easily a
substitute for developing a grassroots culture of collaboration and
trust between marketing, sales, product and development.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New post! &amp;quot;management teams as a decision-making group are too easily a substitute for developing a grassroots culture of collaboration and trust between marketing, sales, product and development.&amp;quot;&lt;a href="https://t.co/7RukBMI59h"&gt;https://t.co/7RukBMI59h&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1328482381314084864?ref_src=twsrc%5Etfw"&gt;November 16, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/the-impact-of-management-teams-on-startups-and-enterprises.html</guid><pubDate>Wed, 11 Nov 2020 00:00:00 +0000</pubDate></item><item><title>Standard ML in 2020</title><link>http://notes.eatonphil.com/standard-ml-in-2020.html</link><description>&lt;p&gt;Incredibly, Standard ML implementations are still actively
developed. &lt;a href="http://mlton.org/"&gt;MLton&lt;/a&gt;, &lt;a href="https://polyml.org"&gt;Poly/ML&lt;/a&gt;,
&lt;a href="https://elsman.com/mlkit/"&gt;MLKit&lt;/a&gt;,
&lt;a href="https://www.pllab.riec.tohoku.ac.jp/smlsharp/"&gt;SML#&lt;/a&gt; and
&lt;a href="http://smlnj-gforge.cs.uchicago.edu/scm/viewvc.php/?root=smlnj"&gt;SML/NJ&lt;/a&gt;
are the most prominent. Discussion on the future direction of Standard
ML &lt;a href="https://github.com/SMLFamily/Successor-ML/issues"&gt;remains healthy as
well&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And somehow OCaml's lesser known cousin still beats out OCaml for
multicore threading support (in Poly/ML).&lt;/p&gt;
&lt;p&gt;While MLton hasn't merged with
&lt;a href="https://github.com/kayceesrk/multiMLton"&gt;MultiMLton&lt;/a&gt; or
&lt;a href="https://github.com/UBMLtonGroup/RTMLton"&gt;RTMLton&lt;/a&gt; to support
multicore, a &lt;a href="https://github.com/mpllang/mpl"&gt;new fork of MLton with
parallelism&lt;/a&gt; is pretty far along and
in active development at CMU.&lt;/p&gt;
&lt;p class="note"&gt;
  A commentor shared
  &lt;a href="https://github.com/ManticoreProject/manticore"&gt;Manticore&lt;/a&gt;,
  another implementation with parallelism support in active
  development at UChicago.
&lt;/p&gt;&lt;p&gt;Furthermore, the last few years have welcomed some entirely new
implementations. &lt;a href="https://github.com/KeenS/webml"&gt;WebML&lt;/a&gt;, by a
prominent open source hacker, is written in Rust and compiles Standard
ML to WebAssembly. &lt;a href="https://sosml.org/"&gt;SOSML&lt;/a&gt; is an interpreter
written in TypeScript by former students of Saarland University. It
features &lt;a href="https://sosml.org/editor"&gt;a nifty online
IDE&lt;/a&gt;.&lt;/p&gt;
&lt;p class="note"&gt;
  A commenter
  shared &lt;a href="https://github.com/SomewhatML/sml-compiler"&gt;SomewhatML&lt;/a&gt;,
  an actively developing compiler for Standard ML written in Rust.
&lt;/p&gt;&lt;p&gt;There have also been some new experimental spins on Standard ML in
the last few years. &lt;a href="https://github.com/julianhyde/morel"&gt;Morel&lt;/a&gt; is an
interpreter with some nice syntax extensions written in Java by the
author of Apache Calcite. And &lt;a href="https://github.com/elpinal/bright-ml"&gt;Bright
ML&lt;/a&gt; is a spin on Standard ML and
OCaml written in Standard ML (and using the abandoned &lt;a href="https://mosml.org/"&gt;Moscow
ML&lt;/a&gt; compiler of all implementations).&lt;/p&gt;
&lt;p&gt;So if you're looking for an easy intro to the ML family of languages,
I still recommend the simplicity and performance of Standard ML and
its small but definitely, surprisingly, not dead community. :)&lt;/p&gt;
&lt;p&gt;Additional resources:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://smlfamily.github.io/"&gt;SML Family Site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://smlfamily.github.io/Basis/index.html"&gt;SML Standard Library (Basis Library) Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://reddit.com/r/sml"&gt;/r/sml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Are you using Standard ML? &lt;a href="mailto:me@eatonphil.com"&gt;Let me know how/why!&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Standard ML implementations are still in active development! There have even been some interesting new implementations pop up in the last few years.&lt;a href="https://t.co/6kOcMKVfQa"&gt;https://t.co/6kOcMKVfQa&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1320487302418845696?ref_src=twsrc%5Etfw"&gt;October 25, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/standard-ml-in-2020.html</guid><pubDate>Sun, 25 Oct 2020 00:00:00 +0000</pubDate></item><item><title>The case for comments in code</title><link>http://notes.eatonphil.com/the-case-for-comments-in-code.html</link><description>&lt;p&gt;When I first started programming, especially when asked for code
samples, my comments lacked purpose and would often duplicate in
English what the code clearly indicated. I knew that "commenting is
good" but as a beginner I had no further insight.&lt;/p&gt;
&lt;p&gt;Over time with the help of books like Clean Code, I grew disdainful of
comments. Good code should be self-documenting. Whenever I needed to
write a comment to explain something, I'd realize I could easily
rename some key variable or function. I grew more comfortable with
variables and functions with a few words in the title. Better to spend
time on good code structure and naming.&lt;/p&gt;
&lt;p class="note"&gt;
  I have always left TODOs though, since TODOs can't so easily be
  expressed in variable names. But even these TODOs concerned me
  because they existed in my issue tracker, or maybe should have.
&lt;/p&gt;&lt;p&gt;As I watched mature open source projects and mature engineers, I came
to value well-documented pull requests. Solid pull requests include or
link to all necessary background, opportunities failed or ignored, how
to use, links to external bugs requiring workarounds and the results
of performance evaluation.&lt;/p&gt;
&lt;p&gt;Beyond pull request descriptions, when I really wanted to grease a
pull request I'd use the pull request UI to add comments calling
reviewer attention to key changes in lines of the diff.&lt;/p&gt;
&lt;p&gt;Both kinds of guidance are a massive aid to reviewers, saving a lot of
time.&lt;/p&gt;
&lt;p&gt;But when I'd find a bug in code -- and I knew there was good pull
request documentation, even for pull requests as recent as six months
ago -- I've been repeatedly failed by the pull request and &lt;em&gt;pull
request comment&lt;/em&gt; search exposed by Github and Gitlab.&lt;/p&gt;
&lt;p&gt;I &lt;em&gt;knew&lt;/em&gt; there were links to documented oddities or bug reports in
pull request threads. But practically speaking, for historic pull
requests, pull request comments are useless.&lt;/p&gt;
&lt;p&gt;This is the single biggest reason I've started to push for more
comments in code. More so than all other tools (issue tracker, code
management system, etc.) comments in code have the greatest chance of
still being around and &lt;em&gt;easily searchable&lt;/em&gt; if they haven't been
deleted.&lt;/p&gt;
&lt;p class="note"&gt;
  Don't get me started on pull request documentation in an external
  medium like Slack. It's so rewarding to get or give instant feedback
  on changes on instant messengers, but good luck finding that
  discussion 3 months later.
&lt;/p&gt;&lt;p&gt;Every time I have to call out a line of code in a pull request, that's
immediate cause for that code to be modified with comments.&lt;/p&gt;
&lt;p&gt;Maybe I wouldn't do this if Github/Gitlab exposed a Google Docs-like
interface for browsing code line by line with links to all pull
request comment threads.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The biggest reason to add comments in code (often linking to documented oddities or bug reports) is because it&amp;#39;s impossible to search pull request threads historically in every source control management UI I&amp;#39;ve used.&lt;a href="https://t.co/JlHWfbUH5z"&gt;https://t.co/JlHWfbUH5z&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1303130504993136642?ref_src=twsrc%5Etfw"&gt;September 8, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/the-case-for-comments-in-code.html</guid><pubDate>Mon, 07 Sep 2020 00:00:00 +0000</pubDate></item><item><title>Writing a simple Python compiler: 1. hello, fibonacci</title><link>http://notes.eatonphil.com/writing-a-simple-python-compiler.html</link><description>&lt;p&gt;In this post we'll write a Python to C compiler in Python. This is
especially easy to do since Python has a &lt;a href="https://docs.python.org/3/library/ast.html"&gt;builtin parser
library&lt;/a&gt; and because a
number of &lt;a href="https://docs.python.org/3/c-api/"&gt;CPython internals are exposed for extension
writers&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By the end of this post, in a few hundred lines of Python, we'll be able to
compile and run the following program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;$ cat tests/recursive_fib.py
def fib(n):
    if n == 0 or n == 1:
        return n

    return fib(n - 1) + fib(n - 2)


def main():
    print(fib(40))
$ python3 pyc tests/recursive_fib.py
$ ./bin/a.out
102334155
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This post implements an extremely small subset of Python and
&lt;strong&gt;completely gives up on even trying to manage memory&lt;/strong&gt; because I
cannot fathom manual reference counting. Maybe some day I'll find a
way to swap in an easy GC like Boehm.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/pyc"&gt;Source code for this project is available on Github.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="dependencies"&gt;Dependencies&lt;/h3&gt;&lt;p&gt;We'll need Python3, GCC, libpython3, and clang-format.&lt;/p&gt;
&lt;p&gt;On Fedora-based systems:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo dnf install gcc python3-devel clang-format python3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And on Debian-based systems:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo apt install gcc python3-dev clang-format python3
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  This program will likely work as well on Windows, Mac, FreeBSD,
  etc. but I haven't gone through the trouble of testing this (or
  providing custom compiler directives). Pull requests welcome!
&lt;/p&gt;&lt;h3 id="a-hand-written-first-pass"&gt;A hand-written first-pass&lt;/h3&gt;&lt;p&gt;Before we get into the compiler, let's write the fibonacci program by
hand in C using libpython.&lt;/p&gt;
&lt;p&gt;As described in the &lt;a href="https://docs.python.org/3/extending/embedding.html#very-high-level-embedding"&gt;Python embedding
guide&lt;/a&gt;
we'll need to include libpython and initialize it in
our &lt;code&gt;main.c&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#define PY_SSIZE_T_CLEAN
#include &amp;lt;Python.h&amp;gt;

int main(int argc, char *argv[]) {
  Py_Initialize();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To compile against libpython, we'll use
&lt;a href="https://helpmanual.io/man1/python3-config/"&gt;python3-config&lt;/a&gt; installed
as part of &lt;code&gt;python3-devel&lt;/code&gt; to tell us what should be linked
at each step during compilation.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ gcc -c -o main.o $(python3-config --cflags) main.c
$ gcc $(python3-config --ldflags) main.o
$ ./a.out; echo $?
0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool! Now as we think about translating the fibonacci implementation,
we want to keep everything as Python objects for as long as
possible. This means passing and receiving
&lt;a href="https://docs.python.org/3/c-api/object.html"&gt;PyObject*&lt;/a&gt; to and from
all functions, and converting all C integers to
&lt;a href="https://docs.python.org/3/c-api/long.html"&gt;PyLong*&lt;/a&gt;, a "subtype" of
&lt;code&gt;PyObject*&lt;/code&gt;. You can imagine that everything in Python is
an &lt;code&gt;object&lt;/code&gt; until you operate on it.&lt;/p&gt;
&lt;p class="note"&gt;
  For more information on objects in Python, check out
  the &lt;a href="https://docs.python.org/3/reference/datamodel.html"&gt;Data
  model&lt;/a&gt; page in Python docs.
&lt;/p&gt;&lt;p&gt;To map a C integer to a &lt;code&gt;PyLong*&lt;/code&gt; we use
&lt;a href="https://docs.python.org/3/c-api/long.html#c.PyLong_FromLong"&gt;PyLong_FromLong&lt;/a&gt;. To
map in reverse, we use
&lt;a href="https://docs.python.org/3/c-api/long.html#c.PyLong_AsLong"&gt;PyLong_AsLong&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To compare two &lt;code&gt;PyObject*&lt;/code&gt;s we can use
&lt;a href="https://docs.python.org/3/c-api/object.html#c.PyObject_RichCompareBool"&gt;PyObject_RichCompareBool&lt;/a&gt;
which will handle the comparison regardless of the type of the two
parameters. Without this helper we'd have to write complex checks to
make sure that the two sides are the same and if they are, unwrap them
into their underlying C value and compare the C value.&lt;/p&gt;
&lt;p&gt;We can use
&lt;a href="https://docs.python.org/3/c-api/number.html#c.PyNumber_Add"&gt;PyNumber_Add&lt;/a&gt;
and
&lt;a href="https://docs.python.org/3/c-api/number.html#c.PyNumber_Subtract"&gt;PyNumber_Subtract&lt;/a&gt;
for basic arithmetic, and there are many similar helpers available to
us for operations down the line.&lt;/p&gt;
&lt;p&gt;Now we can write a translation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#define PY_SSIZE_T_CLEAN
#include &amp;lt;Python.h&amp;gt;

PyObject* fib(PyObject* n) {
  PyObject* zero = PyLong_FromLong(0);
  PyObject* one = PyLong_FromLong(1);
  if (PyObject_RichCompareBool(n, zero, Py_EQ) || PyObject_RichCompareBool(n, one, Py_EQ)) {
    return n;
  }

  PyObject* left = fib(PyNumber_Subtract(n, one));

  PyObject* two = PyLong_FromLong(2);
  PyObject* right = fib(PyNumber_Subtract(n, two));

  return PyNumber_Add(left, right);
}

int main(int argc, char *argv[]) {
  Py_Initialize();

  PyObject* res = fib(PyLong_FromLong(7)); // Should be 13

  return PyLong_AsLong(res);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile and run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ gcc -c -o main.o $(python3-config --cflags) main.c
$ gcc $(python3-config --ldflags) main.o
$ ./a.out; echo $?
13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's great! But we cheated in one place. We assumed that the input
to the &lt;code&gt;fib&lt;/code&gt; function was an integer, and we propagated
that assumption everywhere we wrote &lt;code&gt;PyNumber_*&lt;/code&gt;
operations. When we write the compiler, we'll need to check that both
arguments are an integer before we call a numeric helper, otherwise we
may need to call a string concatenation helper or something else
entirely.&lt;/p&gt;
&lt;h3 id="compiler-architecture"&gt;Compiler Architecture&lt;/h3&gt;&lt;p&gt;We'll break the code into four major parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;libpyc.c&lt;/code&gt;: helper functions for generated code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyc/context.py&lt;/code&gt;: utilities for scope and writing code in memory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyc/codegen.py&lt;/code&gt;: for generating C code from a Python AST&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pyc/__main__.py&lt;/code&gt;: the entrypoint&lt;/li&gt;
&lt;/ol&gt;
&lt;p class="note"&gt;
  When I'm writing a new compiler using an existing parser I almost
  always start with the entrypoint and code generator so I can explore
  the AST. However, it's easiest to explain the code if we start with
  the utilities first.
&lt;/p&gt;&lt;p&gt;We'll also want an empty &lt;code&gt;pyc/__init__.py&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="libpyc.c"&gt;libpyc.c&lt;/h3&gt;&lt;p&gt;This C file will contain three helper functions for safely adding,
subtracting, and printing. It will be concatenated to the top of the
generated C file. We'll only support integers for now but this
structure sets us up for supporting more types later on.&lt;/p&gt;
&lt;p&gt;We'll use
&lt;a href="https://docs.python.org/3/c-api/long.html#c.PyLong_Check"&gt;PyLong_Check&lt;/a&gt;
before calling number-specific methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#define PY_SSIZE_T_CLEAN
#include &amp;lt;Python.h&amp;gt;

inline PyObject* PYC_Add(PyObject* l, PyObject* r) {
  // TODO: allow __add__ override

  // Includes ints and bools
  if (PyLong_Check(l) &amp;amp;&amp;amp; PyLong_Check(r)) {
    return PyNumber_Add(l, r);
  }

  // TODO: handle str, etc.

  // TODO: throw exception
  return NULL;
}

inline PyObject* PYC_Sub(PyObject* l, PyObject* r) {
  // TODO: allow __add__ override

  // Includes ints and bools
  if (PyLong_Check(l) &amp;amp;&amp;amp; PyLong_Check(r)) {
    return PyNumber_Subtract(l, r);
  }

  // TODO: handle str, etc.

  // TODO: throw exception
  return NULL;
}

inline PyObject* PYC_Print(PyObject* o) {
  PyObject_Print(o, stdout, Py_PRINT_RAW);
  printf(&amp;quot;\n&amp;quot;);
  return Py_None;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it! We could generate these as strings in Python but it gets
hairy to do so. By using a dedicated C file, we can take advantage of
syntax highlighting since this file is only C code. And since we've
marked all functions as &lt;code&gt;inline&lt;/code&gt;, there's no runtime cost
to using not embedding these as strings in Python.&lt;/p&gt;
&lt;h3 id="pyc/context.py"&gt;pyc/context.py&lt;/h3&gt;&lt;p&gt;This file will contain a &lt;code&gt;Context&lt;/code&gt; class for managing
identifiers in scope and for proxying to a &lt;code&gt;Writer&lt;/code&gt; class
that contains helpers for writing lines of C code.&lt;/p&gt;
&lt;p&gt;We'll have two instances of the &lt;code&gt;Writer&lt;/code&gt; class in
&lt;code&gt;Context&lt;/code&gt; so that we can write to a body (or
current/primary) region and an initialization region.&lt;/p&gt;
&lt;p&gt;The initialization region is necessary in case there are any variables
declared at the top-level. We can't initialize these variables in C
outside of a function since every &lt;code&gt;PyObject*&lt;/code&gt; must be
created after calling &lt;code&gt;Py_Initialize&lt;/code&gt;. This section will be
written into our C &lt;code&gt;main&lt;/code&gt; function before we enter a
compiled Python &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;import copy


class Writer():
    content = &amp;quot;&amp;quot;

    def write(self, exp: str, indent: int = 0):
        self.content += (&amp;quot;  &amp;quot; * indent) + exp

    def writeln(self, stmt: str, indent: int = 0):
        self.write(stmt + &amp;quot;\n&amp;quot;, indent)

    def write_statement(self, stmt: str, indent: int = 0):
        self.writeln(stmt + &amp;quot;;&amp;quot;, indent)


class Context():
    initializations = Writer()
    body = Writer()
    indentation = 0

    scope = 0
    ret = None
    namings = {}
    counter = -1

    def __getattr__(self, name: str) -&amp;gt; object:
        # Helpers to avoid passing in self.indentation every time
        outputs = [initializations&amp;quot;, &amp;quot;body&amp;quot;]
        for output in outputs:
            if name.startswith(output):
                return lambda s, i=None: getattr(getattr(self, output), name[len(output)+1:])(s, i if i is not None else self.indentation)

        return object.__getattr__(self, name)

    def get_local(self, source_name: str) -&amp;gt; dict:
        return self.namings[source_name]

    def register_global(self, name: str, loc: str):
        self.namings[name] = {
            &amp;quot;name&amp;quot;: loc,
            &amp;quot;scope&amp;quot;: 0,
        }

    def register_local(self, local: str = &amp;quot;tmp&amp;quot;) -&amp;gt; str:
        self.counter += 1
        self.namings[local] = {
            &amp;quot;name&amp;quot;: f&amp;quot;{local}_{self.counter}&amp;quot;,
            # naming dictionary is copied, so we need to capture scope
            # at declaration
            &amp;quot;scope&amp;quot;: self.scope,
        }
        return self.namings[local][&amp;quot;name&amp;quot;]

    def copy(self):
        new = copy.copy(self)
        # For some reason copy.deepcopy doesn&amp;#39;t do this
        new.namings = dict(new.namings)
        return new

    def at_toplevel(self):
        return self.scope == 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is all pretty boring boilerplate. Let's move on.&lt;/p&gt;
&lt;h3 id="pyc/&lt;strong&gt;main&lt;/strong&gt;.py"&gt;pyc/&lt;strong&gt;main&lt;/strong&gt;.py&lt;/h3&gt;&lt;p&gt;The entrypoint is responsible for reading source code, parsing it,
calling the code generator, writing the source code to a C file, and
compiling it.&lt;/p&gt;
&lt;p&gt;First, we read and parse the source code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;import ast
import os
import subprocess
import shutil
import sys

from context import Context
from codegen import generate

BUILTINS = {
    &amp;quot;print&amp;quot;: &amp;quot;PYC_Print&amp;quot;,
}


def main():
    target = sys.argv[1]
    with open(target) as f:
        source = f.read()
    tree = ast.parse(source, target)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we write &lt;code&gt;libpyc.c&lt;/code&gt; into the body, register builtins,
and run code generation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;
...

def main()
    ...

    ctx = Context()
    with open(&amp;quot;libpyc.c&amp;quot;) as f:
        ctx.body_write(f.read() + &amp;quot;\n&amp;quot;)

    for builtin, fn in BUILTINS.items():
        ctx.register_global(builtin, fn)

    generate(ctx, tree)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we create a clean output directory and write
&lt;code&gt;main.c&lt;/code&gt; with the generated code and a &lt;code&gt;main&lt;/code&gt;
function to initialization Python and any global variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;...

def main():
   ...

    # Create and move to working directory
    outdir = &amp;quot;bin&amp;quot;
    shutil.rmtree(outdir, ignore_errors=True)
    os.mkdir(outdir)
    os.chdir(outdir)

    with open(&amp;quot;main.c&amp;quot;, &amp;quot;w&amp;quot;) as f:
        f.write(ctx.body.content)

        main = ctx.namings.get(&amp;quot;main&amp;quot;)[&amp;quot;name&amp;quot;]
        f.write(f&amp;quot;&amp;quot;&amp;quot;int main(int argc, char *argv[]) {{
  Py_Initialize();

  // Initialize globals, if any.
{ctx.initializations.content}
  PyObject* r = {main}();
  return PyLong_AsLong(r);
}}&amp;quot;&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we run &lt;code&gt;clang-format&lt;/code&gt; and &lt;code&gt;gcc&lt;/code&gt; against
the generated C code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;...

def main():
    ...

    subprocess.run([&amp;quot;clang-format&amp;quot;, &amp;quot;-i&amp;quot;, &amp;quot;main.c&amp;quot;])

    cflags_raw = subprocess.check_output([&amp;quot;python3-config&amp;quot;, &amp;quot;--cflags&amp;quot;])
    cflags = [f.strip() for f in cflags_raw.decode().split(&amp;quot; &amp;quot;) if f.strip()]
    cmd = [&amp;quot;gcc&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;main.o&amp;quot;] + cflags + [&amp;quot;main.c&amp;quot;]
    subprocess.run(cmd)

    ldflags_raw = subprocess.check_output([&amp;quot;python3-config&amp;quot;, &amp;quot;--ldflags&amp;quot;])
    ldflags = [f.strip() for f in ldflags_raw.decode().split(&amp;quot; &amp;quot;) if f.strip()]
    cmd = [&amp;quot;gcc&amp;quot;] + ldflags + [&amp;quot;main.o&amp;quot;]
    subprocess.run(cmd)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All together:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;import ast
import os
import subprocess
import shutil
import sys

from context import Context
from codegen import generate

BUILTINS = {
    &amp;quot;print&amp;quot;: &amp;quot;PYC_Print&amp;quot;,
}


def main():
    target = sys.argv[1]
    with open(target) as f:
        source = f.read()
    tree = ast.parse(source, target)

    ctx = Context()
    with open(&amp;quot;libpyc.c&amp;quot;) as f:
        ctx.body_write(f.read() + &amp;quot;\n&amp;quot;)

    for builtin, fn in BUILTINS.items():
        ctx.register_global(builtin, fn)

    generate(ctx, tree)

    # Create and move to working directory
    outdir = &amp;quot;bin&amp;quot;
    shutil.rmtree(outdir, ignore_errors=True)
    os.mkdir(outdir)
    os.chdir(outdir)

    with open(&amp;quot;main.c&amp;quot;, &amp;quot;w&amp;quot;) as f:
        f.write(ctx.body.content)

        main = ctx.namings.get(&amp;quot;main&amp;quot;)[&amp;quot;name&amp;quot;]
        f.write(f&amp;quot;&amp;quot;&amp;quot;int main(int argc, char *argv[]) {{
  Py_Initialize();

  // Initialize globals, if any.
{ctx.initializations.content}
  PyObject* r = {main}();
  return PyLong_AsLong(r);
}}&amp;quot;&amp;quot;&amp;quot;)

    subprocess.run([&amp;quot;clang-format&amp;quot;, &amp;quot;-i&amp;quot;, &amp;quot;main.c&amp;quot;])

    cflags_raw = subprocess.check_output([&amp;quot;python3-config&amp;quot;, &amp;quot;--cflags&amp;quot;])
    cflags = [f.strip() for f in cflags_raw.decode().split(&amp;quot; &amp;quot;) if f.strip()]
    cmd = [&amp;quot;gcc&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;-o&amp;quot;, &amp;quot;main.o&amp;quot;] + cflags + [&amp;quot;main.c&amp;quot;]
    subprocess.run(cmd)

    ldflags_raw = subprocess.check_output([&amp;quot;python3-config&amp;quot;, &amp;quot;--ldflags&amp;quot;])
    ldflags = [f.strip() for f in ldflags_raw.decode().split(&amp;quot; &amp;quot;) if f.strip()]
    cmd = [&amp;quot;gcc&amp;quot;] + ldflags + [&amp;quot;main.o&amp;quot;]
    subprocess.run(cmd)


main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Done!&lt;/p&gt;
&lt;h3 id="pyc/codegen.py"&gt;pyc/codegen.py&lt;/h3&gt;&lt;p&gt;Lastly we write the translation layer from Python AST to C. We'll
break this out into 10 helper functions. It is helpful to have the
&lt;a href="https://docs.python.org/3/library/ast.html#abstract-grammar"&gt;AST
spec&lt;/a&gt; for
reference.&lt;/p&gt;
&lt;h4 id="1/10:-generate"&gt;1/10: generate&lt;/h4&gt;&lt;p&gt;The entrypoint of the code generator is &lt;code&gt;generate(ctx: Context,
exp)&lt;/code&gt;. It generates code for any object with a &lt;code&gt;body&lt;/code&gt;
attribute storing a list of statements. This function will generate
code for objects like modules, function bodies, if bodies, etc.&lt;/p&gt;
&lt;p&gt;The statements we'll support to begin are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ast.Assign&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.FunctionDef&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.Return&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.If&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;ast.Expr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For each statement, we'll simply pass on generation to an associated
helper function. In the case of expression generation though, we'll
also add a noop operation on the result of the expression otherwise
the compiler will complain about an unused variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate(ctx: Context, module):
    for stmt in module.body:
        if isinstance(stmt, ast.Assign):
            generate_assign(ctx, stmt)
        elif isinstance(stmt, ast.FunctionDef):
            generate_function_def(ctx, stmt)
        elif isinstance(stmt, ast.Return):
            generate_return(ctx, stmt)
        elif isinstance(stmt, ast.If):
            generate_if(ctx, stmt)
        elif isinstance(stmt, ast.Expr):
            r = generate_expression(ctx, stmt.value)
            ctx.body_writeln(&amp;quot;// noop to hide unused warning&amp;quot;)
            ctx.body_write_statement(f&amp;quot;{r} += 0&amp;quot;)
        else:
            raise Exception(f&amp;quot;Unsupported statement type: {type(stmt)}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  Remember to throw exceptions aggressively otherwise you'll have a
  bad time debugging programs using new syntax.
&lt;/p&gt;&lt;p&gt;Let's dig into these helpers.&lt;/p&gt;
&lt;h4 id="2/10:-generate_assign"&gt;2/10: generate_assign&lt;/h4&gt;&lt;p&gt;To generate assignment code, we need to check if we're at the
top-level or not. If we're at the top-level we can declare the
variable but we can't initialize it yet. So we add the initialization
code to the &lt;code&gt;initialization&lt;/code&gt; section of the program.&lt;/p&gt;
&lt;p&gt;If we're not at the top-level, we can declare and assign in one
statement.&lt;/p&gt;
&lt;p&gt;Before doing either though, we register the variable name so we can
get a safe local name to use in generated code. Then we compile the
right-hand side so we can assign it to the left-hand side.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;import ast

from context import Context


def initialize_variable(ctx: Context, name: str, val: str):
    if ctx.at_toplevel():
        decl = f&amp;quot;PyObject* {name}&amp;quot;
        ctx.body_write_statement(decl, 0)

        init = f&amp;quot;{name} = {val}&amp;quot;
        ctx.initializations_write_statement(init)
    else:
        ctx.body_write_statement(f&amp;quot;PyObject* {name} = {val}&amp;quot;)


def generate_assign(ctx: Context, stmt: ast.Assign):
    # TODO: support assigning to a tuple
    local = ctx.register_local(stmt.targets[0].id)
    val = generate_expression(ctx, stmt.value)
    initialize_variable(ctx, local, val)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're going to need to implement &lt;code&gt;generate_expression&lt;/code&gt; to
make this work.&lt;/p&gt;
&lt;h4 id="3/10:-generate_expression"&gt;3/10: generate_expression&lt;/h4&gt;&lt;p&gt;Just like for statements in &lt;code&gt;generate&lt;/code&gt;, there are a few
kinds of expressions we need to implement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ast.Num&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.BinOp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.BoolOp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.Name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ast.Compare&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;ast.Call&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For &lt;code&gt;ast.Num&lt;/code&gt;, we just need to wrap the literal number as a
&lt;code&gt;PyLong*&lt;/code&gt;. And for &lt;code&gt;ast.Name&lt;/code&gt; we just need to
look up the local name in context. Otherwise we delegate to more
helper functions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_expression(ctx: Context, exp) -&amp;gt; str:
    if isinstance(exp, ast.Num):
        # TODO: deal with non-integers
        tmp = ctx.register_local(&amp;quot;num&amp;quot;)
        initialize_variable(ctx, tmp, f&amp;quot;PyLong_FromLong({exp.n})&amp;quot;)
        return tmp
    elif isinstance(exp, ast.BinOp):
        return generate_bin_op(ctx, exp)
    elif isinstance(exp, ast.BoolOp):
        return generate_bool_op(ctx, exp)
    elif isinstance(exp, ast.Name):
        return ctx.get_local(exp.id)[&amp;quot;name&amp;quot;]
    elif isinstance(exp, ast.Compare):
        return generate_compare(ctx, exp)
    elif isinstance(exp, ast.Call):
        return generate_call(ctx, exp)

    raise Exception(f&amp;quot;Unsupported expression: {type(exp)}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For every code generation helper that is an expression, we store the
expression in a local variable and return the variable's name so that
parent nodes in the AST can refer to the child. This can result in
inefficient code generation (useless assignment) but that's not really
a big deal for a project like this and will likely be optimized away
by GCC anyway. The more annoying aspect is that useless assignment
just makes the generated code harder to read.&lt;/p&gt;
&lt;h4 id="4/10:-generate_bin_op"&gt;4/10: generate_bin_op&lt;/h4&gt;&lt;p&gt;For binary operators we need to support addition and
subtraction. Other binary operators like equality or and/or are
represented in &lt;code&gt;ast.Compare&lt;/code&gt; and &lt;code&gt;ast.BoolOp&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This is easy to write because we already prepared helpers in
&lt;code&gt;libpyc.c&lt;/code&gt;: &lt;code&gt;PYC_Sub&lt;/code&gt; and &lt;code&gt;PYC_Add&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_bin_op(ctx: Context, binop: ast.BinOp) -&amp;gt; str:
    result = ctx.register_local(&amp;quot;binop&amp;quot;)

    l = generate_expression(ctx, binop.left)
    r = generate_expression(ctx, binop.right)

    if isinstance(binop.op, ast.Add):
        ctx.body_write_statement(f&amp;quot;PyObject* {result} = PYC_Add({l}, {r})&amp;quot;)
    elif isinstance(binop.op, ast.Sub):
        ctx.body_write_statement(f&amp;quot;PyObject* {result} = PYC_Sub({l}, {r})&amp;quot;)
    else:
        raise Exception(f&amp;quot;Unsupported binary operator: {type(binop.op)}&amp;quot;)

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Easy enough.&lt;/p&gt;
&lt;h4 id="5/10:-generate_bool_op"&gt;5/10: generate_bool_op&lt;/h4&gt;&lt;p&gt;We only need to support &lt;code&gt;or&lt;/code&gt; for the fibonacci program, but
&lt;code&gt;or&lt;/code&gt; in Python is more complicated than in C. In Python,
the first value to be truthy short-circuits the expression and the
result is its value, not &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We'll use &lt;code&gt;goto&lt;/code&gt; to short-circuit and we'll use
&lt;a href="https://docs.python.org/3/c-api/object.html#c.PyObject_IsTrue"&gt;PyObject_IsTrue&lt;/a&gt;
to do the truthy check:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_bool_op(ctx: Context, boolop: ast.BoolOp) -&amp;gt; str:
    result = ctx.register_local(&amp;quot;boolop&amp;quot;)
    ctx.body_write_statement(f&amp;quot;PyObject* {result}&amp;quot;)

    if isinstance(boolop.op, ast.Or):
        done_or = ctx.register_local(&amp;quot;done_or&amp;quot;)

        for exp in boolop.values:
            v = generate_expression(ctx, exp)
            ctx.body_write_statement(f&amp;quot;{result} = {v}&amp;quot;)
            ctx.body_writeln(f&amp;quot;if (PyObject_IsTrue({v})) {{&amp;quot;)
            ctx.body_write_statement(f&amp;quot;goto {done_or}&amp;quot;, ctx.indentation+1)
            ctx.body_writeln(&amp;quot;}&amp;quot;)

        ctx.body_writeln(f&amp;quot;{done_or}:\n&amp;quot;, 0)

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  Now that I write this down I see we could probably move this
  function into &lt;code&gt;libpyc.c&lt;/code&gt; if we used a loop. Maybe in
  the next iteration.
&lt;/p&gt;&lt;p&gt;We move on.&lt;/p&gt;
&lt;h4 id="6/10:-generate_compare"&gt;6/10: generate_compare&lt;/h4&gt;&lt;p&gt;This function handles equality and inequality checks. We'll adapt the
&lt;code&gt;PyObject_RichCompareBool&lt;/code&gt; helper we used in the
hand-written translation.&lt;/p&gt;
&lt;p&gt;The only additional thing to keep in mind is that the right-hand side
is passed as an array. So we have to iterate through it and apply the
equality/inequality check on all objects in the list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_compare(ctx: Context, exp: ast.Compare) -&amp;gt; str:
    result = ctx.register_local(&amp;quot;compare&amp;quot;)
    left = generate_expression(ctx, exp.left)
    ctx.body_write_statement(f&amp;quot;PyObject* {result} = {left}&amp;quot;)

    for i, op in enumerate(exp.ops):
        v = generate_expression(ctx, exp.comparators[i])

        if isinstance(op, ast.Eq):
            ctx.body_write_statement(f&amp;quot;{result} = PyObject_RichCompare({result}, {v}, Py_EQ)&amp;quot;)
        elif isinstance(op, ast.NotEq):
            ctx.body_write_statement(f&amp;quot;{result} = PyObject_RichCompare({result}, {v}, Py_NE)&amp;quot;)
        else:
            raise Exception(f&amp;quot;Unsupported comparison: {type(op)}&amp;quot;)

    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="7/10:-generate_call"&gt;7/10: generate_call&lt;/h4&gt;&lt;p&gt;The last expression is simple enough. We compile the call's arguments
first, then the function itself, then we call the function with the
arguments like any C function. Calling the C function directly will
have ramifications for interacting with Python libraries (basically,
we won't be able to interact with any) but it's the easiest way to get
started.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_call(ctx: Context, exp: ast.Call) -&amp;gt; str:
    args = &amp;#39;, &amp;#39;.join([generate_expression(ctx, a) for a in exp.args])
    fun = generate_expression(ctx, exp.func)
    res = ctx.register_local(&amp;quot;call_result&amp;quot;)

    # TODO: lambdas and closures need additional work
    ctx.body_write_statement(
        f&amp;quot;PyObject* {res} = {fun}({args})&amp;quot;)
    return res
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for expressions! Just a few more statement helpers to
support.&lt;/p&gt;
&lt;h4 id="8/10:-generate_function_def"&gt;8/10: generate_function_def&lt;/h4&gt;&lt;p&gt;This is a fun one. First we register the function name in scope. Then
we copy the context so variables within the function body are
contained within the function body. We increment &lt;code&gt;scope&lt;/code&gt; so
we know we've left the top-level. Finally, we compile the body.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_function_def(ctx: Context, fd: ast.FunctionDef):
    name = ctx.register_local(fd.name)

    childCtx = ctx.copy()
    args = &amp;quot;, &amp;quot;.join([f&amp;quot;PyObject* {childCtx.register_local(a.arg)}&amp;quot; for a in fd.args.args])
    ctx.body_writeln(f&amp;quot;PyObject* {name}({args}) {{&amp;quot;, 0)

    childCtx.scope += 1
    childCtx.indentation += 1
    generate(childCtx, fd)

    if not childCtx.ret:
        childCtx.body_write_statement(&amp;quot;return Py_None&amp;quot;)

    ctx.body_writeln(&amp;quot;}\n&amp;quot;, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The check for &lt;code&gt;childCtx.ret&lt;/code&gt; isn't strictly necessary
because we could just emit a return even if there already was
one. Asking &lt;code&gt;generate_return&lt;/code&gt; to set this attribute and
having &lt;code&gt;generate_function_def&lt;/code&gt; check it just makes the
generate code a little prettier.&lt;/p&gt;
&lt;h4 id="9/10:-generate_return"&gt;9/10: generate_return&lt;/h4&gt;&lt;p&gt;Very straightforward, we just compile the value to be returned and
then we emit a &lt;code&gt;return&lt;/code&gt; statement.&lt;/p&gt;
&lt;p&gt;We store the return value so that the function definition can know
whether to add a &lt;code&gt;return PyNone&lt;/code&gt; statement.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_return(ctx: Context, r: ast.Return):
    ctx.ret = generate_expression(ctx, r.value)
    ctx.body_writeln(&amp;quot;&amp;quot;)
    ctx.body_write_statement(f&amp;quot;return {ctx.ret}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we've got one last statement to support!&lt;/p&gt;
&lt;h4 id="10/10:-generate_if"&gt;10/10: generate_if&lt;/h4&gt;&lt;p&gt;You know the deal: compile the test and if the test is truthy, enter
the compiled body. We'll deal with the else body another time.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def generate_if(ctx: Context, exp: ast.If):
    test = generate_expression(ctx, exp.test)
    ctx.body_writeln(f&amp;quot;if (PyObject_IsTrue({test})) {{&amp;quot;)
    ctx.indentation += 1
    generate(ctx, exp)
    # TODO: handle exp.orelse
    ctx.indentation -= 1
    ctx.body_writeln(&amp;quot;}\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're done the compiler!&lt;/p&gt;
&lt;h3 id="trying-it-out"&gt;Trying it out&lt;/h3&gt;&lt;p&gt;As promised:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat tests/recursive_fib.py
def fib(n):
    if n == 0 or n == 1:
        return n

    return fib(n - 1) + fib(n - 2)


def main():
    print(fib(40))
$ python3 pyc tests/recursive_fib.py
$ ./bin/a.out
102334155
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="microbenchmarking,-or-making-compiler-twitter-unhappy"&gt;Microbenchmarking, or making compiler Twitter unhappy&lt;/h4&gt;&lt;p&gt;Keep in mind this implementation does a small fraction of what CPython
is doing.&lt;/p&gt;
&lt;p&gt;If you time the generated code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ python3 pyc tests/recursive_fib.py
$ time ./bin/a.out
102334155
./bin/a.out  18.69s user 0.03s system 99% cpu 18.854 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And CPython (with &lt;code&gt;main()&lt;/code&gt; append to the source):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;time python3 tests/recursive_fib.py
102334155
python3 tests/recursive_fib.py  76.24s user 0.11s system 99% cpu 1:16.81 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only reason I mention this is because when I did a &lt;a href="/compiling-dynamic-programming-languages.html#next-steps-with-jsc"&gt;similar
compiler project for JavaScript targeting
C++/libV8&lt;/a&gt;,
the generated code was about the same or a little slower in speed.&lt;/p&gt;
&lt;p&gt;I haven't gotten &lt;em&gt;that much&lt;/em&gt; better at writing these compilers.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post up, on writing a simple Python to C compiler (in Python).&lt;a href="https://t.co/4kkji0XXbp"&gt;https://t.co/4kkji0XXbp&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1295134027335204865?ref_src=twsrc%5Etfw"&gt;August 16, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-a-simple-python-compiler.html</guid><pubDate>Sun, 16 Aug 2020 00:00:00 +0000</pubDate></item><item><title>A single-node Kubernetes cluster without virtualization or a container registry</title><link>http://notes.eatonphil.com/a-single-node-kubernetes-cluster-without-virtualization-or-a-container-registry.html</link><description>&lt;p&gt;This post is a recipe for setting up a minimal Kubernetes cluster on
Fedora without requiring virtualization or a container registry. These
two features make the system cloud-agnostic and the cluster entirely
self-contained. The post will end with us running a simple Flask app
from a local container.&lt;/p&gt;
&lt;p&gt;This setup is primarily useful for simple CI environments or
application development on Linux. (Docker Desktop has better tooling
for development on Mac or Windows.)&lt;/p&gt;
&lt;h3 id="getting-kubernetes"&gt;Getting Kubernetes&lt;/h3&gt;&lt;p&gt;The core of this effort is &lt;a href="https://k3s.io/"&gt;K3s&lt;/a&gt;, a Kubernetes
distribution that allows us to run on a single node without
virtualization.&lt;/p&gt;
&lt;p&gt;But first off, &lt;a href="https://docs.docker.com/engine/install/fedora/"&gt;install Docker&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Then install K3s:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl -sfL https://get.k3s.io | sh -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It may prompt you to adjust some SELinux policies like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo dnf install -y container-selinux selinux-policy-base
$ sudo rpm -i https://rpm.rancher.io/k3s-selinux-0.1.1-rc1.el7.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Swap these out with whatever it prompts and retry the K3s install.&lt;/p&gt;
&lt;p&gt;Finally, &lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/"&gt;install
kubectl&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now copy the global K3s kubeconfig into &lt;code&gt;~/.kube/config&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo cp /etc/rancher/k3s/k3s.yaml ~/.kube/config
$ sudo chown $USER:$GROUP ~/.kube/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And enable K3s:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo systemctl enable k3s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you're on Fedora 31+ you'll need to disable cgroups v2 and reboot:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo grubby --args=&amp;quot;systemd.unified_cgroup_hierarchy=0&amp;quot; --update-kernel=ALL
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, you can run &lt;code&gt;kubectl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ kubectl get pods
No resources found in default namespace.
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="a-simple-application"&gt;A simple application&lt;/h3&gt;&lt;p&gt;We'll create a small Flask app, containerize it, and write a
Kubernetes deployment and service config for it.&lt;/p&gt;
&lt;p&gt;We begin with &lt;code&gt;app.py&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;from flask import Flask

app = Flask(__name__)


@app.route(&amp;#39;/&amp;#39;)
def index():
    return &amp;#39;Hello World, Flask!&amp;#39;


if __name__ == &amp;#39;__main__&amp;#39;:
    app.run(debug=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then a &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs dockerfile"&gt;FROM python:3-slim

RUN pip install flask
COPY . /app

CMD python3 /app/app.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the deployment in &lt;code&gt;manifest.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: helloworld
spec:
  selector:
    matchLabels:
      name: helloworld
  template:
    metadata:
      labels:
        name: helloworld
    spec:
      containers:
        - image: helloworld
          name: helloworld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="running-in-kubernetes"&gt;Running in Kubernetes&lt;/h3&gt;&lt;p&gt;First we build, save, and import the image into &lt;code&gt;k3s&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker build . -t helloworld
$ docker save helloworld &amp;gt; helloworld.tar
$ sudo k3s ctr image import helloworld.tar
$ kubectl apply -f ./manifest.yaml
$ kubectl port-forward $(kubectl get pods | grep helloworld | cut -d ' ' -f 1) 5000 &amp;gt; log 2&amp;gt;&amp;amp;1 &amp;amp;
$ curl localhost:5000
Hello World, Flask
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post is a recipe for creating a self-contained, single-node Kubernetes cluster for CI environments using a basic Flask app.&lt;a href="https://t.co/fegAZFEQzO"&gt;https://t.co/fegAZFEQzO&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1287163839306444800?ref_src=twsrc%5Etfw"&gt;July 25, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/a-single-node-kubernetes-cluster-without-virtualization-or-a-container-registry.html</guid><pubDate>Sat, 25 Jul 2020 00:00:00 +0000</pubDate></item><item><title>Generating a full-stack application from a database</title><link>http://notes.eatonphil.com/generating-a-full-stack-application-from-a-database.html</link><description>&lt;p&gt;&lt;a href="https://dbcore.org"&gt;DBCore&lt;/a&gt; can now generate a TypeScript/React CRUD
UI that is automatically hooked up to the generated REST API (in Go).&lt;/p&gt;
&lt;p&gt;The UI has full support for login, viewing (and filtering), editing,
and creating database entities.&lt;/p&gt;
&lt;p&gt;PostgreSQL, SQLite and MySQL are supported.&lt;/p&gt;
&lt;h3 id="how-to-use?"&gt;How to use?&lt;/h3&gt;&lt;p&gt;The goal of this project is primarily to provide as much useful
boilerplate as possible for full-stack applications. The system is
probably not sufficient to be an entire application development
platform. It's currently missing hooks, overrides, and
per-row/per-table authorization.&lt;/p&gt;
&lt;p&gt;The UI code generation may be even less useful in the long-term than
the API because UIs are by necessity very diverse. But it is good not
to need to build the same browser-side API, authentication, and
routing logic again now that it's taken care of in code generation.&lt;/p&gt;
&lt;h3 id="screenshots"&gt;Screenshots&lt;/h3&gt;&lt;p&gt;Here are a few screenshots of the examples/todo application. Every
page here is auto-generated after reading the database schema. The
browser application is hooked up to the similarly auto-generated API.&lt;/p&gt;
&lt;div style="padding-bottom: 15px;"&gt;
  &lt;small&gt;Sign in&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/1ReEEdf.png"/&gt;
&lt;/div&gt;
&lt;div style="padding-bottom: 15px;"&gt;
  &lt;small&gt;Creating a table entity&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/AiryzjX.png"/&gt;
&lt;/div&gt;
&lt;div style="padding-bottom: 15px;"&gt;
  &lt;small&gt;Viewing all table entities&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/l9jI0LA.png"/&gt;
&lt;/div&gt;
&lt;div style="padding-bottom: 15px;"&gt;
  &lt;small&gt;Filtering table entities&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/J21vQDE.png"/&gt;
&lt;/div&gt;
&lt;div style="padding-bottom: 15px;"&gt;
  &lt;small&gt;Viewing an individual table entity&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/T2VhBFt.png"/&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;small&gt;Editing a table entity&lt;/small&gt;
  &lt;img style="border: 1px solid #ddd;" src="https://i.imgur.com/f2sRN1p.png"&gt;
&lt;/div&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;What&amp;#39;s new in DBCore: a TypeScript/React UI generated from your database schema and hooked up to the similarly generated Go REST API.&lt;br&gt;&lt;br&gt;So you can now generate an entire full stack application from your database schema. Screenshots in the post.&lt;a href="https://t.co/BTGRVBsfUR"&gt;https://t.co/BTGRVBsfUR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1272295312900661250?ref_src=twsrc%5Etfw"&gt;June 14, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/generating-a-full-stack-application-from-a-database.html</guid><pubDate>Sun, 14 Jun 2020 00:00:00 +0000</pubDate></item><item><title>Generating a REST API from a database</title><link>http://notes.eatonphil.com/generating-a-rest-api-from-a-database.html</link><description>&lt;p&gt;I recently published an &lt;a href="https://eatonphil.github.io/dbcore/"&gt;alpha version of a code generation tool,
DBCore,&lt;/a&gt; that reads a database
schema from PostgreSQL or MySQL and generates an entire Go API with
CRUD operations, pagination, filtering, and authentication.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://pbs.twimg.com/media/EZJ7TvNXQAEgraD?format=png&amp;name=large" /&gt;&lt;/p&gt;
&lt;p&gt;But more than just generating code like
&lt;a href="https://github.com/xo/xo"&gt;xo/xo&lt;/a&gt; or &lt;a href="https://gnorm.org/"&gt;gnorm&lt;/a&gt;,
DBCore defines a standard REST API that can be implemented in any
language -- and includes a reference implementation in Go. I'm eager
to add Java and Ruby implementations as well. And I'd be more than
happy to accept community contributions.&lt;/p&gt;
&lt;h3 id="boilerplate-&amp;amp;-code-generation"&gt;Boilerplate &amp;amp; code generation&lt;/h3&gt;&lt;p&gt;Web application boilerplate is boring. You should do it once from
scratch (preferably down to the socket layer) and never do it again. I
struggled for the last few years to find the right system to reduce
boilerplate. If I were building a new line-of-business application as
an employee I'd pick one of Rails, ASP.NET, Spring, Django, or
similar.&lt;/p&gt;
&lt;p&gt;I've never worked on one of those frameworks professionally and I've
never been able to force myself to learn any of them in my free
time. But even if I could use one of these, none of them get close to
giving you an entire functioning application with authentication,
pagination, filtering all based on your existing database.&lt;/p&gt;
&lt;p&gt;Over the last few years though I've relied heavily on code generation
for Go projects. Code generation is basically the only way to conserve
type-safe code in Go. But it's similarly
&lt;a href="https://www.jooq.org/doc/3.13/manual/code-generation/"&gt;popular&lt;/a&gt; in
more powerful languages like Java.&lt;/p&gt;
&lt;p&gt;However none of the existing projects give you much flexibility or
provide you with enough templates to be useful.&lt;/p&gt;
&lt;h3 id="dbcore"&gt;DBCore&lt;/h3&gt;&lt;p&gt;DBCore is written in F# and can be distributed as a static
binary on all systems .NET now supports (read: not just Windows!).&lt;/p&gt;
&lt;p&gt;Reading from MySQL or PostgreSQL is supported but I'd like to see that
extended to include SQLite, Oracle, and MS SQL at least.&lt;/p&gt;
&lt;p&gt;As mentioned, currently DBCore only provides a Go REST API
template. That only solves half the problem of building an application
though. And while there are some projects that can generate an admin
CRUD interface for you, I want to see that more tightly integrated
into DBCore. So I'll be introducing a new template for a browser
application as well. For each table in the database it will generate a
page showing paginated entries and allow you to create, update, and
delete.&lt;/p&gt;
&lt;p&gt;Finally, while the tool only currently has a concept of "browser" and
"api" templates, the project should be able to accept any kind of
template and generate any text based on any database schema.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New blog post, background and goals for dbcore&lt;a href="https://t.co/XW9gUCtvr0"&gt;https://t.co/XW9gUCtvr0&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1269467766727327745?ref_src=twsrc%5Etfw"&gt;June 7, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/generating-a-rest-api-from-a-database.html</guid><pubDate>Sat, 06 Jun 2020 00:00:00 +0000</pubDate></item><item><title>RFCs and asynchronous-first culture</title><link>http://notes.eatonphil.com/rfcs-and-asynchronous-first-culture.html</link><description>&lt;p&gt;I hated writing documentation before working on features. But after a
while I realized I couldn't communicate well enough, even with folks I
had a good connection with. It took me a number of mistaken deliveries
to get the message.&lt;/p&gt;
&lt;h3 id="sketches-and-mockups"&gt;Sketches and mockups&lt;/h3&gt;&lt;p&gt;Designers solve this by producing low-fidelity sketches early on in
the process, iterating on feedback to produce a high-fidelity
mockup. I solve this by producing short RFC (request for comment)
documents. This isn't an original idea, but I see it so rarely I
wanted to share.&lt;/p&gt;
&lt;p&gt;Now as soon as I begin thinking about a technical or organizational
change, I write an RFC. My RFCs are typically a page or two long and
typically take me 30-60 minutes for a good first draft. I make
clear in the title that it is a proposal or draft. This allows me to
make crazy suggestions without upsetting folks; a draft can be easily
thrown away.&lt;/p&gt;
&lt;h3 id="rfc-process"&gt;RFC process&lt;/h3&gt;&lt;p&gt;My RFCs include three key sections:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;What I think the problem is&lt;/li&gt;
&lt;li&gt;Pros/cons of all the solutions I considered&lt;/li&gt;
&lt;li&gt;Which solution I'm planning to go with if no one responds to the RFC&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After I write the first draft I circulate it among a small group of peers
I respect, my boss, etc. I request feedback at leisure and I check in
every few days with a reminder. If no one responds after a while and
there is little concern, I typically move forward with the proposed
solution.&lt;/p&gt;
&lt;p&gt;In addition to clarifying intent up front, this removes the need to
schedule a meeting to &lt;em&gt;discuss a problem&lt;/em&gt;. Discussion and
decisions can be held asynchronously. I only schedule a meeting if
there is disagreement that is unable to be resolved in writing.&lt;/p&gt;
&lt;p&gt;After incorporating feedback, I either throw away the RFC and move on
or feel reasonably confident about the proposal. I send it out to a
wider group of relevant participants. Final meetings are held as
needed.&lt;/p&gt;
&lt;h3 id="the-other-option"&gt;The other option&lt;/h3&gt;&lt;p&gt;In contrast, synchronous-first and undocumented proposals make some
sense when you've got a small team in the same timezone with a similar
schedule. Otherwise, you repeatedly reschedule meetings to accommodate
everyone. You spend your first few meetings simply coming to
understand and agree on &lt;em&gt;the problem&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Spending 30-60 minutes to draft a proposal is almost always easier. It
makes the decision-making process faster and produces more accurate
results.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Spending 30-60 minutes to draft a technical (or organizational) proposal is almost always easier for discussion and action than just scheduling a meeting. Or &amp;quot;my asynchronous-first manifesto&amp;quot;&lt;a href="https://t.co/gm4SUzBD2W"&gt;https://t.co/gm4SUzBD2W&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1261767623592869896?ref_src=twsrc%5Etfw"&gt;May 16, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/rfcs-and-asynchronous-first-culture.html</guid><pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate></item><item><title>Writing a SQL database from scratch in Go: 4. a database/sql driver</title><link>http://notes.eatonphil.com/database-basics-a-database-sql-driver.html</link><description>&lt;p class="note"&gt;
  Previously in database basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/database-basics.html"&gt;1. SELECT, INSERT, CREATE and a REPL&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-expressions-and-where.html"&gt;2. binary expressions and WHERE filters&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-indexes.html"&gt;3. indexes&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post, we'll extend &lt;a href="https://github.com/eatonphil/gosql"&gt;gosql&lt;/a&gt;
to implement the &lt;code&gt;database/sql&lt;/code&gt; driver interface. This will
allow us to interact with gosql the same way we would interact with
any other database.&lt;/p&gt;
&lt;p&gt;Here is an example familiar program (stored in
&lt;code&gt;cmd/sqlexample/main.go&lt;/code&gt;) we'll be able to run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;database/sql&amp;quot;
    &amp;quot;fmt&amp;quot;

    _ &amp;quot;github.com/eatonphil/gosql&amp;quot;
)

func main() {
    db, err := sql.Open(&amp;quot;postgres&amp;quot;, &amp;quot;&amp;quot;)
    if err != nil {
        panic(err)
    }
    defer db.Close()

    _, err = db.Query(&amp;quot;CREATE TABLE users (name TEXT, age INT);&amp;quot;)
    if err != nil {
        panic(err)
    }

    _, err = db.Query(&amp;quot;INSERT INTO users VALUES (&amp;#39;Terry&amp;#39;, 45);&amp;quot;)
    if err != nil {
        panic(err)
    }

    _, err = db.Query(&amp;quot;INSERT INTO users VALUES (&amp;#39;Anette&amp;#39;, 57);&amp;quot;)
    if err != nil {
        panic(err)
    }

    rows, err := db.Query(&amp;quot;SELECT name, age FROM users;&amp;quot;)
    if err != nil {
        panic(err)
    }

    var name string
    var age uint64
    defer rows.Close()
    for rows.Next() {
        err := rows.Scan(&amp;amp;name, &amp;amp;age)
        if err != nil {
            panic(err)
        }

        fmt.Printf(&amp;quot;Name: %s, Age: %d\n&amp;quot;, name, age)
    }

    if err = rows.Err(); err != nil {
        panic(err)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our gosql driver will use a single instance of the
&lt;code&gt;Backend&lt;/code&gt; for all connections.&lt;/p&gt;
&lt;p&gt;Aside from that, it is a simple matter of wrapping our existing APIs
in structs that implement the &lt;code&gt;database/sql/driver.Driver&lt;/code&gt;
interface.&lt;/p&gt;
&lt;p&gt;This post is largely a discussion of &lt;a href="https://github.com/eatonphil/gosql/commit/0d0aa61a74580a6aef11296741abfba4e1d4ae5c"&gt;this
commit&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="implementing-the-driver"&gt;Implementing the driver&lt;/h3&gt;&lt;p&gt;A driver is registered by calling &lt;code&gt;sql.Register&lt;/code&gt; with a
driver instance.&lt;/p&gt;
&lt;p&gt;We'll add the registration code to an &lt;code&gt;init&lt;/code&gt; function in a
new file, &lt;code&gt;driver.go&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;struct Driver {
    bkd Backend
}

func init() {
    sql.Register(&amp;quot;postgres&amp;quot;, &amp;amp;Driver{NewMemoryBackend()})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;According to the &lt;a href="https://pkg.go.dev/database/sql/driver?tab=doc#Driver"&gt;Driver
interface&lt;/a&gt;, we
need only implement &lt;code&gt;Open&lt;/code&gt; to return an connection instance
that implements the &lt;code&gt;database/sql/driver.Conn&lt;/code&gt; interface.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type Driver struct {
    bkd Backend
}

func (d *Driver) Open(name string) (driver.Conn, error) {
    return &amp;amp;Conn{d.bkd}, nil
}

func init() {
    sql.Register(&amp;quot;postgres&amp;quot;, &amp;amp;Driver{NewMemoryBackend()})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="implementing-the-connection"&gt;Implementing the connection&lt;/h3&gt;&lt;p&gt;According to the &lt;a href="https://pkg.go.dev/database/sql/driver?tab=doc#Conn"&gt;Conn
interface&lt;/a&gt;, we
must implement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Prepare(query string) (driver.Stmt, error)&lt;/code&gt; to handle prepared statements&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Close&lt;/code&gt; to handle cleanup&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;Begin&lt;/code&gt; to start a transaction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The connection can also optionally implement &lt;code&gt;Query&lt;/code&gt; and
&lt;code&gt;Exec&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To simplify things we'll panic on &lt;code&gt;Prepare&lt;/code&gt; and on
&lt;code&gt;Begin&lt;/code&gt; (we don't have transactions yet). There's no
cleanup required so we'll do nothing in &lt;code&gt;Close&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type Conn struct {
    bkd Backend
}

func (dc *Conn) Prepare(query string) (driver.Stmt, error) {
    panic(&amp;quot;Prepare not implemented&amp;quot;)
}

func (dc *Conn) Begin() (driver.Tx, error) {
    panic(&amp;quot;Begin not implemented&amp;quot;)
}

func (dc *Conn) Close() error {
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only method we actually need, &lt;code&gt;Query&lt;/code&gt;, is not required
by the interface. It takes a query string and array of query
parameters, returning an instance implementing
the &lt;code&gt;database/sql/driver.Rows&lt;/code&gt; interface.&lt;/p&gt;
&lt;p&gt;To implement &lt;code&gt;Query&lt;/code&gt;, we basically copy the logic we had in
the &lt;code&gt;cmd/main.go&lt;/code&gt; REPL. The only change is that when we
return results when handling &lt;code&gt;SELECT&lt;/code&gt;, we'll return a
struct that implements the &lt;code&gt;database/sql/driver.Rows&lt;/code&gt;
interface.&lt;/p&gt;
&lt;p class="note"&gt;
  &lt;code&gt;database/sql/driver.Rows&lt;/code&gt; is not the same type as
  &lt;code&gt;database/sql.Rows&lt;/code&gt;, which may sound more
  familiar. &lt;code&gt;database/sql/driver.Rows&lt;/code&gt; is a simpler,
  lower-level interface.
&lt;/p&gt;&lt;p&gt;If we receive parameterized query arguments, we'll ignore them for
now. And if the query involves multiple statements, we'll process only
the first statement.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (dc *Conn) Query(query string, args []driver.Value) (driver.Rows, error) {
    if len(args) &amp;gt; 0 {
        // TODO: support parameterization
        panic(&amp;quot;Parameterization not supported&amp;quot;)
    }

    parser := Parser{}
    ast, err := parser.Parse(query)
    if err != nil {
        return nil, fmt.Errorf(&amp;quot;Error while parsing: %s&amp;quot;, err)
    }

    // NOTE: ignorning all but the first statement
    stmt := ast.Statements[0]
    switch stmt.Kind {
    case CreateIndexKind:
        err = dc.bkd.CreateIndex(stmt.CreateIndexStatement)
        if err != nil {
            return nil, fmt.Errorf(&amp;quot;Error adding index on table: %s&amp;quot;, err)
        }
    case CreateTableKind:
        err = dc.bkd.CreateTable(stmt.CreateTableStatement)
        if err != nil {
            return nil, fmt.Errorf(&amp;quot;Error creating table: %s&amp;quot;, err)
        }
    case DropTableKind:
        err = dc.bkd.DropTable(stmt.DropTableStatement)
        if err != nil {
            return nil, fmt.Errorf(&amp;quot;Error dropping table: %s&amp;quot;, err)
        }
    case InsertKind:
        err = dc.bkd.Insert(stmt.InsertStatement)
        if err != nil {
            return nil, fmt.Errorf(&amp;quot;Error inserting values: %s&amp;quot;, err)
        }
    case SelectKind:
        results, err := dc.bkd.Select(stmt.SelectStatement)
        if err != nil {
            return nil, err
        }

        return &amp;amp;Rows{
            rows:    results.Rows,
            columns: results.Columns,
            index:   0,
        }, nil
    }

    return nil, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="implementing-results"&gt;Implementing results&lt;/h3&gt;&lt;p&gt;According to the &lt;a href="https://pkg.go.dev/database/sql/driver?tab=doc#Rows"&gt;Rows
interface&lt;/a&gt; we
must implement:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Columns() []string&lt;/code&gt; to return an array of columns names&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Next(dest []Value) error&lt;/code&gt; to populate an row array with the next row's worth of cells&lt;/li&gt;
&lt;li&gt;and &lt;code&gt;Close() error&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;Rows&lt;/code&gt; struct will contain the rows and colums as
returned from &lt;code&gt;Backend&lt;/code&gt;, and will also contain an
&lt;code&gt;index&lt;/code&gt; field we can use in &lt;code&gt;Next&lt;/code&gt; to populate
the next row of cells.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type Rows struct {
    columns []ResultColumn
    index   uint64
    rows    [][]Cell
}

func (r *Rows) Columns() []string {}

func (r *Rows) Close() error {}

func (r *Rows) Next(dest []driver.Value) error {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;Columns&lt;/code&gt; we simply need to extract and
return the column names from &lt;code&gt;ResultColumn&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (r *Rows) Columns() []string {
    columns := []string{}
    for _, c := range r.columns {
        columns = append(columns, c.Name)
    }

    return columns
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;Next&lt;/code&gt; we need to iterate over each cell in the current
row and retrieve its Go value, storing it in &lt;code&gt;dest&lt;/code&gt;. The
&lt;code&gt;dest&lt;/code&gt; argument is simply a fixed-length array of
&lt;code&gt;interface{}&lt;/code&gt;, so we'll need no manual conversion.&lt;/p&gt;
&lt;p&gt;Once we've reached the last row, the &lt;code&gt;Next&lt;/code&gt; contract is to
return an &lt;code&gt;io.EOF&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (r *Rows) Next(dest []driver.Value) error {
    if r.index &amp;gt;= uint64(len(r.rows)) {
        return io.EOF
    }

    row := r.rows[r.index]

    for idx, cell := range row {
        typ := r.columns[idx].Type
        switch typ {
        case IntType:
            i := cell.AsInt()
            if i == nil {
                dest[idx] = i
            } else {
                dest[idx] = *i
            }
        case TextType:
            s := cell.AsText()
            if s == nil {
                dest[idx] = s
            } else {
                dest[idx] = *s
            }
        case BoolType:
            b := cell.AsBool()
            if b == nil {
                dest[idx] = b
            } else {
                dest[idx] = b
            }
        }
    }

    r.index++
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally in &lt;code&gt;Close&lt;/code&gt; we'll set &lt;code&gt;index&lt;/code&gt; higher than
the number of rows to force &lt;code&gt;Next&lt;/code&gt; to only ever
return &lt;code&gt;io.EOF&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (r *Rows) Close() error {
    r.index = uint64(len(r.rows))
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's all the changes needed to implement a
&lt;code&gt;database/sql&lt;/code&gt; driver! See
&lt;a href="https://github.com/eatonphil/gosql/commit/0d0aa61a74580a6aef11296741abfba4e1d4ae5c#diff-749da71b40f8ff06fc9e78ce917b0cce"&gt;here&lt;/a&gt;
for &lt;code&gt;driver.go&lt;/code&gt; in full.&lt;/p&gt;
&lt;h3 id="running-the-example"&gt;Running the example&lt;/h3&gt;&lt;p&gt;With the driver in place we can try out the example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build ./cmd/sqlexample/main.go
$ ./main
Name: Terry, Age: 45
Name: Anette, Age: 57
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Next post in the database basics series, implementing a database/sql driver for more seamless interactions in Go.&lt;a href="https://t.co/AUZfUByNGE"&gt;https://t.co/AUZfUByNGE&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1259594720315047942?ref_src=twsrc%5Etfw"&gt;May 10, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/database-basics-a-database-sql-driver.html</guid><pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate></item><item><title>Writing a SQL database from scratch in Go: 3. indexes</title><link>http://notes.eatonphil.com/database-basics-indexes.html</link><description>&lt;p class="note"&gt;
  Previously in database basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/database-basics.html"&gt;1. SELECT, INSERT, CREATE and a REPL&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-expressions-and-where.html"&gt;2. binary expressions and WHERE filters&lt;/a&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  Next in database basics:
  &lt;br /&gt;
  &lt;a href="/database-basics-a-database-sql-driver.html"&gt;4. a database/sql driver&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post, we extend &lt;a href="https://github.com/eatonphil/gosql"&gt;gosql&lt;/a&gt;
to support indexes. We focus on the addition of &lt;code&gt;PRIMARY
KEY&lt;/code&gt; constraints on table creation and some easy optimizations
during &lt;code&gt;SELECT&lt;/code&gt; statements.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;$ go run cmd/main.go
Welcome to gosql.
# CREATE TABLE users (id INT PRIMARY KEY, name TEXT, age INT);
ok
# \d users
Table &amp;quot;users&amp;quot;
Column |  Type   | Nullable
---------+---------+-----------
id     | integer | not null
name   | text    |
age    | integer |
Indexes:
        &amp;quot;users_pkey&amp;quot; PRIMARY KEY, rbtree (&amp;quot;id&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This post will broadly be a discussion of &lt;a href="https://github.com/eatonphil/gosql/commit/9608511d9888ce3842ec7d1bfa8f77499e8123b2"&gt;this
commit&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="what-is-an-index?"&gt;What is an index?&lt;/h3&gt;&lt;p&gt;An index is a mapping of a value to a row in a table. The value is
often a column, but it can be many kinds of expressions. Databases
typically store indexes in tree structures that provide O(log(n))
lookup time. When &lt;code&gt;SELECT&lt;/code&gt;ing and filtering on a column
that is indexed, a database can greatly improve lookup time by
filtering first on this index. Without an index, a database must do a
linear scan for matching rows. Though sometimes if a condition is
broad enough, even with an index, a database may still end up doing a
linear scan.&lt;/p&gt;
&lt;p&gt;While it may make sense initially to map a value to a row using a hash
table for constant lookup times, hash tables don't provide
ordering. So this would prevent an index from being applicable on
anything but equality checks. For example, &lt;code&gt;SELECT x FROM y WHERE
x &gt; 2&lt;/code&gt; couldn't use a hash index on &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Indexes in many SQL databases default to a
&lt;a href="https://www.cs.cornell.edu/courses/cs3110/2012sp/recitations/rec25-B-trees/rec25.html"&gt;B-Tree&lt;/a&gt;,
which offers efficient ordering of elements. These indexes are thus
not constant-time lookups even if filtering on a unique column for a
single item. Some databases, &lt;a href="https://www.postgresql.org/docs/current/indexes-types.html"&gt;like
PostgreSQL&lt;/a&gt;,
allow you to use a hash-based index instead of a tree. Here the
previously listed restrictions apply (i.e. only equality checks will
use the index).&lt;/p&gt;
&lt;h3 id="upgrading-gosql"&gt;Upgrading gosql&lt;/h3&gt;&lt;p&gt;We proceed as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Upgrade table creation to support specifying a primary key&lt;ul&gt;
&lt;li&gt;Pick a tree data structure for the index, adding it to the table&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Upgrade &lt;code&gt;INSERT&lt;/code&gt;s to let any indexes on the table process the new row&lt;/li&gt;
&lt;li&gt;Upgrade &lt;code&gt;SELECT&lt;/code&gt;s to make use of any indexes, if possible&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="upgrading-table-creation"&gt;Upgrading table creation&lt;/h3&gt;&lt;p&gt;To allow the specification of a single column as the primary key when
creating a table, we have to first modify the lexer and parser.&lt;/p&gt;
&lt;h4 id="lexing/parsing"&gt;Lexing/parsing&lt;/h4&gt;&lt;p&gt;Since we've covered this process a few times already suffice it so say
we make the following key additions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/gosql/blob/9608511d9888ce3842ec7d1bfa8f77499e8123b2/lexer.go#L36"&gt;Add &lt;code&gt;PRIMARY KEY&lt;/code&gt; as a new keyword token to the lexer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/gosql/blob/9608511d9888ce3842ec7d1bfa8f77499e8123b2/parser.go#L425"&gt;Add a check for this token to the parsing of column definitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/gosql/blob/9608511d9888ce3842ec7d1bfa8f77499e8123b2/ast.go#L98"&gt;Modify the AST to store a boolean value whether a column is a primary key&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="in-memory-backend"&gt;In-memory backend&lt;/h4&gt;&lt;p&gt;Next we move on to handling a primary key during table creation.&lt;/p&gt;
&lt;p&gt;Since there are many existing papers and blogs on implementing tree
data structures, we will import an open-source implementation. And
while most databases use a B-Tree, the most important properties of
the tree for our purposes are 1) efficient ordering and 2) optionally
duplicate keys. We go with a Red-Black Tree,
&lt;a href="https://github.com/petar/GoLLRB"&gt;GoLLRB&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The full definition of an index now includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A name&lt;/li&gt;
&lt;li&gt;An expression (at first we only support this being an identifier referring to a
column)&lt;/li&gt;
&lt;li&gt;A unique flag&lt;/li&gt;
&lt;li&gt;A type name (it will just be &lt;code&gt;rbtree&lt;/code&gt; for now)&lt;/li&gt;
&lt;li&gt;A primary key flag (so we know to apply null checks among other things)&lt;/li&gt;
&lt;li&gt;And the actual tree itself&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type index struct {
    name       string
    exp        expression
    unique     bool
    primaryKey bool
    tree       *llrb.LLRB
    typ        string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we create a table, we add an index if one of the columns is a
primary key. We call out to a new public
method, &lt;code&gt;CreateIndex&lt;/code&gt;, that will handle actually setting
things up.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {
    if _, ok := mb.tables[crt.name.value]; ok {
        return ErrTableAlreadyExists
    }

    t := createTable()
    t.name = crt.name.value
    mb.tables[t.name] = t
    if crt.cols == nil {
        return nil
    }

    var primaryKey *expression = nil
    for _, col := range *crt.cols {
        t.columns = append(t.columns, col.name.value)

        var dt ColumnType
        switch col.datatype.value {
        case &amp;quot;int&amp;quot;:
            dt = IntType
        case &amp;quot;text&amp;quot;:
            dt = TextType
        case &amp;quot;boolean&amp;quot;:
            dt = BoolType
        default:
            delete(mb.tables, t.name)
            return ErrInvalidDatatype
        }

        if col.primaryKey {
            if primaryKey != nil {
                delete(mb.tables, t.name)
                return ErrPrimaryKeyAlreadyExists
            }

            primaryKey = &amp;amp;expression{
                literal: &amp;amp;col.name,
                kind:    literalKind,
            }
        }

        t.columnTypes = append(t.columnTypes, dt)
    }

    if primaryKey != nil {
        err := mb.CreateIndex(&amp;amp;CreateIndexStatement{
            table:      crt.name,
            name:       token{value: t.name + &amp;quot;_pkey&amp;quot;},
            unique:     true,
            primaryKey: true,
            exp:        *primaryKey,
        })
        if err != nil {
            delete(mb.tables, t.name)
            return err
        }
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Implementing &lt;code&gt;CreateIndex&lt;/code&gt; is just a matter of adding a new
index to the table.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) CreateIndex(ci *CreateIndexStatement) error {
    table, ok := mb.tables[ci.table.value]
    if !ok {
        return ErrTableDoesNotExist
    }

    for _, index := range table.indexes {
        if index.name == ci.name.value {
            return ErrIndexAlreadyExists
        }
    }

    index := &amp;amp;index{
        exp:        ci.exp,
        unique:     ci.unique,
        primaryKey: ci.primaryKey,
        name:       ci.name.value,
        tree:       llrb.New(),
        typ:        &amp;quot;rbtree&amp;quot;,
    }
    table.indexes = append(table.indexes, index)
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for creation of tables and indexes! Table creation is
also the last time we need to make changes to the gosql
frontend. The rest of the changes simply wrap existing insertion and
selection.&lt;/p&gt;
&lt;h3 id="upgrading-insert"&gt;Upgrading INSERT&lt;/h3&gt;&lt;p&gt;When a row is inserted into a table, each index on that table needs to
process the row so it can add value-to-row mappings to the index.&lt;/p&gt;
&lt;p class="note"&gt;
  In the project code, you'll notice logic in &lt;code&gt;CreateIndex&lt;/code&gt;
  to also go back over all existing rows to add them to the new index.
  This post omits further discussing the case where an index is
  created after a table is created. After reading this post, that case
  should be easy to follow.
&lt;/p&gt;&lt;p&gt;Adding a row to an index is a matter of evaluting the index expression
against that row and storing the resulting value in the tree. Along
with the value, we store the integer index of the row in the
table.&lt;/p&gt;
&lt;p&gt;If the index is required to be unique, we first check that the value
does not yet exist.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (i *index) addRow(t *table, rowIndex uint) error {
    indexValue, _, _, err := t.evaluateCell(rowIndex, i.exp)
    if err != nil {
        return err
    }

    if indexValue == nil {
        return ErrViolatesNotNullConstraint
    }

    if i.unique &amp;amp;&amp;amp; i.tree.Has(treeItem{value: indexValue}) {
        return ErrViolatesUniqueConstraint
    }

    i.tree.InsertNoReplace(treeItem{
        value: indexValue,
        index: rowIndex,
    })
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for insertion!&lt;/p&gt;
&lt;h3 id="upgrading-select"&gt;Upgrading SELECT&lt;/h3&gt;&lt;p&gt;Until now, the logic for selecting rows from a table is to pick the
table and iterate over all rows. If the row does not match
the &lt;code&gt;WHERE&lt;/code&gt; filter, we pass the row.&lt;/p&gt;
&lt;p&gt;If the table has an index and we are using the index in a recognized
pattern in the &lt;code&gt;WHERE&lt;/code&gt; AST (more on that later), we can
pre-filter the table based on the index before iterating over each
row. We can do this for each index and for each time a recognized
pattern shows up.&lt;/p&gt;
&lt;p class="note"&gt;
  This process is called query planning. We build a simplified
  version of what you may see in SQL databases, specifically focusing
  on index usage since we don't yet support &lt;code&gt;JOIN&lt;/code&gt;s. For
  further reading, SQLite has
  an &lt;a href="https://www.sqlite.org/queryplanner.html#_lookup_by_index"&gt;excellent
  document&lt;/a&gt; on their query planner for index usage.
&lt;/p&gt;&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
    t := createTable()

    if slct.from != nil {
        var ok bool
        t, ok = mb.tables[slct.from.value]
        if !ok {
            return nil, ErrTableDoesNotExist
        }
    }

    if slct.item == nil || len(*slct.item) == 0 {
        return &amp;amp;Results{}, nil
    }

    results := [][]Cell{}
    columns := []ResultColumn{}

    if slct.from == nil {
        t = createTable()
        t.rows = [][]memoryCell{{}}
    }

    for _, iAndE := range t.getApplicableIndexes(slct.where) {
        index := iAndE.i
        exp := iAndE.e
        t = index.newTableFromSubset(t, exp)
    }

    for i := range t.rows {
        result := []Cell{}
        isFirstRow := len(results) == 0

        if slct.where != nil {
            val, _, _, err := t.evaluateCell(uint(i), *slct.where)
            if err != nil {
                return nil, err
            }

            if !*val.AsBool() {
                continue
            }
        }

        for _, col := range finalItems {
            value, columnName, columnType, err := t.evaluateCell(uint(i), *col.exp)
            if err != nil {
                return nil, err
            }

            if isFirstRow {
                columns = append(columns, ResultColumn{
                    Type: columnType,
                    Name: columnName,
                })
            }

            result = append(result, value)
        }

        results = append(results, result)
    }

    return &amp;amp;Results{
        Columns: columns,
        Rows:    results,
    }, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's very simple and easy to miss, here is the change called out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;    for _, iAndE := range t.getApplicableIndexes(slct.where) {
        index := iAndE.i
        exp := iAndE.e
        t = index.newTableFromSubset(t, exp)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="getapplicableindexes"&gt;getApplicableIndexes&lt;/h4&gt;&lt;p&gt;There are probably a few very simple patterns we could look for, but
for now we look for boolean expressions joined by &lt;code&gt;AND&lt;/code&gt;
that contain an index expression.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (t *table) getApplicableIndexes(where *expression) []indexAndExpression {
    var linearizeExpressions func(where *expression, exps []expression) []expression
    linearizeExpressions = func(where *expression, exps []expression) []expression {
        if where == nil || where.kind != binaryKind {
            return exps
        }

        if where.binary.op.value == string(orKeyword) {
            return exps
        }

        if where.binary.op.value == string(andKeyword) {
            exps := linearizeExpressions(&amp;amp;where.binary.a, exps)
            return linearizeExpressions(&amp;amp;where.binary.b, exps)
        }

        return append(exps, *where)
    }

    exps := linearizeExpressions(where, []expression{})

    iAndE := []indexAndExpression{}
    for _, exp := range exps {
        for _, index := range t.indexes {
            if index.applicableValue(exp) != nil {
                iAndE = append(iAndE, indexAndExpression{
                    i: index,
                    e: exp,
                })
            }
        }
    }

    return iAndE
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;More specifically though, within binary operations we only support
matching on an index if the following three conditions are met:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the operator is one of &lt;code&gt;=&lt;/code&gt;,
&lt;code&gt;&lt;&gt;&lt;/code&gt;, &lt;code&gt;&gt;&lt;/code&gt;, &lt;code&gt;&lt;&lt;/code&gt;, &lt;code&gt;&gt;=&lt;/code&gt;, or
&lt;code&gt;&lt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;one of the operands is an identifier literal that matches the index's &lt;code&gt;exp&lt;/code&gt; value&lt;/li&gt;
&lt;li&gt;the other operand is a literal value&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="note"&gt;
  This is a simpler, stricter matching of an index than PostgreSQL
  where you can index expressions more generally, not just identifer
  literals.
&lt;/p&gt;&lt;pre&gt;&lt;code class="hljs go"&gt;func (i *index) applicableValue(exp expression) *expression {
    if exp.kind != binaryKind {
        return nil
    }

    be := exp.binary
    // Find the column and the value in the boolean expression
    columnExp := be.a
    valueExp := be.b
    if columnExp.generateCode() != i.exp.generateCode() {
        columnExp = be.b
        valueExp = be.a
    }

    // Neither side is applicable, return nil
    if columnExp.generateCode() != i.exp.generateCode() {
        return nil
    }

    supportedChecks := []symbol{eqSymbol, neqSymbol, gtSymbol, gteSymbol, ltSymbol, lteSymbol}
    supported := false
    for _, sym := range supportedChecks {
        if string(sym) == be.op.value {
            supported = true
            break
        }
    }
    if !supported {
        return nil
    }

    if valueExp.kind != literalKind {
        fmt.Println(&amp;quot;Only index checks on literals supported&amp;quot;)
        return nil
    }

    return &amp;amp;valueExp
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for finding applicable indexes.&lt;/p&gt;
&lt;h4 id="newtablefromsubset"&gt;newTableFromSubset&lt;/h4&gt;&lt;p&gt;The last remaining piece is to go from a boolean expression in
a &lt;code&gt;WHERE&lt;/code&gt; clause (where an index is applicable) to a subset
of rows in a table.&lt;/p&gt;
&lt;p&gt;Since we are only working with patterns of the type
&lt;code&gt;indexed-column OP literal-value&lt;/code&gt;, we grab the literal
using the previous &lt;code&gt;applicableValue&lt;/code&gt; helper. Then we
look up that literal value in the index and return a new table with
every row in the index that meets the condition of the operator for the
literal value.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (i *index) newTableFromSubset(t *table, exp expression) *table {
    valueExp := i.applicableValue(exp)
    if valueExp == nil {
        return t
    }

    value, _, _, err := createTable().evaluateCell(0, *valueExp)
    if err != nil {
        fmt.Println(err)
        return t
    }

    tiValue := treeItem{value: value}

    indexes := []uint{}
    switch symbol(exp.binary.op.value) {
    case eqSymbol:
        i.tree.AscendGreaterOrEqual(tiValue, func(i llrb.Item) bool {
            ti := i.(treeItem)

            if !bytes.Equal(ti.value, value) {
                return false
            }

            indexes = append(indexes, ti.index)
            return true
        })
    case neqSymbol:
        i.tree.AscendGreaterOrEqual(llrb.Inf(-1), func(i llrb.Item) bool {
            ti := i.(treeItem)
            if bytes.Equal(ti.value, value) {
                indexes = append(indexes, ti.index)
            }

            return true
        })
    case ltSymbol:
        i.tree.DescendLessOrEqual(tiValue, func(i llrb.Item) bool {
            ti := i.(treeItem)
            if bytes.Compare(ti.value, value) &amp;lt; 0 {
                indexes = append(indexes, ti.index)
            }

            return true
        })
    case lteSymbol:
        i.tree.DescendLessOrEqual(tiValue, func(i llrb.Item) bool {
            ti := i.(treeItem)
            if bytes.Compare(ti.value, value) &amp;lt;= 0 {
                indexes = append(indexes, ti.index)
            }

            return true
        })
    case gtSymbol:
        i.tree.AscendGreaterOrEqual(tiValue, func(i llrb.Item) bool {
            ti := i.(treeItem)
            if bytes.Compare(ti.value, value) &amp;gt; 0 {
                indexes = append(indexes, ti.index)
            }

            return true
        })
    case gteSymbol:
        i.tree.AscendGreaterOrEqual(tiValue, func(i llrb.Item) bool {
            ti := i.(treeItem)
            if bytes.Compare(ti.value, value) &amp;gt;= 0 {
                indexes = append(indexes, ti.index)
            }

            return true
        })
    }

    newT := createTable()
    newT.columns = t.columns
    newT.columnTypes = t.columnTypes
    newT.indexes = t.indexes
    newT.rows = [][]memoryCell{}

    for _, index := range indexes {
        newT.rows = append(newT.rows, t.rows[index])
    }

    return newT
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, an index may not necessarily improve on a linear
search in some conditions. Imagine a table of 1 million rows indexed
on an autoincrementing column. Imagine filtering on &lt;code&gt;col &gt;
10&lt;/code&gt;. The index may be able to eliminate 10 items but still
return a pre-filtered table of around 1 million rows that must
be passed through the &lt;code&gt;WHERE&lt;/code&gt; filter.&lt;/p&gt;
&lt;p&gt;Additionally since we process each boolean expression one at a time,
we can't take advantage of knowledge that might seem obvious to a
human for two boolean expressions that together bound a range. For
example in &lt;code&gt;x &gt; 10 AND x &lt; 20&lt;/code&gt; we can see that only
integers from 11 to 19 are applicable. But the current logic would go
through each expression separately and find all rows that match either
before the final linear search through all pre-filtered rows would
eliminate the bulk.&lt;/p&gt;
&lt;p class="note"&gt;
  Thankfully real databases have decades of optimizations. But even
  then it can be difficult to know what index usages are being
  optimized without reading documentation, benchmarking, using
  &lt;code&gt;EXPLAIN ANALYSE&lt;/code&gt;, or reading the source.
&lt;/p&gt;&lt;p&gt;But that's it for changes needed to support basic indexes end-to-end!&lt;/p&gt;
&lt;h3 id="trialing-an-index"&gt;Trialing an index&lt;/h3&gt;&lt;p&gt;Since the addition of indexes is so seamless, it is difficult to tell
without trial that the index is effective. So we write a simple
program that inserts N rows with and without an index. Finally it will
query for the first and last items inserted. We show time and
memory used during both insertion and selection.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;runtime&amp;quot;
    &amp;quot;strconv&amp;quot;
    &amp;quot;time&amp;quot;

    &amp;quot;github.com/eatonphil/gosql&amp;quot;
)

var inserts = 0
var lastId = 0
var firstId = 0

func doInsert(mb gosql.Backend) {
    parser := gosql.Parser{}
    for i := 0; i &amp;lt; inserts; i++ {
        lastId = i
        if i == 0 {
            firstId = lastId
        }
        ast, err := parser.Parse(fmt.Sprintf(&amp;quot;INSERT INTO users VALUES (%d)&amp;quot;, lastId))
        if err != nil {
            panic(err)
        }

        err = mb.Insert(ast.Statements[0].InsertStatement)
        if err != nil {
            panic(err)
        }
    }
}

func doSelect(mb gosql.Backend) {
    parser := gosql.Parser{}
    ast, err := parser.Parse(fmt.Sprintf(&amp;quot;SELECT id FROM users WHERE id = %d&amp;quot;, lastId))
    if err != nil {
        panic(err)
    }

    r, err := mb.Select(ast.Statements[0].SelectStatement)
    if err != nil {
        panic(err)
    }

    if len(r.Rows) != 1 {
        panic(&amp;quot;Expected 1 row&amp;quot;)
    }

    if int(*r.Rows[0][1].AsInt()) != inserts-1 {
        panic(fmt.Sprintf(&amp;quot;Bad row, got: %d&amp;quot;, r.Rows[0][1].AsInt()))
    }

    ast, err = parser.Parse(fmt.Sprintf(&amp;quot;SELECT id FROM users WHERE id = %d&amp;quot;, firstId))
    if err != nil {
        panic(err)
    }

    r, err = mb.Select(ast.Statements[0].SelectStatement)
    if err != nil {
        panic(err)
    }

    if len(r.Rows) != 1 {
        panic(&amp;quot;Expected 1 row&amp;quot;)
    }

    if int(*r.Rows[0][1].AsInt()) != 0 {
        panic(fmt.Sprintf(&amp;quot;Bad row, got: %d&amp;quot;, r.Rows[0][1].AsInt()))
    }
}

func perf(name string, b gosql.Backend, cb func(b gosql.Backend)) {
    start := time.Now()
    fmt.Println(&amp;quot;Starting&amp;quot;, name)
    cb(b)
    fmt.Printf(&amp;quot;Finished %s: %f seconds\n&amp;quot;, name, time.Since(start).Seconds())

    var m runtime.MemStats
    runtime.ReadMemStats(&amp;amp;m)
    fmt.Printf(&amp;quot;Alloc = %d MiB\n\n&amp;quot;, m.Alloc/1024/1024)
}

func main() {
    mb := gosql.NewMemoryBackend()

    index := false
    for i, arg := range os.Args {
        if arg == &amp;quot;--with-index&amp;quot; {
            index = true
        }

        if arg == &amp;quot;--inserts&amp;quot; {
            inserts, _ = strconv.Atoi(os.Args[i+1])
        }
    }

    primaryKey := &amp;quot;&amp;quot;
    if index {
        primaryKey = &amp;quot; PRIMARY KEY&amp;quot;
    }

    parser := gosql.Parser{}
    ast, err := parser.Parse(fmt.Sprintf(&amp;quot;CREATE TABLE users (id INT%s)&amp;quot;, primaryKey))
    if err != nil {
        panic(err)
    }

    err = mb.CreateTable(ast.Statements[0].CreateTableStatement)
    if err != nil {
        panic(err)
    }

    indexingString := &amp;quot; with indexing enabled&amp;quot;
    if !index {
        indexingString = &amp;quot;&amp;quot;
    }
    fmt.Printf(&amp;quot;Inserting %d rows%s\n&amp;quot;, inserts, indexingString)

    perf(&amp;quot;INSERT&amp;quot;, mb, doInsert)

    perf(&amp;quot;SELECT&amp;quot;, mb, doSelect)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build and run once without an index:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build cmd/indextest/main.go
./main --inserts 1000000
Inserting 1000000 rows
Starting INSERT
Finished INSERT: 76.175133 seconds
Alloc = 239 MiB

Starting SELECT
Finished SELECT: 1.301556 seconds
Alloc = 238 MiB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And run again with an index:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;./main --inserts 1000000 --with-index
Inserting 1000000 rows with indexing enabled
Starting INSERT
Finished INSERT: 89.108121 seconds
Alloc = 341 MiB

Starting SELECT
Finished SELECT: 0.000137 seconds
Alloc = 341 MiB
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The basic tradeoff that you can see is that for more memory and longer
insertion times, you get a significantly faster lookup.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Very excited to share the latest database basics post on implementing indexes in gosql.&lt;a href="https://t.co/QHfjCe1XsC"&gt;https://t.co/QHfjCe1XsC&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1256209468133650433?ref_src=twsrc%5Etfw"&gt;May 1, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/database-basics-indexes.html</guid><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate></item><item><title>Writing a SQL database from scratch in Go: 2. binary expressions and WHERE filters</title><link>http://notes.eatonphil.com/database-basics-expressions-and-where.html</link><description>&lt;p class="note"&gt;
  Previously in database basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/database-basics.html"&gt;1. SELECT, INSERT, CREATE and a REPL&lt;/a&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  Next in database basics:
  &lt;br /&gt;
  &lt;a href="/database-basics-indexes.html"&gt;3. indexes&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-a-database-sql-driver.html"&gt;4. a database/sql driver&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post, we'll extend &lt;a href="https://github.com/eatonphil/gosql"&gt;gosql&lt;/a&gt;
to support binary expressions and very simple filtering on SELECT
results via WHERE. We'll introduce a general mechanism for
interpreting an expression on a row in a table. The expression may be
an identifier (where the result is the value of the cell corresponding
to that column in the row), a numeric literal, a combination via a
binary expression, etc.&lt;/p&gt;
&lt;p&gt;The following interactions will be possible:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;# CREATE TABLE users (name TEXT, age INT);
ok
#  INSERT INTO users VALUES (&amp;#39;Stephen&amp;#39;, 16);
ok
# SELECT name, age FROM users;
name   | age
----------+------
Stephen |  16
(1 result)
ok
# INSERT INTO users VALUES (&amp;#39;Adrienne&amp;#39;, 23);
ok
# SELECT age + 2, name FROM users WHERE age = 23;
age |   name
------+-----------
25 | Adrienne
(1 result)
ok
# SELECT name FROM users;
name
------------
Stephen
Adrienne
(2 results)
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The changes we'll make in this post are roughly a walk through of
&lt;a href="https://github.com/eatonphil/gosql/commit/bd6a5d0d4a7410699b0d01beaabf91923df34b28"&gt;this
commit&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="boilerplate-updates"&gt;Boilerplate updates&lt;/h3&gt;&lt;p&gt;There are a few updates to pick up that I won't go into in this
post. Grab the following files from the main repo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/gosql/blob/master/lexer.go"&gt;lexer.go&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;The big change here is to use the same keyword matching algorithm
for symbols. This allows us to support symbols that are longer
than one character.&lt;/li&gt;
&lt;li&gt;This file also now includes the following keywords and symbols:
&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;,
&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&lt;&gt;&lt;/code&gt;,
&lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;+&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/eatonphil/gosql/blob/master/cmd/main.go"&gt;cmd/main.go&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;This file now uses a &lt;a href="https://github.com/olekukonko/tablewriter"&gt;third-party table-rendering
library&lt;/a&gt; instead of the
hacky, handwritten original one.&lt;/li&gt;
&lt;li&gt;This also uses a &lt;a href="https://github.com/chzyer/readline"&gt;third-party readline
implementation&lt;/a&gt; so you get
history and useful cursor movement in the REPL.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="parsing-boilerplate"&gt;Parsing boilerplate&lt;/h4&gt;&lt;p&gt;We'll redefine three helper functions in &lt;code&gt;parser.go&lt;/code&gt; before
going further:
&lt;code&gt;parseToken&lt;/code&gt;, &lt;code&gt;parseTokenKind&lt;/code&gt;, and
&lt;code&gt;helpMessage&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;parseToken&lt;/code&gt; helper will consume a token if it matches
the one provided as an argument (ignoring location).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseToken(tokens []*token, initialCursor uint, t token) (*token, uint, bool) {
    cursor := initialCursor

    if cursor &amp;gt;= uint(len(tokens)) {
        return nil, initialCursor, false
    }

    if p := tokens[cursor]; t.equals(p) {
        return p, cursor + 1, true
    }

    return nil, initialCursor, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parseTokenKind&lt;/code&gt; helper will consume a token if it is
the same kind as an argument provided.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseTokenKind(tokens []*token, initialCursor uint, kind tokenKind) (*token, uint, bool) {
    cursor := initialCursor

    if cursor &amp;gt;= uint(len(tokens)) {
        return nil, initialCursor, false
    }

    current := tokens[cursor]
    if current.kind == kind {
        return current, cursor + 1, true
    }

    return nil, initialCursor, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the &lt;code&gt;helpMessage&lt;/code&gt; helper will give an indication of
where in a program something happened.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func helpMessage(tokens []*token, cursor uint, msg string) {
    var c *token
    if cursor+1 &amp;lt; uint(len(tokens)) {
        c = tokens[cursor+1]
    } else {
        c = tokens[cursor]
    }

    fmt.Printf(&amp;quot;[%d,%d]: %s, near: %s\n&amp;quot;, c.loc.line, c.loc.col, msg, c.value)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="parsing-binary-expressions"&gt;Parsing binary expressions&lt;/h3&gt;&lt;p&gt;Next we'll extend the AST structure in &lt;code&gt;ast.go&lt;/code&gt; to
support a "binary kind" of expression. The binary expression will have
two sub-expressions and an operator.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;const (
    literalKind expressionKind
    binaryKind
)

type binaryExpression struct {
    a  expression
    b  expression
    op token
}

type expression struct {
    literal *token
    binary  *binaryExpression
    kind    expressionKind
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll use Pratt parsing to handle operator precedence. There is an
excellent introduction to this technique
&lt;a href="https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If at the beginning of parsing we see a left parenthesis, we'll
consume it and parse an expression within it. Then we'll look for a
right parenthesis. Otherwise we'll look for a non-binary expression
first (e.g. symbol, number).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseExpression(tokens []*token, initialCursor uint, delimiters []token, minBp uint) (*expression, uint, bool) {
    cursor := initialCursor

    var exp *expression
    _, newCursor, ok := parseToken(tokens, cursor, tokenFromSymbol(leftParenSymbol))
    if ok {
        cursor = newCursor
        rightParenToken := tokenFromSymbol(rightParenSymbol)

        exp, cursor, ok = parseExpression(tokens, cursor, append(delimiters, rightParenToken), minBp)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected expression after opening paren&amp;quot;)
            return nil, initialCursor, false
        }

        _, cursor, ok = parseToken(tokens, cursor, rightParenToken)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected closing paren&amp;quot;)
            return nil, initialCursor, false
        }
    } else {
        exp, cursor, ok = parseLiteralExpression(tokens, cursor)
        if !ok {
            return nil, initialCursor, false
        }
    }

    ...

    return exp, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we'll look for a binary operator (e.g. &lt;code&gt;=&lt;/code&gt;,
&lt;code&gt;and&lt;/code&gt;) or delimiter. If we find an operator and it of
lesser "binding power" than the current minimum (&lt;code&gt;minBp&lt;/code&gt;
passed as an argument to the parse function with a default value of
&lt;code&gt;0&lt;/code&gt;), we'll return the current expression.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;    ...

    lastCursor := cursor
outer:
    for cursor &amp;lt; uint(len(tokens)) {
        for _, d := range delimiters {
            _, _, ok = parseToken(tokens, cursor, d)
            if ok {
                break outer
            }
        }

        binOps := []token{
            tokenFromKeyword(andKeyword),
            tokenFromKeyword(orKeyword),
            tokenFromSymbol(eqSymbol),
            tokenFromSymbol(neqSymbol),
            tokenFromSymbol(concatSymbol),
            tokenFromSymbol(plusSymbol),
        }

        var op *token = nil
        for _, bo := range binOps {
            var t *token
            t, cursor, ok = parseToken(tokens, cursor, bo)
            if ok {
                op = t
                break
            }
        }

        if op == nil {
            helpMessage(tokens, cursor, &amp;quot;Expected binary operator&amp;quot;)
            return nil, initialCursor, false
        }

        bp := op.bindingPower()
        if bp &amp;lt; minBp {
            cursor = lastCursor
            break
        }

        ...
    }

    return exp, cursor, true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;bindingPower&lt;/code&gt; function on tokens can be defined for
now such that sum and concatenation have the highest binding power,
followed by equality operations, then boolean operators, and then
everything else at zero.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (t token) bindingPower() uint {
    switch t.kind {
    case keywordKind:
        switch keyword(t.value) {
        case andKeyword:
            fallthrough
        case orKeyword:
            return 1
        }
    case symbolKind:
        switch symbol(t.value) {
        case eqSymbol:
            fallthrough
        case neqSymbol:
            fallthrough
        case concatSymbol:
            fallthrough
        case plusSymbol:
            return 3
        }
    }

    return 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Back in &lt;code&gt;parseExpression&lt;/code&gt;, if the new operator has greater
binding power we'll parse the next operand expression (a recursive
call, passing the binding power of the new operator as the new
&lt;code&gt;minBp&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Upon completion, the current expression (the return value of the
recursive call) is set to a new binary expression containing the
previously current expression on the left and the just-parsed
expression on the right.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;        ...

        b, newCursor, ok := parseExpression(tokens, cursor, delimiters, bp)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected right operand&amp;quot;)
            return nil, initialCursor, false
        }
        exp = &amp;amp;expression{
            binary: &amp;amp;binaryExpression{
                *exp,
                *b,
                *op,
            },
            kind: binaryKind,
        }
        cursor = newCursor
        lastCursor = cursor
    }

    return exp, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All together:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseExpression(tokens []*token, initialCursor uint, delimiters []token, minBp uint) (*expression, uint, bool) {
    cursor := initialCursor

    var exp *expression
    _, newCursor, ok := parseToken(tokens, cursor, tokenFromSymbol(leftParenSymbol))
    if ok {
        cursor = newCursor
        rightParenToken := tokenFromSymbol(rightParenSymbol)

        exp, cursor, ok = parseExpression(tokens, cursor, append(delimiters, rightParenToken), minBp)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected expression after opening paren&amp;quot;)
            return nil, initialCursor, false
        }

        _, cursor, ok = parseToken(tokens, cursor, rightParenToken)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected closing paren&amp;quot;)
            return nil, initialCursor, false
        }
    } else {
        exp, cursor, ok = parseLiteralExpression(tokens, cursor)
        if !ok {
            return nil, initialCursor, false
        }
    }

    lastCursor := cursor
outer:
    for cursor &amp;lt; uint(len(tokens)) {
        for _, d := range delimiters {
            _, _, ok = parseToken(tokens, cursor, d)
            if ok {
                break outer
            }
        }

        binOps := []token{
            tokenFromKeyword(andKeyword),
            tokenFromKeyword(orKeyword),
            tokenFromSymbol(eqSymbol),
            tokenFromSymbol(neqSymbol),
            tokenFromSymbol(concatSymbol),
            tokenFromSymbol(plusSymbol),
        }

        var op *token = nil
        for _, bo := range binOps {
            var t *token
            t, cursor, ok = parseToken(tokens, cursor, bo)
            if ok {
                op = t
                break
            }
        }

        if op == nil {
            helpMessage(tokens, cursor, &amp;quot;Expected binary operator&amp;quot;)
            return nil, initialCursor, false
        }

        bp := op.bindingPower()
        if bp &amp;lt; minBp {
            cursor = lastCursor
            break
        }

        b, newCursor, ok := parseExpression(tokens, cursor, delimiters, bp)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected right operand&amp;quot;)
            return nil, initialCursor, false
        }
        exp = &amp;amp;expression{
            binary: &amp;amp;binaryExpression{
                *exp,
                *b,
                *op,
            },
            kind: binaryKind,
        }
        cursor = newCursor
        lastCursor = cursor
    }

    return exp, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have this general parse expression helper in place, we can
add support for parsing &lt;code&gt;WHERE&lt;/code&gt; in &lt;code&gt;SELECT&lt;/code&gt;
statements.&lt;/p&gt;
&lt;h3 id="parsing-where"&gt;Parsing WHERE&lt;/h3&gt;&lt;p&gt;This part's pretty easy. We modify the existing
&lt;code&gt;parseSelectStatement&lt;/code&gt; to search for an optional
&lt;code&gt;WHERE&lt;/code&gt; token followed by an expression.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseSelectStatement(tokens []*token, initialCursor uint, delimiter token) (*SelectStatement, uint, bool) {
    var ok bool
    cursor := initialCursor
    _, cursor, ok = parseToken(tokens, cursor, tokenFromKeyword(selectKeyword))
    if !ok {
        return nil, initialCursor, false
    }

    slct := SelectStatement{}

    fromToken := tokenFromKeyword(fromKeyword)
    item, newCursor, ok := parseSelectItem(tokens, cursor, []token{fromToken, delimiter})
    if !ok {
        return nil, initialCursor, false
    }

    slct.item = item
    cursor = newCursor

    whereToken := tokenFromKeyword(whereKeyword)
    delimiters := []token{delimiter, whereToken}

    _, cursor, ok = parseToken(tokens, cursor, fromToken)
    if ok {
        from, newCursor, ok := parseFromItem(tokens, cursor, delimiters)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected FROM item&amp;quot;)
            return nil, initialCursor, false
        }

        slct.from = from
        cursor = newCursor
    }

    _, cursor, ok = parseToken(tokens, cursor, whereToken)
    if ok {
        where, newCursor, ok := parseExpression(tokens, cursor, []token{delimiter}, 0)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected WHERE conditionals&amp;quot;)
            return nil, initialCursor, false
        }

        slct.where = where
        cursor = newCursor
    }

    return &amp;amp;slct, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we're all done with parsing binary expressions and
&lt;code&gt;WHERE&lt;/code&gt; filters! If in doubt, refer to
&lt;a href="https://github.com/eatonphil/gosql/blob/master/parser.go"&gt;parser.go&lt;/a&gt;
in the project.&lt;/p&gt;
&lt;h3 id="re-thinking-query-execution"&gt;Re-thinking query execution&lt;/h3&gt;&lt;p&gt;In the first post in this series, we didn't establish any standard way
for interpreting an expression in any kind of statement. In SQL
though, every expression is always run in the context of a row in a
table. We'll handle cases like &lt;code&gt;SELECT 1&lt;/code&gt; and &lt;code&gt;INSERT INTO
users VALUES (1)&lt;/code&gt; by creating a table with a single empty row to act
as the context.&lt;/p&gt;
&lt;p&gt;This requires a bit of re-architecting. So we'll rewrite the
&lt;code&gt;memory.go&lt;/code&gt; implementation in this post from scratch.&lt;/p&gt;
&lt;p&gt;We'll also stop &lt;code&gt;panic&lt;/code&gt;-ing when things go wrong. Instead
we'll print a message. This allows the REPL loop to keep going.&lt;/p&gt;
&lt;h4 id="memory-cells"&gt;Memory cells&lt;/h4&gt;&lt;p&gt;Again the fundamental blocks of memory in the table will be an untyped
array of bytes. We'll provide conversion methods from this memory cell
into integers, strings, and boolean Go values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type MemoryCell []byte

func (mc MemoryCell) AsInt() int32 {
    var i int32
    err := binary.Read(bytes.NewBuffer(mc), binary.BigEndian, &amp;amp;i)
    if err != nil {
        fmt.Printf(&amp;quot;Corrupted data [%s]: %s\n&amp;quot;, mc, err)
        return 0
    }

    return i
}

func (mc MemoryCell) AsText() string {
    return string(mc)
}

func (mc MemoryCell) AsBool() bool {
    return len(mc) != 0
}

func (mc MemoryCell) equals(b MemoryCell) bool {
    // Seems verbose but need to make sure if one is nil, the
    // comparison still fails quickly
    if mc == nil || b == nil {
        return mc == nil &amp;amp;&amp;amp; b == nil
    }

    return bytes.Compare(mc, b) == 0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll also extend the &lt;code&gt;Cell&lt;/code&gt; interface in
&lt;code&gt;backend.go&lt;/code&gt; to support the new boolean type.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package gosql

type ColumnType uint

const (
    TextType ColumnType = iota
    IntType
    BoolType
)

type Cell interface {
    AsText() string
    AsInt() int32
    AsBool() bool
}

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we need a way for mapping a Go value &lt;em&gt;into&lt;/em&gt; a memory
cell.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func literalToMemoryCell(t *token) MemoryCell {
    if t.kind == numericKind {
        buf := new(bytes.Buffer)
        i, err := strconv.Atoi(t.value)
        if err != nil {
            fmt.Printf(&amp;quot;Corrupted data [%s]: %s\n&amp;quot;, t.value, err)
            return MemoryCell(nil)
        }

        // TODO: handle bigint
        err = binary.Write(buf, binary.BigEndian, int32(i))
        if err != nil {
            fmt.Printf(&amp;quot;Corrupted data [%s]: %s\n&amp;quot;, string(buf.Bytes()), err)
            return MemoryCell(nil)
        }
        return MemoryCell(buf.Bytes())
    }

    if t.kind == stringKind {
        return MemoryCell(t.value)
    }

    if t.kind == boolKind {
        if t.value == &amp;quot;true&amp;quot; {
            return MemoryCell([]byte{1})
        } else {
            return MemoryCell(nil)
        }
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we'll provide global &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;
values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;
var (
    trueToken  = token{kind: boolKind, value: &amp;quot;true&amp;quot;}
    falseToken = token{kind: boolKind, value: &amp;quot;false&amp;quot;}

    trueMemoryCell  = literalToMemoryCell(&amp;amp;trueToken)
    falseMemoryCell = literalToMemoryCell(&amp;amp;falseToken)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="tables"&gt;Tables&lt;/h4&gt;&lt;p&gt;A table has a list of rows (an array of memory cells) and a list of
column names and types.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type table struct {
    columns     []string
    columnTypes []ColumnType
    rows        [][]MemoryCell
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally we'll add a series of methods on &lt;code&gt;table&lt;/code&gt; that,
given a row index, interprets an expression AST against that row in
the table.&lt;/p&gt;
&lt;h3 id="interpreting-literals"&gt;Interpreting literals&lt;/h3&gt;&lt;p&gt;First we'll implement &lt;code&gt;evaluateLiteralCell&lt;/code&gt; that will look
up an identifier or return the value of integers, strings, and
booleans.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (t *table) evaluateLiteralCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {
    if exp.kind != literalKind {
        return nil, &amp;quot;&amp;quot;, 0, ErrInvalidCell
    }

    lit := exp.literal
    if lit.kind == identifierKind {
        for i, tableCol := range t.columns {
            if tableCol == lit.value {
                return t.rows[rowIndex][i], tableCol, t.columnTypes[i], nil
            }
        }

        return nil, &amp;quot;&amp;quot;, 0, ErrColumnDoesNotExist
    }

    columnType := IntType
    if lit.kind == stringKind {
        columnType = TextType
    } else if lit.kind == boolKind {
        columnType = BoolType
    }

    return literalToMemoryCell(lit), &amp;quot;?column?&amp;quot;, columnType, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interpreting-binary-expressions"&gt;Interpreting binary expressions&lt;/h3&gt;&lt;p&gt;Now we can implement &lt;code&gt;evaluateBinaryCell&lt;/code&gt; that will
evaluate it's two sub-expressions and combine them together according
to the operator. The SQL operators we have defined so far do no
coercion. So we'll fail immediately if the two sides of the operation
are not of the same type. Additionally, the concatenation and addition
operators require that their arguments are strings and numbers,
respectively.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (t *table) evaluateBinaryCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {
    if exp.kind != binaryKind {
        return nil, &amp;quot;&amp;quot;, 0, ErrInvalidCell
    }

    bexp := exp.binary

    l, _, lt, err := t.evaluateCell(rowIndex, bexp.a)
    if err != nil {
        return nil, &amp;quot;&amp;quot;, 0, err
    }

    r, _, rt, err := t.evaluateCell(rowIndex, bexp.b)
    if err != nil {
        return nil, &amp;quot;&amp;quot;, 0, err
    }

    switch bexp.op.kind {
    case symbolKind:
        switch symbol(bexp.op.value) {
        case eqSymbol:
            eq := l.equals(r)
            if lt == TextType &amp;amp;&amp;amp; rt == TextType &amp;amp;&amp;amp; eq {
                return trueMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
            }

            if lt == IntType &amp;amp;&amp;amp; rt == IntType &amp;amp;&amp;amp; eq {
                return trueMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
            }

            if lt == BoolType &amp;amp;&amp;amp; rt == BoolType &amp;amp;&amp;amp; eq {
                return trueMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
            }

            return falseMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
        case neqSymbol:
            if lt != rt || !l.equals(r) {
                return trueMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
            }

            return falseMemoryCell, &amp;quot;?column?&amp;quot;, BoolType, nil
        case concatSymbol:
            if lt != TextType || rt != TextType {
                return nil, &amp;quot;&amp;quot;, 0, ErrInvalidOperands
            }

            return literalToMemoryCell(&amp;amp;token{kind: stringKind, value: l.AsText() + r.AsText()}), &amp;quot;?column?&amp;quot;, TextType, nil
        case plusSymbol:
            if lt != IntType || rt != IntType {
                return nil, &amp;quot;&amp;quot;, 0, ErrInvalidOperands
            }

            iValue := int(l.AsInt() + r.AsInt())
            return literalToMemoryCell(&amp;amp;token{kind: numericKind, value: strconv.Itoa(iValue)}), &amp;quot;?column?&amp;quot;, IntType, nil
        default:
            // TODO
            break
        }
    case keywordKind:
        switch keyword(bexp.op.value) {
        case andKeyword:
            if lt != BoolType || rt != BoolType {
                return nil, &amp;quot;&amp;quot;, 0, ErrInvalidOperands
            }

            res := falseMemoryCell
            if l.AsBool() &amp;amp;&amp;amp; r.AsBool() {
                res = trueMemoryCell
            }

            return res, &amp;quot;?column?&amp;quot;, BoolType, nil
        case orKeyword:
            if lt != BoolType || rt != BoolType {
                return nil, &amp;quot;&amp;quot;, 0, ErrInvalidOperands
            }

            res := falseMemoryCell
            if l.AsBool() || r.AsBool() {
                res = trueMemoryCell
            }

            return res, &amp;quot;?column?&amp;quot;, BoolType, nil
        default:
            // TODO
            break
        }
    }

    return nil, &amp;quot;&amp;quot;, 0, ErrInvalidCell
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we'll provide a generic &lt;code&gt;evaluateCell&lt;/code&gt; method to wrap
these two correctly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (t *table) evaluateCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {
    switch exp.kind {
        case literalKind:
            return t.evaluateLiteralCell(rowIndex, exp)
        case binaryKind:
            return t.evaluateBinaryCell(rowIndex, exp)
        default:
            return nil, &amp;quot;&amp;quot;, 0, ErrInvalidCell
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="implementing-select"&gt;Implementing SELECT&lt;/h3&gt;&lt;p&gt;As before, each statement will operate on a backend of tables.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type MemoryBackend struct {
    tables map[string]*table
}

func NewMemoryBackend() *MemoryBackend {
    return &amp;amp;MemoryBackend{
        tables: map[string]*table{},
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we implement &lt;code&gt;SELECT&lt;/code&gt;, we'll iterate over each row in
the table (we only support looking up one table for now).  If the
&lt;code&gt;SELECT&lt;/code&gt; statement contains a &lt;code&gt;WHERE&lt;/code&gt; block,
we'll evaluate the &lt;code&gt;WHERE&lt;/code&gt; expression against the current
row and move on if the result is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Otherwise for each expression in the &lt;code&gt;SELECT&lt;/code&gt; list of items
we'll evaluate it against the current row in the table.&lt;/p&gt;
&lt;p&gt;If there is no table selected, we provide a fake table with a single
empty row.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
    t := &amp;amp;table{}

    if slct.from != nil &amp;amp;&amp;amp; slct.from.table != nil {
        var ok bool
        t, ok = mb.tables[slct.from.table.value]
        if !ok {
            return nil, ErrTableDoesNotExist
        }
    }

    if slct.item == nil || len(*slct.item) == 0 {
        return &amp;amp;Results{}, nil
    }

    results := [][]Cell{}
    columns := []struct {
        Type ColumnType
        Name string
    }{}

    if slct.from == nil {
        t = &amp;amp;table{}
        t.rows = [][]MemoryCell{{}}
    }

    for i := range t.rows {
        result := []Cell{}
        isFirstRow := len(results) == 0

        if slct.where != nil {
            val, _, _, err := t.evaluateCell(uint(i), *slct.where)
            if err != nil {
                return nil, err
            }

            if !val.AsBool() {
                continue
            }
        }

        for _, col := range *slct.item {
            if col.asterisk {
                // TODO: handle asterisk
                fmt.Println(&amp;quot;Skipping asterisk.&amp;quot;)
                continue
            }

            value, columnName, columnType, err := t.evaluateCell(uint(i), *col.exp)
            if err != nil {
                return nil, err
            }

            if isFirstRow {
                columns = append(columns, struct {
                    Type ColumnType
                    Name string
                }{
                    Type: columnType,
                    Name: columnName,
                })
            }

            result = append(result, value)
        }

        results = append(results, result)
    }

    return &amp;amp;Results{
        Columns: columns,
        Rows:    results,
    }, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="implementing-insert,-create"&gt;Implementing INSERT, CREATE&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;INSERT&lt;/code&gt; and &lt;code&gt;CREATE&lt;/code&gt; statements stay mostly
the same except for that we'll use the &lt;code&gt;evaluateCell&lt;/code&gt; help
for every expression. Refer back to the first post if the
implementation is otherwise unclear.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) Insert(inst *InsertStatement) error {
    t, ok := mb.tables[inst.table.value]
    if !ok {
        return ErrTableDoesNotExist
    }

    if inst.values == nil {
        return nil
    }

    row := []MemoryCell{}

    if len(*inst.values) != len(t.columns) {
        return ErrMissingValues
    }

    for _, value := range *inst.values {
        if value.kind != literalKind {
            fmt.Println(&amp;quot;Skipping non-literal.&amp;quot;)
            continue
        }

        emptyTable := &amp;amp;table{}
        value, _, _, err := emptyTable.evaluateCell(0, *value)
        if err != nil {
            return err
        }

        row = append(row, value)
    }

    t.rows = append(t.rows, row)
    return nil
}

func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {
    t := table{}
    mb.tables[crt.name.value] = &amp;amp;t
    if crt.cols == nil {

        return nil
    }

    for _, col := range *crt.cols {
        t.columns = append(t.columns, col.name.value)

        var dt ColumnType
        switch col.datatype.value {
        case &amp;quot;int&amp;quot;:
            dt = IntType
        case &amp;quot;text&amp;quot;:
            dt = TextType
        default:
            return ErrInvalidDatatype
        }

        t.columnTypes = append(t.columnTypes, dt)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="back-to-the-repl"&gt;Back to the REPL&lt;/h3&gt;&lt;p&gt;Putting it all together, we run the following session:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;# CREATE TABLE users (name TEXT, age INT);
ok
#  INSERT INTO users VALUES (&amp;#39;Stephen&amp;#39;, 16);
ok
# SELECT name, age FROM users;
name   | age
----------+------
Stephen |  16
(1 result)
ok
# INSERT INTO users VALUES (&amp;#39;Adrienne&amp;#39;, 23);
ok
# SELECT age + 2, name FROM users WHERE age = 23;
age |   name
------+-----------
25 | Adrienne
(1 result)
ok
# SELECT name FROM users;
name
------------
Stephen
Adrienne
(2 results)
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for now! In future posts we'll get into indices, joining
tables, etc.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post up in the database basics series: adding support for binary expressions and WHERE filtering in SELECTs.&lt;br&gt;&lt;br&gt;Much nicer to have a real table rendering library and readline implementation in the REPL too.&lt;a href="https://t.co/GYzn3FUNon"&gt;https://t.co/GYzn3FUNon&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1249426633347473408?ref_src=twsrc%5Etfw"&gt;April 12, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/database-basics-expressions-and-where.html</guid><pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate></item><item><title>Studying foreign languages with inbox zero</title><link>http://notes.eatonphil.com/studying-with-inbox-zero.html</link><description>&lt;p&gt;The only time I've been able to seriously, rapidly improve my ability
to speak a foreign language was through intensive language courses in
college. I was forced to actively speak, read, and write Chinese for
6-8 hours a week (1-2 hours every day). Then study another 5-10 hours
a week in preparation for the active sessions. I went three semesters
like this before I left school.&lt;/p&gt;
&lt;p&gt;I've been trying to recreate that intensity since and mostly
failed. After marrying a Korean, I've redirected the little effort I
can muster to learning Korean. Aside from stints over the years
(mostly for a month or two before or after a trip to Korea), I haven't
been able to keep up any practice.&lt;/p&gt;
&lt;p&gt;One thing I've tried over the years to commit myself to learning a
number of different topics is to set up recurring calendar invites:
"Study Linux", "Study TCP/IP", "Study Korean", etc.&lt;/p&gt;
&lt;p&gt;This has mostly failed too. However, I do always &lt;em&gt;look&lt;/em&gt; at the
invites as I get notified.&lt;/p&gt;
&lt;p&gt;I keep inbox zero and I check my email many times a day, marking each
email read dilligently when I no longer need to think about it.&lt;/p&gt;
&lt;p&gt;Tools like Quizlet, Anki, or even Duolingo let you self-learn
vocabulary &lt;em&gt;when you feel like it&lt;/em&gt;. But basically no service
will try to keep giving you exposure to some set of topics whether you
spend time on it or not.&lt;/p&gt;
&lt;p&gt;The most important thing I can think of is forced exposure to
vocabulary. So I've been planning for some time to hook up a list of
the one thousand most common Korean words to scheduled emails.&lt;/p&gt;
&lt;p&gt;This weekend I finally got around to scripting the Google Calendar API
against the words list. I have an event for each word for the next
1000 days. Each day I receive a summary email including all events of
the day and the new word is part of it.&lt;/p&gt;
&lt;p&gt;This is a pretty indirect approach but it's pretty simple to set
up. It's not very easy to reconfigure.&lt;/p&gt;
&lt;p&gt;The code for doing this is &lt;a href="https://github.com/eatonphil/learnit"&gt;available on
Github&lt;/a&gt; if you're
interested. And if you know a service that can build and manage
scheduled notifications against a spreadsheet or database I'd rather
be looking at that.&lt;/p&gt;
&lt;p&gt;We'll see how this works out.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Daily new words in my inbox feels like the only way I can &amp;quot;force&amp;quot; myself to get exposed to new vocabulary. Wish there were a service for scheduling notifications from a spreadsheet. Finally got to scripting GCal&amp;#39;s API populating daily events from 1000 most common Korean words&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1246557948068925441?ref_src=twsrc%5Etfw"&gt;April 4, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/studying-with-inbox-zero.html</guid><pubDate>Sat, 04 Apr 2020 00:00:00 +0000</pubDate></item><item><title>Reviewing the Surface Book 2</title><link>http://notes.eatonphil.com/reviewing-the-surface-book-2.html</link><description>&lt;p&gt;The first few paragraphs cover what I was looking for and what I
considered. Then the review.&lt;/p&gt;
&lt;h3 id="why-the-surface-book-2"&gt;Why the Surface Book 2&lt;/h3&gt;&lt;p&gt;I used a Macbook throughout my professional career until I had the
choice a few years ago when I started my current job. Here, I ran
Gentoo, then FreeBSD, then Arch, and now Windows 10 on the Dell XPS
15.&lt;/p&gt;
&lt;p&gt;I enjoy Windows and I think Microsoft is doing a better job on
hardware and software these days. At least, compared to Apple, they
appear to be trying. So when my personal 2015 Macbook Pro died this
year I decided to buy and run Windows at home.&lt;/p&gt;
&lt;p&gt;On my Mac, I dealt with bad battery life for a while: running VMs,
running Docker, compiling Go, running Node.js kills any battery. So I
moved my development into the cloud and gained on battery life and
network speeds at the cost of memory (I am paying for 4GB of RAM).&lt;/p&gt;
&lt;p&gt;My ideal replacement was a cheaper machine that felt as good as a 2015
Macbook Pro. (The build quality has not been good since.) I was
hoping not to pay more than $1000. My shortlist included the Surface
Book 2, the Surface Pro X, the Surface Laptop 3, the Lenovo Yoga 14,
and the LG Gram. So I went to Best Buy to try them out.&lt;/p&gt;
&lt;p&gt;I was impressed by every Surface device. At first sight, I mistook the
Surface Book and Surface Laptop for an old Macbook Pro. They both have
a brushed aluminum body with a large trackpad and great
keyboards. Even the Surface Pro X, which is a tablet, has an addon
keyboard that is easy to type (that is, program) on.&lt;/p&gt;
&lt;p&gt;I tried out the Lenovo Yoga 14 and it was solid, but I preferred the
brushed aluminum body of the Surface devices. I did not get a chance
to feel out the LG Gram.&lt;/p&gt;
&lt;p&gt;I eliminated the Surface Laptop 3 because I like tablet mode. While
the Surface Laptop 3 is a touchscreen, it is not a 2-in-1 device and
does not have tablet mode.&lt;/p&gt;
&lt;p&gt;And I eliminated the Surface Pro X because it is one of the first
mainstream Windows ARM devices. While Windows on ARM is now the same
operating system as Windows on a desktop, most consumer software ships
x86_64 (not ARM) binaries. Windows on ARM can emulate x86 but not yet
x86_64. I didn't feel like working around this on my primary personal
device.&lt;/p&gt;
&lt;p&gt;I bought the 13.5", 7th generation i5 Surface Book 2 for $999. It
comes with 8GB DDR4 RAM and a 128GB SSD. I have had the device for two
weeks now and I use it at least 10 hours a day.&lt;/p&gt;
&lt;h3 id="keyboard"&gt;Keyboard&lt;/h3&gt;&lt;p&gt;The keyboard layout is standard, easy to use. The control, shift,
caps, function, and alt keys are big enough that it is easy to program
without staring at the keyboard. The up and down arrow keys are
smaller than would be nice. But they are easier for me to find than on
a 2019 Macbook Pro.&lt;/p&gt;
&lt;p&gt;The function key is modal by default (like a Caps key) and indicates
if function is enabled with a small LED. I have never seen a function
key like this. I find it annoying when I turn it on.&lt;/p&gt;
&lt;p&gt;And while there is builtin volume controls and a play/pause button,
there is no media forward/back button. I assigned
Ctrl+Windows+Alt+Left/Right to be media forward/back.&lt;/p&gt;
&lt;p&gt;There is also no right Ctrl key. Instead there is a "media key" which is
the equivalent of right-clicking... I guess. This is useless so I
mapped it back to another Ctrl key.&lt;/p&gt;
&lt;p&gt;Unlike macOS, which needs an app like Spectacle, Windows default
window control shortcuts are great. Windows+Left to send to the left
half, Windows+Right to send to the right half, Windows+Up to make full
screen.&lt;/p&gt;
&lt;p&gt;But macOS default swipe gestures are more intuitive: swipe left to go
backwards, swipe right to go forwards. So I mapped this back myself.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/eatonphil/0a684561d599fcd94128ff462a5253b7"&gt;Here is my autohotkey
script.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="screen"&gt;Screen&lt;/h3&gt;&lt;p&gt;The 13.5" screen feels top-heavy but may not actually weigh more than
the keyboard/body. The bevel is larger than it feels like it should
be. But the camera is in the right location: top and center.&lt;/p&gt;
&lt;p&gt;Additionally, the default behavior when attaching/detaching the screen
is to prompt you to enter/exit tablet mode rather than doing it for
you. This prompt is easy to click out of and after doing so the option
to switch between disappears until you reattach and detach again.&lt;/p&gt;
&lt;p&gt;The screen isn't flush with the body when you close it. Few marketing
pictures show you this, but here's
&lt;a href="https://assets.pcmag.com/media/images/563021-microsoft-surface-book-2-15-inch.jpg?thumb=y"&gt;one&lt;/a&gt;. This
makes me worry something may snap if the laptop is ever slammed
against a wall for some reason.&lt;/p&gt;
&lt;p&gt;And fully open, it only goes back 120 degrees. This makes it hard to
look at if it is on your legs and your legs are up higher than 90
degrees.&lt;/p&gt;
&lt;p&gt;Finally, the headphone jack is not on the body but on the screen. This
makes sense since the screen is detachable. But the jack is on the
top-right corner, further away than usual. This requires me to be
closer to the screen to feel like I am not pulling the screen when I
am wearing headphones.&lt;/p&gt;
&lt;h4 id="pen"&gt;Pen&lt;/h4&gt;&lt;p&gt;The Surface Pen is awesome and the screen's palm detection is too. I
have had a lot of fun drawing on it in Paint 3. And it has been useful
in annotating mockups for work too.&lt;/p&gt;
&lt;p&gt;It costs $100 and comes with a AAAA battery. It is magnetized and
sticks to the left side of the screen.&lt;/p&gt;
&lt;h3 id="body"&gt;Body&lt;/h3&gt;&lt;p&gt;As mentioned, the body is a brushed aluminum. It feels great. The
power input is magnetic, which is helpful. But it uses a novel
Surface-specific input rather than USB-C, so that sucks. A new charger
from Microsoft costs $100.&lt;/p&gt;
&lt;p&gt;The speakers are as good as Macbook speakers were 5 years ago.
They don't have much bass. Additionally, these speakers get a little
distorted at top volume.&lt;/p&gt;
&lt;p&gt;The battery lasts 7-8 hours without charging. While this is as
advertised, it is still disappointing of a new laptop in 2020 that is
only running Chrome, Spotify, and Windows Terminal.&lt;/p&gt;
&lt;h4 id="tablet"&gt;Tablet&lt;/h4&gt;&lt;p&gt;To release the screen from the body, there is a key on the function
row. However, it is not a hardware release. So when I accidentally
killed the battery while the screen was flipped, I couldn't detach the
screen after booting (to turn it back into a laptop) until after 10-20
minutes of charging.&lt;/p&gt;
&lt;p&gt;The screen isn't easy to detach. It requires both hands lifting up
from the base of the screen to get enough leverage. You cannot pull up
from the top of the screen.&lt;/p&gt;
&lt;p&gt;Aside from drawing apps, tablet mode apps on Windows aren't
great. Kindle for Windows on tablet is terrible. I got stuck in
Kindle's full screen mode and couldn't adjust the page size or exit
full screen mode without reverting back to laptop mode first.&lt;/p&gt;
&lt;p&gt;Tablet mode also throws away the standard Windows menu and shortcuts
to give you a desktop of application cards. However, these cards don't
adapt to recent or frequent applications. After I deleted Candy Crush
and other built in apps I will never use, this desktop is blank except
for Edge and Groove Music. It is incredible how bad the tablet desktop
is. You have to use the full application list view every time you want
to open a new program.&lt;/p&gt;
&lt;h3 id="in-summary"&gt;In summary&lt;/h3&gt;&lt;p&gt;It's not a bad Windows machine for $1000. The body is great quality
and the pen/screen interaction is solid. But I'd like to see Windows
invest more in a useful tablet experience. And the detachable screen
comes at the cost of being a awkward. So I'd go with the Surface Pro X
or Surface Laptop 3 next time.&lt;/p&gt;
&lt;p&gt;But above all I can't shake the expectation that a laptop built in
2020 running GMail and Slack in Chrome, Spotify, and a terminal
application should last at least 10 hours.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Wrote a short post reviewing Microsoft&amp;#39;s Surface Book 2&lt;a href="https://t.co/0n6K3y6FBC"&gt;https://t.co/0n6K3y6FBC&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1241503107806384133?ref_src=twsrc%5Etfw"&gt;March 21, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/reviewing-the-surface-book-2.html</guid><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate></item><item><title>Writing a SQL database from scratch in Go: 1. SELECT, INSERT, CREATE and a REPL</title><link>http://notes.eatonphil.com/database-basics.html</link><description>&lt;p class="note"&gt;
  Next in database basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-expressions-and-where.html"&gt;2. binary expressions and WHERE filters&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-indexes.html"&gt;3. indexes&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/database-basics-a-database-sql-driver.html"&gt;4. a database/sql driver&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this series we'll write a rudimentary database from
scratch in Go. Project source code is available on
&lt;a href="https://github.com/eatonphil/gosql"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this first post we'll build enough of a parser to run some simple
&lt;code&gt;CREATE&lt;/code&gt;, &lt;code&gt;INSERT&lt;/code&gt;, and &lt;code&gt;SELECT&lt;/code&gt;
queries. Then we'll build an in-memory backend
supporting &lt;code&gt;TEXT&lt;/code&gt; and &lt;code&gt;INT&lt;/code&gt; types and write a
basic REPL.&lt;/p&gt;
&lt;p&gt;We'll be able to support the following interaction:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;$ go run *.go
Welcome to gosql.
# CREATE TABLE users (id INT, name TEXT);
ok
# INSERT INTO users VALUES (1, &amp;#39;Phil&amp;#39;);
ok
# SELECT id, name FROM users;
| id | name |
====================
| 1 |  Phil |
ok
# INSERT INTO users VALUES (2, &amp;#39;Kate&amp;#39;);
ok
# SELECT name, id FROM users;
| name | id |
====================
| Phil |  1 |
| Kate |  2 |
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first stage will be to map a SQL source into a list of tokens
(lexing). Then we'll call parse functions to find individual SQL
statements (such as &lt;code&gt;SELECT&lt;/code&gt;). These parse functions will
in turn call their own helper functions to find patterns of
recursively parseable chunks, keywords, symbols (like parenthesis),
identifiers (like a table name), and numeric or string literals.&lt;/p&gt;
&lt;p&gt;Then, we'll write an in-memory backend to do operations based on an
AST. Finally, we'll write a REPL to accept SQL from a CLI and pass it
to the in-memory backend.&lt;/p&gt;
&lt;p class="note"&gt;
  This post assumes a basic understanding of parsing concepts. We
  won't skip any code, but also won't go into great detail on why we
  structure the way we do.
  &lt;br /&gt;
  &lt;br /&gt;
  For a simpler introduction to parsing and parsing concepts,
  see &lt;a href="/writing-a-simple-json-parser.html"&gt;this post on
  parsing JSON&lt;/a&gt;.
&lt;/p&gt;&lt;h3 id="lexing"&gt;Lexing&lt;/h3&gt;&lt;p&gt;The lexer is responsible for finding every distinct group of
characters in source code: tokens. This will consist primarily of
identifiers, numbers, strings, and symbols.&lt;/p&gt;
&lt;p class="note"&gt;
  What follows is a second, more orthodox pass at lexing. The first
  pass took a number of shortcuts and couldn't handle spaces in
  strings, for example.
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;a href="https://github.com/eatonphil/gosql/pull/2"&gt;Here is the
  relevant pull request in gosql if you are curious.&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;The gist of the logic will be to pass control to a helper function for
each kind of token. If the helper function succeeds in finding a
token, it will return true and the location for the lexer to start at
next. It will continue doing this until it reaches the end of the
source.&lt;/p&gt;
&lt;p&gt;First off, we'll define a few types and constants for use
in &lt;code&gt;lexer.go&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package gosql

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;strings&amp;quot;
)

type location struct {
    line uint
    col  uint
}

type keyword string

const (
    selectKeyword keyword = &amp;quot;select&amp;quot;
    fromKeyword   keyword = &amp;quot;from&amp;quot;
    asKeyword     keyword = &amp;quot;as&amp;quot;
    tableKeyword  keyword = &amp;quot;table&amp;quot;
    createKeyword keyword = &amp;quot;create&amp;quot;
    insertKeyword keyword = &amp;quot;insert&amp;quot;
    intoKeyword   keyword = &amp;quot;into&amp;quot;
    valuesKeyword keyword = &amp;quot;values&amp;quot;
    intKeyword    keyword = &amp;quot;int&amp;quot;
    textKeyword   keyword = &amp;quot;text&amp;quot;
)

type symbol string

const (
    semicolonSymbol  symbol = &amp;quot;;&amp;quot;
    asteriskSymbol   symbol = &amp;quot;*&amp;quot;
    commaSymbol      symbol = &amp;quot;,&amp;quot;
    leftparenSymbol  symbol = &amp;quot;(&amp;quot;
    rightparenSymbol symbol = &amp;quot;)&amp;quot;
)

type tokenKind uint

const (
    keywordKind tokenKind = iota
    symbolKind
    identifierKind
    stringKind
    numericKind
)

type token struct {
    value string
    kind  tokenKind
    loc   location
}

type cursor struct {
    pointer uint
    loc     location
}

func (t *token) equals(other *token) bool {
    return t.value == other.value &amp;amp;&amp;amp; t.kind == other.kind
}

type lexer func(string, cursor) (*token, cursor, bool)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll write out the main loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lex(source string) ([]*token, error) {
    tokens := []*token{}
    cur := cursor{}

lex:
    for cur.pointer &amp;lt; uint(len(source)) {
        lexers := []lexer{lexKeyword, lexSymbol, lexString, lexNumeric, lexIdentifier}
        for _, l := range lexers {
            if token, newCursor, ok := l(source, cur); ok {
                cur = newCursor

                // Omit nil tokens for valid, but empty syntax like newlines
                if token != nil {
                    tokens = append(tokens, token)
                }

                continue lex
            }
        }

        hint := &amp;quot;&amp;quot;
        if len(tokens) &amp;gt; 0 {
            hint = &amp;quot; after &amp;quot; + tokens[len(tokens)-1].value
        }
        return nil, fmt.Errorf(&amp;quot;Unable to lex token%s, at %d:%d&amp;quot;, hint, cur.loc.line, cur.loc.col)
    }

    return tokens, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we'll write a helper for each kind of fundemental token.&lt;/p&gt;
&lt;h4 id="analyzing-numbers"&gt;Analyzing numbers&lt;/h4&gt;&lt;p&gt;Numbers are the most complex. So we'll refer to the &lt;a href="https://www.postgresql.org/docs/current/sql-syntax-lexical.html"&gt;PostgreSQL
documentation (section
4.1.2.6)&lt;/a&gt;
for what constitutes a valid number.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lexNumeric(source string, ic cursor) (*token, cursor, bool) {
    cur := ic

    periodFound := false
    expMarkerFound := false

    for ; cur.pointer &amp;lt; uint(len(source)); cur.pointer++ {
        c := source[cur.pointer]
        cur.loc.col++

        isDigit := c &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;9&amp;#39;
        isPeriod := c == &amp;#39;.&amp;#39;
        isExpMarker := c == &amp;#39;e&amp;#39;

        // Must start with a digit or period
        if cur.pointer == ic.pointer {
            if !isDigit &amp;amp;&amp;amp; !isPeriod {
                return nil, ic, false
            }

            periodFound = isPeriod
            continue
        }

        if isPeriod {
            if periodFound {
                return nil, ic, false
            }

            periodFound = true
            continue
        }

        if isExpMarker {
            if expMarkerFound {
                return nil, ic, false
            }

            // No periods allowed after expMarker
            periodFound = true
            expMarkerFound = true

            // expMarker must be followed by digits
            if cur.pointer == uint(len(source)-1) {
                return nil, ic, false
            }

            cNext := source[cur.pointer+1]
            if cNext == &amp;#39;-&amp;#39; || cNext == &amp;#39;+&amp;#39; {
                cur.pointer++
                cur.loc.col++
            }

            continue
        }

        if !isDigit {
            break
        }
    }

    // No characters accumulated
    if cur.pointer == ic.pointer {
        return nil, ic, false
    }

    return &amp;amp;token{
        value: source[ic.pointer:cur.pointer],
        loc:   ic.loc,
        kind:  numericKind,
    }, cur, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="analyzing-strings"&gt;Analyzing strings&lt;/h4&gt;&lt;p&gt;Strings must start and end with a single apostrophe. They can contain
a single apostophe if it is followed by another single
apostrophe. We'll put this kind of character delimited lexing logic
into a helper function so we can use it again when analyzing
identifiers.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lexCharacterDelimited(source string, ic cursor, delimiter byte) (*token, cursor, bool) {
    cur := ic

    if len(source[cur.pointer:]) == 0 {
        return nil, ic, false
    }

    if source[cur.pointer] != delimiter {
        return nil, ic, false
    }

    cur.loc.col++
    cur.pointer++

    var value []byte
    for ; cur.pointer &amp;lt; uint(len(source)); cur.pointer++ {
        c := source[cur.pointer]

        if c == delimiter {
            // SQL escapes are via double characters, not backslash.
            if cur.pointer+1 &amp;gt;= uint(len(source)) || source[cur.pointer+1] != delimiter {
                return &amp;amp;token{
                    value: string(value),
                    loc:   ic.loc,
                    kind:  stringKind,
                }, cur, true
            } else {
                value = append(value, delimiter)
                cur.pointer++
                cur.loc.col++
            }
        }

        value = append(value, c)
        cur.loc.col++
    }

    return nil, ic, false
}

func lexString(source string, ic cursor) (*token, cursor, bool) {
    return lexCharacterDelimited(source, ic, &amp;#39;\&amp;#39;&amp;#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="analyzing-symbols-and-keywords"&gt;Analyzing symbols and keywords&lt;/h4&gt;&lt;p&gt;Symbols come from a fixed set of strings, so they're easy
to compare against. Whitespace should be thrown away.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lexSymbol(source string, ic cursor) (*token, cursor, bool) {
    c := source[ic.pointer]
    cur := ic
    // Will get overwritten later if not an ignored syntax
    cur.pointer++
    cur.loc.col++

    switch c {
    // Syntax that should be thrown away
    case &amp;#39;\n&amp;#39;:
        cur.loc.line++
        cur.loc.col = 0
        fallthrough
    case &amp;#39;\t&amp;#39;:
        fallthrough
    case &amp;#39; &amp;#39;:
        return nil, cur, true
    }

    // Syntax that should be kept
    symbols := []symbol{
        commaSymbol,
        leftParenSymbol,
        rightParenSymbol,
        semicolonSymbol,
        asteriskSymbol,
    }

    var options []string
    for _, s := range symbols {
        options = append(options, string(s))
    }

    // Use `ic`, not `cur`
    match := longestMatch(source, ic, options)
    // Unknown character
    if match == &amp;quot;&amp;quot; {
        return nil, ic, false
    }

    cur.pointer = ic.pointer + uint(len(match))
    cur.loc.col = ic.loc.col + uint(len(match))

    return &amp;amp;token{
        value: match,
        loc:   ic.loc,
        kind:  symbolKind,
    }, cur, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Keywords are even simpler, and use the same &lt;code&gt;longestMatch&lt;/code&gt;
helper.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lexKeyword(source string, ic cursor) (*token, cursor, bool) {
    cur := ic
    keywords := []keyword{
        selectKeyword,
        insertKeyword,
        valuesKeyword,
        tableKeyword,
        createKeyword,
        whereKeyword,
        fromKeyword,
        intoKeyword,
        textKeyword,
    }

    var options []string
    for _, k := range keywords {
        options = append(options, string(k))
    }

    match := longestMatch(source, ic, options)
    if match == &amp;quot;&amp;quot; {
        return nil, ic, false
    }

    cur.pointer = ic.pointer + uint(len(match))
    cur.loc.col = ic.loc.col + uint(len(match))

    return &amp;amp;token{
        value: match,
        kind:  kind,
        loc:   ic.loc,
    }, cur, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally we implement the &lt;code&gt;longestMatch&lt;/code&gt; helper:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;// longestMatch iterates through a source string starting at the given
// cursor to find the longest matching substring among the provided
// options
func longestMatch(source string, ic cursor, options []string) string {
    var value []byte
    var skipList []int
    var match string

    cur := ic

    for cur.pointer &amp;lt; uint(len(source)) {

        value = append(value, strings.ToLower(string(source[cur.pointer]))...)
        cur.pointer++

    match:
        for i, option := range options {
            for _, skip := range skipList {
                if i == skip {
                    continue match
                }
            }

            // Deal with cases like INT vs INTO
            if option == string(value) {
                skipList = append(skipList, i)
                if len(option) &amp;gt; len(match) {
                    match = option
                }

                continue
            }

            sharesPrefix := string(value) == option[:cur.pointer-ic.pointer]
            tooLong := len(value) &amp;gt; len(option)
            if tooLong || !sharesPrefix {
                skipList = append(skipList, i)
            }
        }

        if len(skipList) == len(options) {
            break
        }
    }

    return match
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="analyzing-identifiers"&gt;Analyzing identifiers&lt;/h4&gt;&lt;p&gt;An identifier is either a double-quoted string or a group of
characters starting with an alphabetical character and possibly
containing numbers and underscores.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func lexIdentifier(source string, ic cursor) (*token, cursor, bool) {
    // Handle separately if is a double-quoted identifier
    if token, newCursor, ok := lexCharacterDelimited(source, ic, &amp;#39;&amp;quot;&amp;#39;); ok {
        return token, newCursor, true
    }

    cur := ic

    c := source[cur.pointer]
    // Other characters count too, big ignoring non-ascii for now
    isAlphabetical := (c &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39;) || (c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;)
    if !isAlphabetical {
        return nil, ic, false
    }
    cur.pointer++
    cur.loc.col++

    value := []byte{c}
    for ; cur.pointer &amp;lt; uint(len(source)); cur.pointer++ {
        c = source[cur.pointer]

        // Other characters count too, big ignoring non-ascii for now
        isAlphabetical := (c &amp;gt;= &amp;#39;A&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;Z&amp;#39;) || (c &amp;gt;= &amp;#39;a&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;z&amp;#39;)
        isNumeric := c &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; c &amp;lt;= &amp;#39;9&amp;#39;
        if isAlphabetical || isNumeric || c == &amp;#39;$&amp;#39; || c == &amp;#39;_&amp;#39; {
            value = append(value, c)
            cur.loc.col++
            continue
        }

        break
    }

    if len(value) == 0 {
        return nil, ic, false
    }

    return &amp;amp;token{
        // Unquoted dentifiers are case-insensitive
        value: strings.ToLower(string(value)),
        loc:   ic.loc,
        kind:  identifierKind,
    }, cur, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for the lexer! If you copy
&lt;a href="https://github.com/eatonphil/gosql/blob/master/lexer_test.go"&gt;lexer_test.go&lt;/a&gt;
from the main project, the tests should now pass.&lt;/p&gt;
&lt;h3 id="ast-model"&gt;AST model&lt;/h3&gt;&lt;p&gt;At the highest level, an AST is a collection of statements:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

type Ast struct {
    Statements []*Statement
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A statement, for now, is one of &lt;code&gt;INSERT&lt;/code&gt;,
&lt;code&gt;CREATE&lt;/code&gt;, or &lt;code&gt;SELECT&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type AstKind uint

const (
    SelectKind AstKind = iota
    CreateTableKind
    InsertKind
)

type Statement struct {
    SelectStatement      *SelectStatement
    CreateTableStatement *CreateTableStatement
    InsertStatement      *InsertStatement
    Kind                 AstKind
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="insert"&gt;INSERT&lt;/h4&gt;&lt;p&gt;An insert statement, for now, has a table name and a list of values to
insert:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type InsertStatement struct {
    table  token
    values *[]*expression
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An expression is a literal token or (in the future) a function call or
inline operation:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type expressionKind uint

const (
    literalKind expressionKind = iota
)

type expression struct {
    literal *token
    kind    expressionKind
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="create"&gt;CREATE&lt;/h4&gt;&lt;p&gt;A create statement, for now, has a table name and a list of column
names and types:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type columnDefinition struct {
    name     token
    datatype token
}

type CreateTableStatement struct {
    name token
    cols *[]*columnDefinition
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="select"&gt;SELECT&lt;/h4&gt;&lt;p&gt;A select statement, for now, has a table name and a list of column
names:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;type SelectStatement struct {
    item []*expression
    from token
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for the AST.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Parse&lt;/code&gt; entrypoint will take a list of tokens and
attempt to parse statements, separated by a semi-colon, until it
reaches the last token.&lt;/p&gt;
&lt;p&gt;In general our strategy will be to increment and pass around a cursor
containing the current position of unparsed tokens. Each helper will
return the new cursor that the caller should start from.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;errors&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func tokenFromKeyword(k keyword) token {
    return token{
        kind:  keywordKind,
        value: string(k),
    }
}

func tokenFromSymbol(s symbol) token {
    return token{
        kind:  symbolKind,
        value: string(s),
    }
}

func expectToken(tokens []*token, cursor uint, t token) bool {
    if cursor &amp;gt;= uint(len(tokens)) {
        return false
    }

    return t.equals(tokens[cursor])
}

func helpMessage(tokens []*token, cursor uint, msg string) {
    var c *token
    if cursor &amp;lt; uint(len(tokens)) {
        c = tokens[cursor]
    } else {
        c = tokens[cursor-1]
    }

    fmt.Printf(&amp;quot;[%d,%d]: %s, got: %s\n&amp;quot;, c.loc.line, c.loc.col, msg, c.value)
}

func Parse(source string) (*Ast, error) {
    tokens, err := lex(source)
    if err != nil {
        return nil, err
    }

    a := Ast{}
    cursor := uint(0)
    for cursor &amp;lt; uint(len(tokens)) {
        stmt, newCursor, ok := parseStatement(tokens, cursor, tokenFromSymbol(semicolonSymbol))
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected statement&amp;quot;)
            return nil, errors.New(&amp;quot;Failed to parse, expected statement&amp;quot;)
        }
        cursor = newCursor

        a.Statements = append(a.Statements, stmt)

        atLeastOneSemicolon := false
        for expectToken(tokens, cursor, tokenFromSymbol(semicolonSymbol)) {
            cursor++
            atLeastOneSemicolon = true
        }

        if !atLeastOneSemicolon {
            helpMessage(tokens, cursor, &amp;quot;Expected semi-colon delimiter between statements&amp;quot;)
            return nil, errors.New(&amp;quot;Missing semi-colon between statements&amp;quot;)
        }
    }

    return &amp;amp;a, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="parsing-statements"&gt;Parsing statements&lt;/h4&gt;&lt;p&gt;Each statement will be one of &lt;code&gt;INSERT&lt;/code&gt;,
&lt;code&gt;CREATE&lt;/code&gt;, or &lt;code&gt;SELECT&lt;/code&gt;. The
&lt;code&gt;parseStatement&lt;/code&gt; helper will call a helper on each of these
statement types and return &lt;code&gt;true&lt;/code&gt; if one of them succeeds
in parsing.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseStatement(tokens []*token, initialCursor uint, delimiter token) (*Statement, uint, bool) {
    cursor := initialCursor

    // Look for a SELECT statement
    semicolonToken := tokenFromSymbol(semicolonSymbol)
    slct, newCursor, ok := parseSelectStatement(tokens, cursor, semicolonToken)
    if ok {
        return &amp;amp;Statement{
            Kind:            SelectKind,
            SelectStatement: slct,
        }, newCursor, true
    }

    // Look for a INSERT statement
    inst, newCursor, ok := parseInsertStatement(tokens, cursor, semicolonToken)
    if ok {
        return &amp;amp;Statement{
            Kind:            InsertKind,
            InsertStatement: inst,
        }, newCursor, true
    }

    // Look for a CREATE statement
    crtTbl, newCursor, ok := parseCreateTableStatement(tokens, cursor, semicolonToken)
    if ok {
        return &amp;amp;Statement{
            Kind:                 CreateTableKind,
            CreateTableStatement: crtTbl,
        }, newCursor, true
    }

    return nil, initialCursor, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="parsing-select-statements"&gt;Parsing select statements&lt;/h4&gt;&lt;p&gt;Parsing &lt;code&gt;SELECT&lt;/code&gt; statements is easy. We'll look for the
following token pattern:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SELECT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$expression [, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$table-name&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Sketching that out we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseSelectStatement(tokens []*token, initialCursor uint, delimiter token) (*SelectStatement, uint, bool) {
    cursor := initialCursor
    if !expectToken(tokens, cursor, tokenFromKeyword(selectKeyword)) {
        return nil, initialCursor, false
    }
    cursor++

    slct := SelectStatement{}

    exps, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromKeyword(fromKeyword), delimiter})
    if !ok {
        return nil, initialCursor, false
    }

    slct.item = *exps
    cursor = newCursor

    if expectToken(tokens, cursor, tokenFromKeyword(fromKeyword)) {
        cursor++

        from, newCursor, ok := parseToken(tokens, cursor, identifierKind)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected FROM token&amp;quot;)
            return nil, initialCursor, false
        }

        slct.from = *from
        cursor = newCursor
    }

    return &amp;amp;slct, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parseToken&lt;/code&gt; helper will look for a token of a
particular token kind.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseToken(tokens []*token, initialCursor uint, kind tokenKind) (*token, uint, bool) {
    cursor := initialCursor

    if cursor &amp;gt;= uint(len(tokens)) {
        return nil, initialCursor, false
    }

    current := tokens[cursor]
    if current.kind == kind {
        return current, cursor + 1, true
    }

    return nil, initialCursor, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parseExpressions&lt;/code&gt; helper will look for tokens
separated by a comma until a delimiter is found. It will use existing
helpers plus &lt;code&gt;parseExpression&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseExpressions(tokens []*token, initialCursor uint, delimiters []token) (*[]*expression, uint, bool) {
    cursor := initialCursor

    exps := []*expression{}
outer:
    for {
        if cursor &amp;gt;= uint(len(tokens)) {
            return nil, initialCursor, false
        }

        // Look for delimiter
        current := tokens[cursor]
        for _, delimiter := range delimiters {
            if delimiter.equals(current) {
                break outer
            }
        }

        // Look for comma
        if len(exps) &amp;gt; 0 {
            if !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {
                helpMessage(tokens, cursor, &amp;quot;Expected comma&amp;quot;)
                return nil, initialCursor, false
            }

            cursor++
        }

        // Look for expression
        exp, newCursor, ok := parseExpression(tokens, cursor, tokenFromSymbol(commaSymbol))
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected expression&amp;quot;)
            return nil, initialCursor, false
        }
        cursor = newCursor

        exps = append(exps, exp)
    }

    return &amp;amp;exps, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parseExpression&lt;/code&gt; helper (for now) will look for a
numeric, string, or identifier token.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseExpression(tokens []*token, initialCursor uint, _ token) (*expression, uint, bool) {
    cursor := initialCursor

    kinds := []tokenKind{identifierKind, numericKind, stringKind}
    for _, kind := range kinds {
        t, newCursor, ok := parseToken(tokens, cursor, kind)
        if ok {
            return &amp;amp;expression{
                literal: t,
                kind:    literalKind,
            }, newCursor, true
        }
    }

    return nil, initialCursor, false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for parsing a &lt;code&gt;SELECT&lt;/code&gt; statement!&lt;/p&gt;
&lt;h4 id="parsing-insert-statements"&gt;Parsing insert statements&lt;/h4&gt;&lt;p&gt;We'll look for the following token pattern:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;INSERT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INTO&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$table-name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VALUES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$expression [, ...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With the existing helpers, this is straightforward to sketch out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseInsertStatement(tokens []*token, initialCursor uint, delimiter token) (*InsertStatement, uint, bool) {
    cursor := initialCursor

    // Look for INSERT
    if !expectToken(tokens, cursor, tokenFromKeyword(insertKeyword)) {
        return nil, initialCursor, false
    }
    cursor++

    // Look for INTO
    if !expectToken(tokens, cursor, tokenFromKeyword(intoKeyword)) {
        helpMessage(tokens, cursor, &amp;quot;Expected into&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    // Look for table name
    table, newCursor, ok := parseToken(tokens, cursor, identifierKind)
    if !ok {
        helpMessage(tokens, cursor, &amp;quot;Expected table name&amp;quot;)
        return nil, initialCursor, false
    }
    cursor = newCursor

    // Look for VALUES
    if !expectToken(tokens, cursor, tokenFromKeyword(valuesKeyword)) {
        helpMessage(tokens, cursor, &amp;quot;Expected VALUES&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    // Look for left paren
    if !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {
        helpMessage(tokens, cursor, &amp;quot;Expected left paren&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    // Look for expression list
    values, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromSymbol(rightparenSymbol)})
    if !ok {
        return nil, initialCursor, false
    }
    cursor = newCursor

    // Look for right paren
    if !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {
        helpMessage(tokens, cursor, &amp;quot;Expected right paren&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    return &amp;amp;InsertStatement{
        table:  *table,
        values: values,
    }, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for parsing an &lt;code&gt;INSERT&lt;/code&gt; statement!&lt;/p&gt;
&lt;h4 id="parsing-create-statements"&gt;Parsing create statements&lt;/h4&gt;&lt;p&gt;Finally, for create statements we'll look for the following token
pattern:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;CREATE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$table-name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;(&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[$column-name $column-type [, ...]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Sketching that out with a new &lt;code&gt;parseColumnDefinitions&lt;/code&gt;
helper we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseCreateTableStatement(tokens []*token, initialCursor uint, delimiter token) (*CreateTableStatement, uint, bool) {
    cursor := initialCursor

    if !expectToken(tokens, cursor, tokenFromKeyword(createKeyword)) {
        return nil, initialCursor, false
    }
    cursor++

    if !expectToken(tokens, cursor, tokenFromKeyword(tableKeyword)) {
        return nil, initialCursor, false
    }
    cursor++

    name, newCursor, ok := parseToken(tokens, cursor, identifierKind)
    if !ok {
        helpMessage(tokens, cursor, &amp;quot;Expected table name&amp;quot;)
        return nil, initialCursor, false
    }
    cursor = newCursor

    if !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {
        helpMessage(tokens, cursor, &amp;quot;Expected left parenthesis&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    cols, newCursor, ok := parseColumnDefinitions(tokens, cursor, tokenFromSymbol(rightparenSymbol))
    if !ok {
        return nil, initialCursor, false
    }
    cursor = newCursor

    if !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {
        helpMessage(tokens, cursor, &amp;quot;Expected right parenthesis&amp;quot;)
        return nil, initialCursor, false
    }
    cursor++

    return &amp;amp;CreateTableStatement{
        name: *name,
        cols: cols,
    }, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parseColumnDefinitions&lt;/code&gt; helper will look column names
followed by column types separated by a comma and ending with some
delimiter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func parseColumnDefinitions(tokens []*token, initialCursor uint, delimiter token) (*[]*columnDefinition, uint, bool) {
    cursor := initialCursor

    cds := []*columnDefinition{}
    for {
        if cursor &amp;gt;= uint(len(tokens)) {
            return nil, initialCursor, false
        }

        // Look for a delimiter
        current := tokens[cursor]
        if delimiter.equals(current) {
            break
        }

        // Look for a comma
        if len(cds) &amp;gt; 0 {
            if !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {
                helpMessage(tokens, cursor, &amp;quot;Expected comma&amp;quot;)
                return nil, initialCursor, false
            }

            cursor++
        }

        // Look for a column name
        id, newCursor, ok := parseToken(tokens, cursor, identifierKind)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected column name&amp;quot;)
            return nil, initialCursor, false
        }
        cursor = newCursor

        // Look for a column type
        ty, newCursor, ok := parseToken(tokens, cursor, keywordKind)
        if !ok {
            helpMessage(tokens, cursor, &amp;quot;Expected column type&amp;quot;)
            return nil, initialCursor, false
        }
        cursor = newCursor

        cds = append(cds, &amp;amp;columnDefinition{
            name:     *id,
            datatype: *ty,
        })
    }

    return &amp;amp;cds, cursor, true
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for parsing! If you copy
&lt;a href="https://github.com/eatonphil/gosql/blob/master/parser_test.go"&gt;parser_test.go&lt;/a&gt;
from the main project, the tests should now pass.&lt;/p&gt;
&lt;h3 id="an-in-memory-backend"&gt;An in-memory backend&lt;/h3&gt;&lt;p&gt;Our in-memory backend should conform to a general backend interface
that allows a user to create, select, and insert data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import &amp;quot;errors&amp;quot;

type ColumnType uint

const (
    TextType ColumnType = iota
    IntType
)

type Cell interface {
    AsText() string
    AsInt() int32
}

type Results struct {
    Columns []struct {
        Type ColumnType
        Name string
    }
    Rows [][]Cell
}

var (
    ErrTableDoesNotExist  = errors.New(&amp;quot;Table does not exist&amp;quot;)
    ErrColumnDoesNotExist = errors.New(&amp;quot;Column does not exist&amp;quot;)
    ErrInvalidSelectItem  = errors.New(&amp;quot;Select item is not valid&amp;quot;)
    ErrInvalidDatatype    = errors.New(&amp;quot;Invalid datatype&amp;quot;)
    ErrMissingValues      = errors.New(&amp;quot;Missing values&amp;quot;)
)

type Backend interface {
    CreateTable(*CreateTableStatement) error
    Insert(*InsertStatement) error
    Select(*SelectStatement) (*Results, error)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This leaves us room in the future for a disk-backed backend.&lt;/p&gt;
&lt;h4 id="memory-layout"&gt;Memory layout&lt;/h4&gt;&lt;p&gt;Our in-memory backend should store a list of tables. Each table
will have a list of columns and rows. Each column will have a name and
type. Each row will have a list of byte arrays.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;encoding/binary&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;strconv&amp;quot;
)

type MemoryCell []byte

func (mc MemoryCell) AsInt() int32 {
    var i int32
    err := binary.Read(bytes.NewBuffer(mc), binary.BigEndian, &amp;amp;i)
    if err != nil {
        panic(err)
    }

    return i
}

func (mc MemoryCell) AsText() string {
    return string(mc)
}

type table struct {
    columns     []string
    columnTypes []ColumnType
    rows        [][]MemoryCell
}

type MemoryBackend struct {
    tables map[string]*table
}

func NewMemoryBackend() *MemoryBackend {
    return &amp;amp;MemoryBackend{
        tables: map[string]*table{},
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="implementing-create-table-support"&gt;Implementing create table support&lt;/h4&gt;&lt;p&gt;When creating a table, we'll make a new entry in the backend tables
map. Then we'll create columns as specified by the AST.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {
    t := table{}
    mb.tables[crt.name.value] = &amp;amp;t
    if crt.cols == nil {

        return nil
    }

    for _, col := range *crt.cols {
        t.columns = append(t.columns, col.name.value)

        var dt ColumnType
        switch col.datatype.value {
        case &amp;quot;int&amp;quot;:
            dt = IntType
        case &amp;quot;text&amp;quot;:
            dt = TextType
        default:
            return ErrInvalidDatatype
        }

        t.columnTypes = append(t.columnTypes, dt)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="implementing-insert-support"&gt;Implementing insert support&lt;/h4&gt;&lt;p&gt;Keeping things simple, we'll assume the value passed can be correctly
mapped to the type of the column specified.&lt;/p&gt;
&lt;p&gt;We'll reference a helper for mapper values to internal storage,
&lt;code&gt;tokenToCell&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) Insert(inst *InsertStatement) error {
    table, ok := mb.tables[inst.table.value]
    if !ok {
        return ErrTableDoesNotExist
    }

    if inst.values == nil {
        return nil
    }

    row := []MemoryCell{}

    if len(*inst.values) != len(table.columns) {
        return ErrMissingValues
    }

    for _, value := range *inst.values {
        if value.kind != literalKind {
            fmt.Println(&amp;quot;Skipping non-literal.&amp;quot;)
            continue
        }

        row = append(row, mb.tokenToCell(value.literal))
    }

    table.rows = append(table.rows, row)
    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;tokenToCell&lt;/code&gt; helper will write numbers as binary bytes
and will write strings as bytes:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;
func (mb *MemoryBackend) tokenToCell(t *token) MemoryCell {
    if t.kind == numericKind {
        buf := new(bytes.Buffer)
        i, err := strconv.Atoi(t.value)
        if err != nil {
            panic(err)
        }

        err = binary.Write(buf, binary.BigEndian, int32(i))
        if err != nil {
            panic(err)
        }
        return MemoryCell(buf.Bytes())
    }

    if t.kind == stringKind {
        return MemoryCell(t.value)
    }

    return nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="implementing-select-support"&gt;Implementing select support&lt;/h4&gt;&lt;p&gt;Finally, for select we'll iterate over each row in the table and
return the cells according to the columns specified by the AST.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;func (mb *MemoryBackend) Select(slct *SelectStatement) (*Results, error) {
    table, ok := mb.tables[slct.from.table]
    if !ok {
        return nil, ErrTableDoesNotExist
    }

    results := [][]Cell{}
    columns := []struct {
        Type ColumnType
        Name string
    }{}

    for i, row := range table.rows {
        result := []Cell{}
        isFirstRow := i == 0

        for _, exp := range slct.item {
            if exp.kind != literalKind {
                // Unsupported, doesn&amp;#39;t currently exist, ignore.
                fmt.Println(&amp;quot;Skipping non-literal expression.&amp;quot;)
                continue
            }

            lit := exp.literal
            if lit.kind == identifierKind {
                found := false
                for i, tableCol := range table.columns {
                    if tableCol == lit.value {
                        if isFirstRow {
                            columns = append(columns, struct {
                                Type ColumnType
                                Name string
                            }{
                                Type: table.columnTypes[i],
                                Name: lit.value,
                            })
                        }

                        result = append(result, row[i])
                        found = true
                        break
                    }
                }

                if !found {
                    return nil, ErrColumnDoesNotExist
                }

                continue
            }

            return nil, ErrColumnDoesNotExist
        }

        results = append(results, result)
    }

    return &amp;amp;Results{
        Columns: columns,
        Rows:    results,
    }, nil
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="the-repl"&gt;The REPL&lt;/h3&gt;&lt;p&gt;At last, we're ready to wrap the parser and in-memory backend in a
REPL. The most complex part is displaying the table of results from a
select query.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs go"&gt;package main

import (
    &amp;quot;bufio&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
    &amp;quot;strings&amp;quot;

    &amp;quot;github.com/eatonphil/gosql&amp;quot;
)

func main() {
    mb := gosql.NewMemoryBackend()

    reader := bufio.NewReader(os.Stdin)
    fmt.Println(&amp;quot;Welcome to gosql.&amp;quot;)
    for {
        fmt.Print(&amp;quot;# &amp;quot;)
        text, err := reader.ReadString(&amp;#39;\n&amp;#39;)
        text = strings.Replace(text, &amp;quot;\n&amp;quot;, &amp;quot;&amp;quot;, -1)

        ast, err := gosql.Parse(text)
        if err != nil {
            panic(err)
        }

        for _, stmt := range ast.Statements {
            switch stmt.Kind {
            case gosql.CreateTableKind:
                err = mb.CreateTable(ast.Statements[0].CreateTableStatement)
                if err != nil {
                    panic(err)
                }
                fmt.Println(&amp;quot;ok&amp;quot;)
            case gosql.InsertKind:
                err = mb.Insert(stmt.InsertStatement)
                if err != nil {
                    panic(err)
                }

                fmt.Println(&amp;quot;ok&amp;quot;)
            case gosql.SelectKind:
                results, err := mb.Select(stmt.SelectStatement)
                if err != nil {
                    panic(err)
                }

                for _, col := range results.Columns {
                    fmt.Printf(&amp;quot;| %s &amp;quot;, col.Name)
                }
                fmt.Println(&amp;quot;|&amp;quot;)

                for i := 0; i &amp;lt; 20; i++ {
                    fmt.Printf(&amp;quot;=&amp;quot;)
                }
                fmt.Println()

                for _, result := range results.Rows {
                    fmt.Printf(&amp;quot;|&amp;quot;)

                    for i, cell := range result {
                        typ := results.Columns[i].Type
                        s := &amp;quot;&amp;quot;
                        switch typ {
                        case gosql.IntType:
                            s = fmt.Sprintf(&amp;quot;%d&amp;quot;, cell.AsInt())
                        case gosql.TextType:
                            s = cell.AsText()
                        }

                        fmt.Printf(&amp;quot; %s | &amp;quot;, s)
                    }

                    fmt.Println()
                }

                fmt.Println(&amp;quot;ok&amp;quot;)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Putting it all together:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go run *.go
Welcome to gosql.
# CREATE TABLE users (id INT, name TEXT);
ok
# INSERT INTO users VALUES (1, &amp;#39;Phil&amp;#39;);
ok
# SELECT id, name FROM users;
| id | name |
====================
| 1 |  Phil |
ok
# INSERT INTO users VALUES (2, &amp;#39;Kate&amp;#39;);
ok
# SELECT name, id FROM users;
| name | id |
====================
| Phil |  1 |
| Kate |  2 |
ok
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we've got a very simple SQL database!&lt;/p&gt;
&lt;p&gt;Next up we'll get into filtering, sorting, and indexing.&lt;/p&gt;
&lt;h4 id="further-reading"&gt;Further reading&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="/writing-a-simple-json-parser.html"&gt;Writing a simple JSON parser&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;This post goes into a little more detail about the theory and basics of parsing.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.goodreads.com/book/show/617120.Database_Systems"&gt;Database Systems: A Practical Approach to Design, Implementation and Management&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;A giant book, but an excellent and very easy introduction to database theory.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet" data-conversation="none"&gt;&lt;p lang="en" dir="ltr"&gt;Latest blog post: writing a simple SQL database from scratch in Go &lt;a href="https://t.co/csQmNhWIEf"&gt;https://t.co/csQmNhWIEf&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1237522975143776256?ref_src=twsrc%5Etfw"&gt;March 10, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/database-basics.html</guid><pubDate>Fri, 06 Mar 2020 00:00:00 +0000</pubDate></item><item><title>A minimal REST API in Java</title><link>http://notes.eatonphil.com/a-minimal-rest-api-in-java.html</link><description>&lt;p&gt;There's a style of Java that is a joy to write. This post will cover
how to set up a basic PostgreSQL-integrated REST API using
&lt;a href="https://eclipse-ee4j.github.io/jersey/"&gt;Jersey&lt;/a&gt; and
&lt;a href="https://www.jooq.org/"&gt;JOOQ&lt;/a&gt; in a style not dissimilar to Flask and
SQLAlchemy in Python.&lt;/p&gt;
&lt;p&gt;In particular, we'll try to avoid as much runtime
reflection/class-loading as possible. This will make the application
less flexible but easier to debug and understand.&lt;/p&gt;
&lt;p&gt;I'd appreciate pointers in email if you see anything weird or can fix
any of my bugs.&lt;/p&gt;
&lt;h3 id="dependencies"&gt;Dependencies&lt;/h3&gt;&lt;p&gt;Install &lt;a href="https://maven.apache.org/"&gt;Maven&lt;/a&gt;, a recent
&lt;a href="https://openjdk.java.net/"&gt;JDK&lt;/a&gt;, and PostgreSQL.&lt;/p&gt;
&lt;p&gt;Copy the following into &lt;code&gt;pom.xml&lt;/code&gt; to tell Maven about Java
dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs xml"&gt;&amp;lt;project xmlns=&amp;quot;http://maven.apache.org/POM/4.0.0&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
         xsi:schemaLocation=&amp;quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;api&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;api&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;13&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;13&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;compilerArgs&amp;gt;
            &amp;lt;arg&amp;gt;-Xlint:all,-options,-path&amp;lt;/arg&amp;gt;
          &amp;lt;/compilerArgs&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;

      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;exec-maven-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.6.0&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;mainClass&amp;gt;api.Main&amp;lt;/mainClass&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
  &amp;lt;/build&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.glassfish.jersey.containers&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jersey-container-jetty-http&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.30&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.jooq&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jooq&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.12.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.jooq&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jooq-meta&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.12.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.postgresql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;postgresql&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;42.2.9&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.glassfish.jersey.inject&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jersey-hk2&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.30&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.7.30&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;logback-classic&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2.3&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.glassfish.jersey.media&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jersey-media-json-jackson&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.30&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.persistence&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.persistence-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.18.10&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-bom&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.10.2&amp;lt;/version&amp;gt;
      &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now run &lt;code&gt;mvn install&lt;/code&gt; to download and configure all dependencies.&lt;/p&gt;
&lt;h3 id="project-setup"&gt;Project setup&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Main&lt;/code&gt; class will be our entrypoint
within &lt;code&gt;src/main/java/api/Main.java&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It will handle loading configuration, setting up the application
server, and starting it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api;

import java.io.InputStream;

import api.app.Application;
import api.app.Config;

public class Main {
  public static void main(String[] args) {
    try {
      var cfg = new Config();
      var server = new Application(cfg);
      server.start();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Config&lt;/code&gt; class in
&lt;code&gt;src/main/java/api/app/Config.java&lt;/code&gt; will contain a few
hard-coded settings for now. In the future it could be read from a
file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api.app;

import java.io.InputStream;
import java.time.Duration;
import java.util.Properties;

public final class Config {
  public final String server_address = &amp;quot;http://localhost&amp;quot;;
  public final int server_port = 7780;

  public final String db_connection = &amp;quot;jdbc:postgresql://localhost/todo&amp;quot;;
  public final String db_username = &amp;quot;todo&amp;quot;;
  public final String db_password = &amp;quot;todo&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally the &lt;code&gt;Application&lt;/code&gt; class
in &lt;code&gt;src/main/java/api/app/Application.java&lt;/code&gt; will handle
loading a PostgreSQL connection, registering the class path to look
for Jersey routes/controllers, registering the PostgreSQL connection
in the dependency injection controller and starting the Jersey
controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api.app;

import javax.ws.rs.core.UriBuilder;

import org.glassfish.jersey.internal.inject.AbstractBinder;
import org.glassfish.jersey.jetty.JettyHttpContainerFactory;
import org.glassfish.jersey.server.ResourceConfig;
import org.slf4j.LoggerFactory;

import api.dao.Dao;
import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.Logger;

public class Application {
  private static final Logger logger = (Logger) LoggerFactory.getLogger(Application.class);
  private static final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);
  static {
    rootLogger.setLevel(Level.INFO);
  }

  Config cfg;

  public Application(final Config _cfg) {
    cfg = _cfg;
  }

  private void addShutdownHook(final Runnable hook) {
    Runtime.getRuntime().addShutdownHook(new Thread(hook));
  }

  public void start() {
    var dao = new Dao(cfg.db_connection, cfg.db_username, cfg.db_password);
    try {
      dao.initialize();
    } catch (Exception e) {
      e.printStackTrace();
      return;
    }
    addShutdownHook(() -&amp;gt; {
      try {
        dao.close();
      } catch (java.sql.SQLException e) {
        e.printStackTrace();
      }
    });

    var resourceConfig = new ResourceConfig();
    resourceConfig.packages(&amp;quot;api.controller&amp;quot;);
    resourceConfig.register(new AbstractBinder() {
      @Override
      protected void configure() {
        bind(dao).to(Dao.class);
      }
    });

    var baseUri = UriBuilder.fromUri(cfg.server_address).port(cfg.server_port).build();
    var server = JettyHttpContainerFactory.createServer(baseUri, resourceConfig);
    logger.info(&amp;quot;Started listening on {}:{}&amp;quot;, cfg.server_address, cfg.server_port);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  I couldn't figure out a reasonable way to avoid the class path
  registration for routes.
  &lt;br /&gt;
  &lt;br /&gt;
  It's also important to note that the &lt;code&gt;AbstractBinder&lt;/code&gt;
  appears to search the class path implicitly for any available
  dependency injection controller. I'd rather we had specified it
  explicitly but I'm not sure how. It will succeed because we
  installed
  &lt;a href="https://javaee.github.io/hk2/"&gt;HK2&lt;/a&gt; as a dependency
  (see &lt;code&gt;pom.xml&lt;/code&gt;).
&lt;/p&gt;&lt;p&gt;With the &lt;code&gt;Application&lt;/code&gt; code finished, we'll need to build
out the referenced &lt;code&gt;Dao&lt;/code&gt; and controller classes.&lt;/p&gt;
&lt;h3 id="dao"&gt;Dao&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;Dao&lt;/code&gt; class in
&lt;code&gt;src/main/java/api/dao/Dao.java&lt;/code&gt; will enclose the
connection to PostgreSQL via JOOQ.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api.dao;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;

public class Dao {
  private Connection conn;
  private String url;
  private String username;
  private String password;

  public Dao(final String _url, final String _username, final String _password) {
    url = _url;
    username = _username;
    password = _password;
  }

  public void initialize() throws SQLException {
    conn = DriverManager.getConnection(url, username, password);
  }

  public void close() throws SQLException {
    conn.close();
  }

  public DSLContext getDSLContext() {
    return DSL.using(conn, SQLDialect.POSTGRES);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this will be enough to use in our controller. But let's take a
moment to talk about the data model.&lt;/p&gt;
&lt;h3 id="data"&gt;Data&lt;/h3&gt;&lt;p&gt;This API will return results from a TODO list. The database should
store each TODO item and a timestamp of completion, if completed.&lt;/p&gt;
&lt;p&gt;We'll start by creating a database and user for the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo su postgres
postgres $ psql
postgres=# CREATE DATABASE todo;
postgres=# CREATE USER todo WITH PASSWORD &amp;#39;todo&amp;#39;;
postgres=# GRANT ALL ON DATABASE todo TO todo;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we'll write an initial migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs sql"&gt;$ cat migrations/1_init.sql
CREATE TABLE todo_item (
  id BIGSERIAL NOT NULL PRIMARY KEY,
  item TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a helper script for running migrations:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat scripts/migrate.sh
#!/usr/bin/env bash

set -e

export PGPASSWORD=todo

for file in $(ls migrations); do
    echo &amp;quot;Running migration: $file&amp;quot;
    psql -U todo -f &amp;quot;migrations/$file&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ chmod +x ./scripts/migrate.sh
$ ./scripts/migrate.sh
Running migration: 1_init.sql
CREATE TABLE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let's add some data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ sudo su postgres
postgres $ psql -U todo
todo=# INSERT INTO todo_item (item) VALUES (&amp;#39;My note&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we're ready to model the data in Java.&lt;/p&gt;
&lt;h3 id="models"&gt;Models&lt;/h3&gt;&lt;p&gt;While it's possible to have &lt;a href="https://www.jooq.org/doc/3.12/manual/code-generation/"&gt;JOOQ generate Java data
classes&lt;/a&gt; (or
POJOs) by reading the database schema, the generated class cannot be
directly serialized to a JSON string.&lt;/p&gt;
&lt;p&gt;So for each table (there's only one) we'll write a class with fields
for each column. We'll use the &lt;a href="https://javaee.github.io/tutorial/persistence-intro.html"&gt;Java Persistence
API&lt;/a&gt; (JPA)
to annotate the class and fields so JOOQ will know how to deserialize
query results into an instance of the model.&lt;/p&gt;
&lt;p&gt;We'll use &lt;a href="https://projectlombok.org/"&gt;Lombok&lt;/a&gt; to label the whole
object as &lt;code&gt;Data&lt;/code&gt; so that getter and setter methods are
generated automatically for each private field. And we'll use a
&lt;a href="https://github.com/FasterXML/jackson"&gt;Jackson&lt;/a&gt; annotation to label
the JSON field name of each column.&lt;/p&gt;
&lt;p&gt;This is the &lt;code&gt;TodoItem&lt;/code&gt; class in
&lt;code&gt;src/main/java/api/model/TodoItem.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api.model;

import java.time.OffsetDateTime;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonProperty;

import lombok.Data;

@Data
@Table(name = &amp;quot;todo_item&amp;quot;)
public class TodoItem {
  @Column(name = &amp;quot;id&amp;quot;)
  @JsonProperty(&amp;quot;id&amp;quot;)
  @Id
  private long id;

  @Column(name = &amp;quot;name&amp;quot;)
  @JsonProperty(&amp;quot;name&amp;quot;)
  private String name;

  @Column(name = &amp;quot;created_at&amp;quot;)
  @JsonProperty(&amp;quot;createdAt&amp;quot;)
  @JsonFormat(pattern = &amp;quot;yyyy-MM-dd&amp;#39;T&amp;#39;HH:mm:ssZ&amp;quot;)
  private OffsetDateTime createdAt;

  @Column(name = &amp;quot;completed_at&amp;quot;)
  @JsonProperty(&amp;quot;completedAt&amp;quot;)
  @JsonFormat(pattern = &amp;quot;yyyy-MM-dd&amp;#39;T&amp;#39;HH:mm:ssZ&amp;quot;)
  private OffsetDateTime completedAt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  The JSON format specifications for the timestamp fields aren't
  actually working. The formatted JSON returns a giant object and I
  haven't figured out how to get it to serialize to the RFC3339 string
  yet.
&lt;/p&gt;&lt;p&gt;We're set! The last step is a simple controller to return a list of
TODO items.&lt;/p&gt;
&lt;h3 id="the-/items-controller"&gt;The /items controller&lt;/h3&gt;&lt;p&gt;In the &lt;code&gt;ItemsController&lt;/code&gt; class in
&lt;code&gt;src/main/java/api/model/ItemsController.java&lt;/code&gt; we'll inject
the &lt;code&gt;Dao&lt;/code&gt; object and use it to return a page of TODO items
as JSON.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs java"&gt;package api.controller;

import java.util.List;

import javax.inject.Inject;
import javax.persistence.Table;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

import org.jooq.DSLContext;

import api.dao.Dao;
import api.model.TodoItem;

@Path(&amp;quot;items&amp;quot;)
public class ItemsController {
  @Inject
  Dao dao;

  @GET
  @Produces(MediaType.APPLICATION_JSON)
  public List&amp;lt;TodoItem&amp;gt; getServers() {
    DSLContext dslCtx = dao.getDSLContext();
    Table table = TodoItem.class.getAnnotation(Table.class);
    return dslCtx.select().from(table.name()).fetch().into(TodoItem.class);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  There's some more implicit magic here when we return a list of
  &lt;code&gt;TodoItem&lt;/code&gt;s. Since we marked the endpoint as producing
  JSON, and since Jackson is in our class path, Jersey will
  automatically use Jackson to serialize the list to JSON.
  &lt;br /&gt;
  &lt;br /&gt;
  The API is quite nice but I could do without the automatic
  class-loading magic.
&lt;/p&gt;&lt;p&gt;Now we're ready to build, run and test.&lt;/p&gt;
&lt;h3 id="building-and-running"&gt;Building and running&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs bash"&gt;$ mvn clean compile
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------&amp;lt; api:api &amp;gt;-------------------------------
[INFO] Building api 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- maven-clean-plugin:2.5:clean (default-clean) @ api ---
[INFO] Deleting /Users/philipeaton/tmp/test/target
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ api ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory /Users/philipeaton/tmp/test/src/main/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ api ---
[INFO] Changes detected - recompiling the module!
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[INFO] Compiling 6 source files to /Users/philipeaton/tmp/test/target/classes
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  2.198 s
[INFO] Finished at: 2020-02-01T17:07:14-05:00
[INFO] ------------------------------------------------------------------------
$ mvn exec:java
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------&amp;lt; api:api &amp;gt;-------------------------------
[INFO] Building api 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO]
[INFO] --- exec-maven-plugin:1.6.0:java (default-cli) @ api ---
17:06:53.793 [api.Main.main()] INFO org.eclipse.jetty.util.log - Logging initialized @2017ms to org.eclipse.jetty.util.log.Slf4jLog
17:06:54.378 [api.Main.main()] INFO org.eclipse.jetty.server.Server - jetty-9.4.17.v20190418; built: 2019-04-18T19:45:35.259Z; git: aa1c656c315c011c01e7b21aabb04066635b9f67; jvm 13+33
17:06:54.425 [api.Main.main()] INFO org.eclipse.jetty.server.AbstractConnector - Started ServerConnector@3943a159{HTTP/1.1,[http/1.1]}{0.0.0.0:7780}
17:06:54.425 [api.Main.main()] INFO org.eclipse.jetty.server.Server - Started @2651ms
17:06:54.425 [api.Main.main()] INFO api.app.Application - Started listening on http://localhost:7780
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a new terminal curl the endpoint:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ curl localhost:7780/items | jq
[
  {
    &amp;quot;id&amp;quot;: 1,
    &amp;quot;name&amp;quot;: null,
    &amp;quot;createdAt&amp;quot;: {
      &amp;quot;offset&amp;quot;: {
        &amp;quot;totalSeconds&amp;quot;: -18000,
        &amp;quot;id&amp;quot;: &amp;quot;-05:00&amp;quot;,
        &amp;quot;rules&amp;quot;: {
          &amp;quot;transitions&amp;quot;: [],
          &amp;quot;transitionRules&amp;quot;: [],
          &amp;quot;fixedOffset&amp;quot;: true
        }
      },
      &amp;quot;dayOfWeek&amp;quot;: &amp;quot;SATURDAY&amp;quot;,
      &amp;quot;dayOfYear&amp;quot;: 32,
      &amp;quot;nano&amp;quot;: 594440000,
      &amp;quot;year&amp;quot;: 2020,
      &amp;quot;monthValue&amp;quot;: 2,
      &amp;quot;dayOfMonth&amp;quot;: 1,
      &amp;quot;hour&amp;quot;: 17,
      &amp;quot;minute&amp;quot;: 8,
      &amp;quot;second&amp;quot;: 0,
      &amp;quot;month&amp;quot;: &amp;quot;FEBRUARY&amp;quot;
    },
    &amp;quot;completedAt&amp;quot;: null
  }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're done!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I really enjoy using Java for REST APIs, avoiding Spring and Play. Use simple but mature libraries that are no more difficult to cobble together than everything you must do in Go or Flask for a REST API. vs Go you get generics and vs python you get safety&lt;a href="https://t.co/twmjZprow6"&gt;https://t.co/twmjZprow6&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1223733417453465601?ref_src=twsrc%5Etfw"&gt;February 1, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/a-minimal-rest-api-in-java.html</guid><pubDate>Sat, 01 Feb 2020 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 6. an x86 upgrade</title><link>http://notes.eatonphil.com/compiler-basics-an-x86-upgrade.html</link><description>&lt;p class="note"&gt;
  Previously in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-lisp-to-assembly.html"&gt;1. lisp to assembly&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-functions.html"&gt;2. user-defined functions and variables&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm.html"&gt;3. LLVM&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-conditionals.html"&gt;4. LLVM conditionals and compiling fibonacci&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-system-calls.html"&gt;5. LLVM system calls&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;This post upgrades the ulisp x86 backend from using a limited set of
registers (with no spilling support) to solely using the stack to pass
values between expressions.&lt;/p&gt;
&lt;p&gt;This is a slightly longer post since we've got a lot of catchup to do
to get to feature parity with the LLVM backend. Namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"Infinite" locals, parameters&lt;/li&gt;
&lt;li&gt;Function definitions&lt;/li&gt;
&lt;li&gt;Variable references&lt;/li&gt;
&lt;li&gt;Arithmetic and logical operations&lt;/li&gt;
&lt;li&gt;If&lt;/li&gt;
&lt;li&gt;Syscalls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll tackle the first four points first and finish up with the last
two. This way we can support the same fibonacci program that prints
integers to stdout that we support in the LLVM backend.&lt;/p&gt;
&lt;p&gt;As always the &lt;a href="https://github.com/eatonphil/ulisp"&gt;code is available on
Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But first a digression into how this is suddenly easy for us to do
with x86 and one-pass (sorta) code generation.&lt;/p&gt;
&lt;h3 id="stack-based-languages"&gt;Stack-based languages&lt;/h3&gt;&lt;p&gt;Stack-based languages have the extremely convenient attribute that
values are (by default) stored on the stack, which allows a code
generator targeting a stack-based language the option to omit handling
register allocation. And as it happens, x86 has enough support to make
it easy to treat as a stack machine.&lt;/p&gt;
&lt;p&gt;As we build out the code generator for x86 as a stack machine we need
to keep two commitments in mind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every expression must pop all arguments/operands&lt;/li&gt;
&lt;li&gt;Every expression must store one result back on the stack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the future, we may replace the second commitment. But for now it is
more than enough.&lt;/p&gt;
&lt;h3 id="boilerplate"&gt;Boilerplate&lt;/h3&gt;&lt;p&gt;We'll start with the existing x86 backend code and strip all the
implementation code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const cp = require(&amp;#39;child_process&amp;#39;);
const fs = require(&amp;#39;fs&amp;#39;);
const os = require(&amp;#39;os&amp;#39;);

let GLOBAL_COUNTER = 0;

const SYSCALL_MAP = {
  darwin: {
    exit: &amp;#39;0x2000001&amp;#39;,
    write: &amp;#39;0x2000004&amp;#39;,
  },
  linux: {
    exit: 60,
    write: 1,
  },
}[os.platform()];

class Scope {}

class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      if: this.compileIf.bind(this),
      ...this.prepareArithmeticWrappers(),
      ...this.prepareLogicalWrappers(),
      ...this.prepareSyscallWrappers(),
    };
  }

  prepareArithmeticWrappers() {}

  prepareLogicalWrappers() {}

  prepareSyscallWrappers() {}

  emit(depth, args) {
    if (depth === undefined || args === undefined) {
      throw new Error(&amp;#39;Invalid call to emit&amp;#39;);
    }

    const indent = new Array(depth + 1).join(&amp;#39;  &amp;#39;);
    this.outBuffer.push(indent + args);
  }

  compileExpression(arg, scope, depth) {}

  compileIf([test, then, els], scope, depth) {}

  compileBegin(body, scope, depth, topLevel = false) {}

  compileDefine([name, params, ...body], scope, depth) {}

  compileCall(fun, args, scope, depth) {}

  emitPrefix() {
    this.emit(1, &amp;#39;.global _main\n&amp;#39;);

    this.emit(1, &amp;#39;.text\n&amp;#39;);
  }

  emitPostfix() {
    this.emit(0, &amp;#39;_main:&amp;#39;);
    this.emit(1, &amp;#39;CALL main&amp;#39;);
    this.emit(1, &amp;#39;MOV RDI, RAX&amp;#39;); // Set exit arg
    this.emit(1, `MOV RAX, ${SYSCALL_MAP[&amp;#39;exit&amp;#39;]}`);
    this.emit(1, &amp;#39;SYSCALL&amp;#39;);
  }

  getOutput() {
    const output = this.outBuffer.join(&amp;#39;\n&amp;#39;);

    // Leave at most one empty line
    return output.replace(/\n\n\n+/g, &amp;#39;\n\n&amp;#39;);
  }
}

module.exports.compile = function(ast) {
  const c = new Compiler();
  c.emitPrefix();
  const s = new Scope();
  c.compileBegin(ast, s, 1, true);
  c.emitPostfix();
  return c.getOutput();
};

module.exports.build = function(buildDir, program) {
  const prog = &amp;#39;prog&amp;#39;;
  fs.writeFileSync(`${buildDir}/${prog}.s`, program);
  cp.execSync(
    `gcc -mstackrealign -masm=intel -o ${buildDir}/${prog} ${buildDir}/${prog}.s`,
  );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The prefix and postfix stays mostly the same as the original
implementation. But we'll assume a couple of new helpers to get us in
parity with the LLVM backend:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compileDefine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileBegin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileIf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileCall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepareArithmeticWrappers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepareLogicalWrappers&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prepareSyscallWrappers&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;prepareArithmeticWrappers&lt;/code&gt; helper will define wrappers
for arithmetic instructions. The &lt;code&gt;prepareLogicalWrappers&lt;/code&gt;
helper will define wrappers for logical instructions. And the
&lt;code&gt;prepareSyscallWrappers&lt;/code&gt; helper will define a wrapper for
syscalls and generate builtins based on the SYSCALL_MAP entries.&lt;/p&gt;
&lt;h3 id="scope"&gt;Scope&lt;/h3&gt;&lt;p&gt;Similar to our LLVM backend's Context and Scope helpers we'll define
our own for the x86 backend. Since we're placing all locals on the
stack, the two most important things Scope will do for us are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map identifiers to escaped strings&lt;/li&gt;
&lt;li&gt;Store and increment the location of the local on the stack&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here's what it will look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {
  constructor() {
    this.localOffset = 1;
    this.map = {};
  }

  assign(name) {
    const safe = name.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);
    this.map[safe] = this.localOffset++;
    return safe;
  }

  symbol() {
    return this.localOffset++;
  }

  lookup(name) {
    const safe = name.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);
    if (this.map[safe]) {
      return { name: safe, offset: this.map[safe] };
    }

    return null;
  }

  copy() {
    const s = new Scope();
    // In the future we may need to store s.scopeOffset = this.scopeOffset + 1
    // so we can read outer-scoped values at runtime.
    s.map = { ...this.map };
    return s;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="compileexpression"&gt;compileExpression&lt;/h3&gt;&lt;p&gt;An expression will be one of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A function call (possibly a builtin like &lt;code&gt;def&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A literal value (e.g. &lt;code&gt;29&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A reference (e.g. &lt;code&gt;&amp;c&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;An identifier (e.g. &lt;code&gt;my-var&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll handle compiling an expression in that order. If the AST
argument passed to &lt;code&gt;compileExpression&lt;/code&gt; is an array, we will
call &lt;code&gt;compileCall&lt;/code&gt; and return.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileExpression(arg, scope, depth) {
    // Is a nested function call, compile it
    if (Array.isArray(arg)) {
      this.compileCall(arg[0], arg.slice(1), scope, depth);
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the AST is a number, we will push the number onto the stack and
return.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileExpression(arg, scope, depth) {
    // Is a nested function call, compile it
    if (Array.isArray(arg)) {
      this.compileCall(arg[0], arg.slice(1), scope, depth);
      return;
    }

    if (Number.isInteger(arg)) {
      this.emit(depth, `PUSH ${arg}`);
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the AST is a string that starts with &lt;code&gt;&amp;&lt;/code&gt; we will look up
the location of the identifier after the &lt;code&gt;&amp;&lt;/code&gt;, push its
&lt;em&gt;location&lt;/em&gt; onto the stack and return.&lt;/p&gt;
&lt;p&gt;We count on the Scope storing its offset from the "frame pointer",
which we will later set up to be stored in &lt;code&gt;RBP&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Locals will be stored after the frame pointer and parameters will be
stored before it. So we'll need to add or subtract from the frame
pointer depending on if we need a positive or negative offset from it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileExpression(arg, scope, depth) {
    // Is a nested function call, compile it
    if (Array.isArray(arg)) {
      this.compileCall(arg[0], arg.slice(1), scope, depth);
      return;
    }

    if (Number.isInteger(arg)) {
      this.emit(depth, `PUSH ${arg}`);
      return;
    }

    if (arg.startsWith(&amp;#39;&amp;amp;&amp;#39;)) {
      const { offset } = scope.lookup(arg.substring(1));
      // Copy the frame pointer so we can return an offset from it
      this.emit(depth, `MOV RAX, RBP`);
      const operation = offset &amp;lt; 0 ? &amp;#39;ADD&amp;#39; : &amp;#39;SUB&amp;#39;;
      this.emit(depth, `${operation} RAX, ${Math.abs(offset * 8)} # ${arg}`);
      this.emit(depth, `PUSH RAX`);
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we'll look up the identifier and copy the value (in its
offset on the stack) to the top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileExpression(arg, scope, depth) {
    // Is a nested function call, compile it
    if (Array.isArray(arg)) {
      this.compileCall(arg[0], arg.slice(1), scope, depth);
      return;
    }

    if (Number.isInteger(arg)) {
      this.emit(depth, `PUSH ${arg}`);
      return;
    }

    if (arg.startsWith(&amp;#39;&amp;amp;&amp;#39;)) {
      const { offset } = scope.lookup(arg.substring(1));
      // Copy the frame pointer so we can return an offset from it
      this.emit(depth, `MOV RAX, RBP`);
      const operation = offset &amp;lt; 0 ? &amp;#39;ADD&amp;#39; : &amp;#39;SUB&amp;#39;;
      this.emit(depth, `${operation} RAX, ${Math.abs(offset * 8)} # ${arg}`);
      this.emit(depth, `PUSH RAX`);
      return;
    }

    // Variable lookup
    const { offset } = scope.lookup(arg);
    if (offset) {
      const operation = offset &amp;lt; 0 ? &amp;#39;+&amp;#39; : &amp;#39;-&amp;#39;;
      this.emit(
        depth,
        `PUSH [RBP ${operation} ${Math.abs(offset * 8)}] # ${arg}`,
      );
    } else {
      throw new Error(
        &amp;#39;Attempt to reference undefined variable or unsupported literal: &amp;#39; +
          arg,
      );
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it for handling expression! Let's add
&lt;code&gt;compileCall&lt;/code&gt; support now that we referenced it.&lt;/p&gt;
&lt;h3 id="compilecall"&gt;compileCall&lt;/h3&gt;&lt;p&gt;A call will first check if the call is a builtin. If so, it will
immediately pass control to the builtin.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileCall(fun, args, scope, depth) {
    if (this.primitiveFunctions[fun]) {
      this.primitiveFunctions[fun](args, scope, depth);
      return;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otherwise it will compile every argument to the call (which will leave
all the resulting values on the stack.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileCall(fun, args, scope, depth) {
    if (this.primitiveFunctions[fun]) {
      this.primitiveFunctions[fun](args, scope, depth);
      return;
    }

    // Compile registers and store on the stack
    args.map((arg, i) =&amp;gt; this.compileExpression(arg, scope, depth));
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we will check that function is defined and call it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileCall(fun, args, scope, depth) {
    if (this.primitiveFunctions[fun]) {
      this.primitiveFunctions[fun](args, scope, depth);
      return;
    }

    // Compile registers and store on the stack
    args.map((arg, i) =&amp;gt; this.compileExpression(arg, scope, depth));

    const fn = scope.lookup(fun);
    if (fn) {
      this.emit(depth, `CALL ${fn.name}`);
    } else {
      throw new Error(&amp;#39;Attempt to call undefined function: &amp;#39; + fun);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we'll reset the stack pointer (to maintain our commitment) based
on the number of arguments and push &lt;code&gt;RAX&lt;/code&gt; (where the return
result of the function call will be stored) onto the stack. We'll make
two minor optimizations for when there is exactly zero or one argument
to the function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileCall(fun, args, scope, depth) {
    if (this.primitiveFunctions[fun]) {
      this.primitiveFunctions[fun](args, scope, depth);
      return;
    }

    // Compile registers and store on the stack
    args.map((arg, i) =&amp;gt; this.compileExpression(arg, scope, depth));

    const fn = scope.lookup(fun);
    if (fn) {
      this.emit(depth, `CALL ${fn.name}`);
    } else {
      throw new Error(&amp;#39;Attempt to call undefined function: &amp;#39; + fun);
    }

    if (args.length &amp;gt; 1) {
      // Drop the args
      this.emit(depth, `ADD RSP, ${args.length * 8}`);
    }

    if (args.length === 1) {
      this.emit(depth, `MOV [RSP], RAX\n`);
    } else {
      this.emit(depth, &amp;#39;PUSH RAX\n&amp;#39;);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When there is only one argument, we can just set the top value on the
stack to be the return result of the call rather than resetting the
stack pointer just to push onto it.&lt;/p&gt;
&lt;p&gt;And that's it for &lt;code&gt;compileCall&lt;/code&gt;! Now that we've got a feel
for expressions and function calls, let's add some simple arithmetic
operations.&lt;/p&gt;
&lt;h3 id="preparearithmeticwrappers"&gt;prepareArithmeticWrappers&lt;/h3&gt;&lt;p&gt;There are two major kind of arithmetic instructions we'll wrap for now:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;"General" instructions that operate on two arguments, putting the
return result in the first argument&lt;/li&gt;
&lt;li&gt;"RAX" instructions that operate on RAX and the first argument,
putting the return result in &lt;code&gt;RAX&lt;/code&gt; and possibly
&lt;code&gt;RDX&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="preparegeneral"&gt;prepareGeneral&lt;/h4&gt;&lt;p&gt;This helper will compile its two arguments and pop the second argument
into &lt;code&gt;RAX&lt;/code&gt;. This is because x86 instructions typically
require one argument to be a register if one argument is allowed to be
a memory address.&lt;/p&gt;
&lt;p&gt;We'll use the stack address as the first argument so 1) that
non-commutative operations are correct and 2) the result is stored
right back onto the stack in the right location.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;    const prepareGeneral = (instruction) =&amp;gt; (arg, scope, depth) =&amp;gt; {
      depth++;
      this.emit(depth, `# ${instruction.toUpperCase()}`);

      // Compile first argument
      this.compileExpression(arg[0], scope, depth);

      // Compile second argument
      this.compileExpression(arg[1], scope, depth);
      this.emit(depth, `POP RAX`);

      // Compile operation
      this.emit(depth, `${instruction.toUpperCase()} [RSP], RAX`);

      this.emit(depth, `# End ${instruction.toUpperCase()}`);
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="preparerax"&gt;prepareRax&lt;/h4&gt;&lt;p&gt;This helper will similarly compile its two arguments and pop
the second argument into &lt;code&gt;RAX&lt;/code&gt;. But the RAX-implicit
instructions require the argument to be stored in a register
so we'll use the &lt;code&gt;XCHG&lt;/code&gt; instruction to swap &lt;code&gt;RAX&lt;/code&gt;
with the value on the top of the stack (the first argument).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;    const prepareRax = (instruction, outRegister = &amp;#39;RAX&amp;#39;) =&amp;gt; (
      arg,
      scope,
      depth,
    ) =&amp;gt; {
      depth++;
      this.emit(depth, `# ${instruction.toUpperCase()}`);

      // Compile first argument, store in RAX
      this.compileExpression(arg[0], scope, depth);

      // Compile second argument
      this.compileExpression(arg[1], scope, depth);

      // POP second argument and swap with first
      this.emit(depth, `POP RAX`);
      this.emit(depth, `XCHG [RSP], RAX`);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may seem roundabout but remember that we &lt;em&gt;must&lt;/em&gt; pop all
arguments to the instruction to maintain our commitment.&lt;/p&gt;
&lt;p&gt;Next we'll zero out the &lt;code&gt;RDX&lt;/code&gt; register if the operation is
&lt;code&gt;DIV&lt;/code&gt;, perform the operation, and store the result on the
top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;    const prepareRax = (instruction, outRegister = &amp;#39;RAX&amp;#39;) =&amp;gt; (
      arg,
      scope,
      depth,
    ) =&amp;gt; {
      depth++;
      this.emit(depth, `# ${instruction.toUpperCase()}`);

      // Compile first argument, store in RAX
      this.compileExpression(arg[0], scope, depth);

      // Compile second argument
      this.compileExpression(arg[1], scope, depth);

      // POP second argument and swap with first
      this.emit(depth, `POP RAX`);
      this.emit(depth, `XCHG [RSP], RAX`);

      // Reset RDX for DIV
      if (instruction.toUpperCase() === &amp;#39;DIV&amp;#39;) {
        this.emit(depth, `XOR RDX, RDX`);
      }

      // Compiler operation
      this.emit(depth, `${instruction.toUpperCase()} QWORD PTR [RSP]`);

      // Swap the top of the stack
      this.emit(depth, `MOV [RSP], ${outRegister}`);
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We parameterize the out register because the &lt;code&gt;%&lt;/code&gt; wrapper
will call &lt;code&gt;DIV&lt;/code&gt; but need &lt;code&gt;RDX&lt;/code&gt; rather than
&lt;code&gt;RAX&lt;/code&gt; after the operation.&lt;/p&gt;
&lt;h4 id="preparearithmeticwrappers"&gt;prepareArithmeticWrappers&lt;/h4&gt;&lt;p&gt;Putting everything together we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  prepareArithmeticWrappers() {
    // General operatations
    const prepareGeneral = (instruction) =&amp;gt; (arg, scope, depth) =&amp;gt; {
      depth++;
      this.emit(depth, `# ${instruction.toUpperCase()}`);

      // Compile first argument
      this.compileExpression(arg[0], scope, depth);

      // Compile second argument
      this.compileExpression(arg[1], scope, depth);
      this.emit(depth, `POP RAX`);

      // Compile operation
      this.emit(depth, `${instruction.toUpperCase()} [RSP], RAX`);

      this.emit(depth, `# End ${instruction.toUpperCase()}`);
    };

    // Operations that use RAX implicitly
    const prepareRax = (instruction, outRegister = &amp;#39;RAX&amp;#39;) =&amp;gt; (
      arg,
      scope,
      depth,
    ) =&amp;gt; {
      depth++;
      this.emit(depth, `# ${instruction.toUpperCase()}`);

      // Compile first argument, store in RAX
      this.compileExpression(arg[0], scope, depth);

      // Compile second argument
      this.compileExpression(arg[1], scope, depth);

      // POP second argument and swap with first
      this.emit(depth, `POP RAX`);
      this.emit(depth, `XCHG [RSP], RAX`);

      // Reset RDX for DIV
      if (instruction.toUpperCase() === &amp;#39;DIV&amp;#39;) {
        this.emit(depth, `XOR RDX, RDX`);
      }

      // Compiler operation
      this.emit(depth, `${instruction.toUpperCase()} QWORD PTR [RSP]`);

      // Swap the top of the stack
      this.emit(depth, `MOV [RSP], ${outRegister}`);
    };

    return {
      &amp;#39;+&amp;#39;: prepareGeneral(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: prepareGeneral(&amp;#39;sub&amp;#39;),
      &amp;#39;&amp;amp;&amp;#39;: prepareGeneral(&amp;#39;and&amp;#39;),
      &amp;#39;|&amp;#39;: prepareGeneral(&amp;#39;or&amp;#39;),
      &amp;#39;=&amp;#39;: prepareGeneral(&amp;#39;mov&amp;#39;),
      &amp;#39;*&amp;#39;: prepareRax(&amp;#39;mul&amp;#39;),
      &amp;#39;/&amp;#39;: prepareRax(&amp;#39;div&amp;#39;),
      &amp;#39;%&amp;#39;: prepareRax(&amp;#39;div&amp;#39;, &amp;#39;RDX&amp;#39;),
    };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll tackle &lt;code&gt;compileBegin&lt;/code&gt; and
&lt;code&gt;compileDefine&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="compilebegin"&gt;compileBegin&lt;/h3&gt;&lt;p&gt;A begin form is an expression made up of a series of expressions where
all expression values are thrown away and the last expression value is
the result of the begin form.&lt;/p&gt;
&lt;p&gt;To compile this form we will compile each expression passed in and pop
from the stack to throw its value away. If the expression is the
last in the list we will not pop since it is the result of the begin
form.&lt;/p&gt;
&lt;p&gt;We will add one exception to this popping logic: if the begin is
called from the top-level we will omit the popping.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileBegin(body, scope, depth, topLevel = false) {
    body.forEach((expression, i) =&amp;gt; {
      this.compileExpression(expression, scope, depth);
      if (!topLevel &amp;amp;&amp;amp; i &amp;lt; body.length - 1) {
        this.emit(depth, `POP RAX # Ignore non-final expression`);
      }
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it for &lt;code&gt;compileBegin&lt;/code&gt;!&lt;/p&gt;
&lt;h3 id="compiledefine"&gt;compileDefine&lt;/h3&gt;&lt;p&gt;The prelude for a function definition will add its name to scope, push
the current frame pointer (&lt;code&gt;RBP&lt;/code&gt;) onto the stack and store
the current stack pointer (&lt;code&gt;RSP&lt;/code&gt;) as the new frame pointer
(&lt;code&gt;RBP&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Remember that we use the frame pointer as a point of reference when
setting and getting local and parameter values. It works out entirely
by convention.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileDefine([name, params, ...body], scope, depth) {
    // Add this function to outer scope
    const safe = scope.assign(name);

    // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
    const childScope = scope.copy();

    this.emit(0, `${safe}:`);
    this.emit(depth, `PUSH RBP`);
    this.emit(depth, `MOV RBP, RSP\n`);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we copy the parameters into local scope at their negative (from
the frame pointer) location. In the future we may decide to actually
copy in the parameter &lt;em&gt;values&lt;/em&gt; into the local stack but for now
there's no benefit.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileDefine([name, params, ...body], scope, depth) {
    // Add this function to outer scope
    const safe = scope.assign(name);

    // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
    const childScope = scope.copy();

    this.emit(0, `${safe}:`);
    this.emit(depth, `PUSH RBP`);
    this.emit(depth, `MOV RBP, RSP\n`);

    // Copy params into local scope
    params.forEach((param, i) =&amp;gt; {
      childScope.map[param] = -1 * (params.length - i - 1 + 2);
    });
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we'll compile the body of the function within a
&lt;code&gt;begin&lt;/code&gt; block.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileDefine([name, params, ...body], scope, depth) {
    // Add this function to outer scope
    const safe = scope.assign(name);

    // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
    const childScope = scope.copy();

    this.emit(0, `${safe}:`);
    this.emit(depth, `PUSH RBP`);
    this.emit(depth, `MOV RBP, RSP\n`);

    // Copy params into local scope
    params.forEach((param, i) =&amp;gt; {
      childScope.map[param] = -1 * (params.length - i - 1 + 2);
    });

    // Pass childScope in for reference when body is compiled.
    this.compileBegin(body, childScope, depth);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then in the postlude we'll pop the stack (for the return result of the
begin form), save it in RAX, pop the previous frame pointer back to
restore the calling frame, and return.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  compileDefine([name, params, ...body], scope, depth) {
    // Add this function to outer scope
    const safe = scope.assign(name);

    // Copy outer scope so parameter mappings aren't exposed in outer scope.
    const childScope = scope.copy();

    this.emit(0, `${safe}:`);
    this.emit(depth, `PUSH RBP`);
    this.emit(depth, `MOV RBP, RSP\n`);

    // Copy params into local scope
    params.forEach((param, i) =&amp;gt; {
      childScope.map[param] = -1 * (params.length - i - 1 + 2);
    });

    // Pass childScope in for reference when body is compiled.
    this.compileBegin(body, childScope, depth);

    // Save the return value
    this.emit(0, '');
    this.emit(depth, `POP RAX`);
    this.emit(depth, `POP RBP\n`);

    this.emit(depth, 'RET\n');
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we're ready to compile a simple program!&lt;/p&gt;
&lt;h3 id="our-first-program"&gt;Our first program&lt;/h3&gt;&lt;p&gt;Here's a simple one we can support:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;$ cat tests/meaning-of-life.lisp
(def main ()
  (+ 8 (* 2 17)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll compile this program without the ulisp kernel (which contains a
lisp library we cannot currently compile):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node src/ulisp.js tests/meaning-of-life.lisp --no-kernel --backend x86
$ ./build/prog
$ echo $?
42
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not bad. Let's finish up with support for
&lt;code&gt;prepareLogicalWrappers&lt;/code&gt;,
&lt;code&gt;prepareSyscallWrappers&lt;/code&gt;, and &lt;code&gt;compileIf&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="preparelogicalwrappers"&gt;prepareLogicalWrappers&lt;/h3&gt;&lt;p&gt;Storing logical results as values is a bit of pain. Most of the
internet wants you to use branching. And a better compiler may
optimize an idiom like &lt;code&gt;(if (&gt; 5 2) ...)&lt;/code&gt; into a single
branch.&lt;/p&gt;
&lt;p&gt;But we're going to resort to an instruction I just learned about
called &lt;code&gt;CMOV&lt;/code&gt;. This allows us to conditionally assign a
value based on flags, similar to how you can conditionally branch.&lt;/p&gt;
&lt;p&gt;Otherwise we'll follow a pattern similar to our arithmetic
wrappers. At the end of the procedure we will have a 0 or a 1 on the
top of the stack.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  prepareLogicalWrappers() {
    const prepareComparison = (operator) =&amp;gt; {
      return {
        [operator]: (arg, scope, depth) =&amp;gt; {
          depth++;
          this.emit(depth, `# ${operator}`);

          // Compile first argument, store in RAX
          this.compileExpression(arg[0], scope, depth);

          // Compile second argument
          this.compileExpression(arg[1], scope, depth);
          this.emit(depth, `POP RAX`);

          // Compile operation
          this.emit(depth, `CMP [RSP], RAX`);

          // Reset RAX to serve as CMOV* dest, MOV to keep flags (vs. XOR)
          this.emit(depth, `MOV RAX, 0`);

          // Conditional set [RSP]
          const operation = {
            &amp;#39;&amp;gt;&amp;#39;: &amp;#39;CMOVA&amp;#39;,
            &amp;#39;&amp;gt;=&amp;#39;: &amp;#39;CMOVAE&amp;#39;,
            &amp;#39;&amp;lt;&amp;#39;: &amp;#39;CMOVB&amp;#39;,
            &amp;#39;&amp;lt;=&amp;#39;: &amp;#39;CMOVBE&amp;#39;,
            &amp;#39;==&amp;#39;: &amp;#39;CMOVE&amp;#39;,
            &amp;#39;!=&amp;#39;: &amp;#39;CMOVNE&amp;#39;,
          }[operator];
          // CMOV* requires the source to be memory or register
          this.emit(depth, `MOV DWORD PTR [RSP], 1`);
          // CMOV* requires the dest to be a register
          this.emit(depth, `${operation} RAX, [RSP]`);
          this.emit(depth, `MOV [RSP], RAX`);
          this.emit(depth, `# End ${operator}`);
        },
      };
    };

    return {
      ...prepareComparison(&amp;#39;&amp;gt;&amp;#39;),
      ...prepareComparison(&amp;#39;&amp;gt;=&amp;#39;),
      ...prepareComparison(&amp;#39;&amp;lt;&amp;#39;),
      ...prepareComparison(&amp;#39;&amp;lt;=&amp;#39;),
      ...prepareComparison(&amp;#39;==&amp;#39;),
      ...prepareComparison(&amp;#39;!=&amp;#39;),
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="preparesyscallwrappers"&gt;prepareSyscallWrappers&lt;/h3&gt;&lt;p&gt;This helper is similar to &lt;code&gt;compileCall&lt;/code&gt; except for that it
needs to follow the SYS V ABI and use the &lt;code&gt;SYSCALL&lt;/code&gt;
instruction rather than &lt;code&gt;CALL&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  prepareSyscallWrappers() {
    const registers = [&amp;#39;RDI&amp;#39;, &amp;#39;RSI&amp;#39;, &amp;#39;RDX&amp;#39;, &amp;#39;R10&amp;#39;, &amp;#39;R8&amp;#39;, &amp;#39;R9&amp;#39;];

    const wrappers = {};
    Object.keys(SYSCALL_MAP).forEach((key, obj) =&amp;gt; {
      wrappers[`syscall/${key}`] = (args, scope, depth) =&amp;gt; {
        if (args.length &amp;gt; registers.length) {
          throw new Error(`Too many arguments to syscall/${key}`);
        }

        // Compile first
        args.forEach((arg) =&amp;gt; this.compileExpression(arg, scope, depth));

        // Then pop to avoid possible register contention
        args.forEach((_, i) =&amp;gt;
          this.emit(depth, `POP ${registers[args.length - i - 1]}`),
        );

        this.emit(depth, `MOV RAX, ${SYSCALL_MAP[key]}`);
        this.emit(depth, &amp;#39;SYSCALL&amp;#39;);
        this.emit(depth, `PUSH RAX`);
      };
    });

    return wrappers;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're set! Last up is &lt;code&gt;compileIf&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="compileif"&gt;compileIf&lt;/h3&gt;&lt;p&gt;This is standard code generation but gets a little tricky due to our
stack commitments. Testing must pop the test value off the stack. And
then/else blocks must &lt;em&gt;push&lt;/em&gt; a value onto the stack (even if
there is no else block).&lt;/p&gt;
&lt;p&gt;Here is an example we'd like to support:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(if (foo)
  (do-bar))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We compile the test and branch:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileIf([test, then, els], scope, depth) {
    this.emit(depth, &amp;#39;# If&amp;#39;);
    // Compile test
    this.compileExpression(test, scope, depth);
    const branch = `else_branch` + GLOBAL_COUNTER++;
    // Must pop/use up argument in test
    this.emit(0, &amp;#39;&amp;#39;);
    this.emit(depth, `POP RAX`);
    this.emit(depth, `TEST RAX, RAX`);
    this.emit(depth, `JZ .${branch}\n`);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we compile the then block and jump to after the else block
afterward.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileIf([test, then, els], scope, depth) {
    this.emit(depth, &amp;#39;# If&amp;#39;);
    // Compile test
    this.compileExpression(test, scope, depth);
    const branch = `else_branch` + GLOBAL_COUNTER++;
    // Must pop/use up argument in test
    this.emit(0, &amp;#39;&amp;#39;);
    this.emit(depth, `POP RAX`);
    this.emit(depth, `TEST RAX, RAX`);
    this.emit(depth, `JZ .${branch}\n`);

    // Compile then section
    this.emit(depth, `# If then`);
    this.compileExpression(then, scope, depth);
    this.emit(depth, `JMP .after_${branch}\n`);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally we compile the else block if it exists, and otherwise we push
a zero onto the stack (possibly to represent null).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  compileIf([test, then, els], scope, depth) {
    this.emit(depth, &amp;#39;# If&amp;#39;);
    // Compile test
    this.compileExpression(test, scope, depth);
    const branch = `else_branch` + GLOBAL_COUNTER++;
    // Must pop/use up argument in test
    this.emit(0, &amp;#39;&amp;#39;);
    this.emit(depth, `POP RAX`);
    this.emit(depth, `TEST RAX, RAX`);
    this.emit(depth, `JZ .${branch}\n`);

    // Compile then section
    this.emit(depth, `# If then`);
    this.compileExpression(then, scope, depth);
    this.emit(depth, `JMP .after_${branch}\n`);

    // Compile else section
    this.emit(depth, `# If else`);
    this.emit(0, `.${branch}:`);
    if (els) {
      this.compileExpression(els, scope, depth);
    } else {
      this.emit(1, &amp;#39;PUSH 0 # Null else branch&amp;#39;);
    }
    this.emit(0, `.after_${branch}:`);
    this.emit(depth, &amp;#39;# End if&amp;#39;);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're ready for an interesting program! Let's print (to stdout)
the result of &lt;code&gt;fib(20)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="fibonacci"&gt;Fibonacci&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs lisp"&gt;$ cat ./tests/fib.lisp
(def fib (n)
     (if (&amp;lt; n 2)
       n
       (+ (fib (- n 1)) (fib (- n 2)))))

(def main ()
     (print (fib 20)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And check out the kernel:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;$ cat ./lib/kernel.lisp
(def print-char (c)
     (syscall/write 1 &amp;amp;c 1))

(def print (n)
     (if (&amp;gt; n 9)
       (print (/ n 10)))

     (print-char (+ 48 (% n 10))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compile and run it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node src/ulisp.js tests/fib.lisp --backend x86
$ ./build/prog
6765
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're in business!&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet" data-conversation="none"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post in the compiler basics series: an x86 upgrade. We&amp;#39;ve got basic syscall support, &amp;quot;infinite&amp;quot; locals and parameters, and if/else. More than enough to handle printing integers to stdout and recursive fibonacci. &lt;a href="https://t.co/B3OV0vEX1V"&gt;https://t.co/B3OV0vEX1V&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1203816831456284677?ref_src=twsrc%5Etfw"&gt;December 8, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-an-x86-upgrade.html</guid><pubDate>Sun, 08 Dec 2019 00:00:00 +0000</pubDate></item><item><title>Confusion and disengagement in meetings</title><link>http://notes.eatonphil.com/confusion-disengagement-in-meetings.html</link><description>&lt;p&gt;The quickest way to cut through confusion or disagreement among
otherwise amiable and honest folks is to ask questions.&lt;/p&gt;
&lt;p&gt;Ask early so you don't waste time. But it's not enough to just ask
clarifying questions because the &lt;strong&gt;answers&lt;/strong&gt; won't always be clear.&lt;/p&gt;
&lt;p&gt;Sounds like Human Interaction 101, and maybe it is. These techniques
show up more when discussing &lt;strong&gt;outcomes&lt;/strong&gt; and very rarely when
discussing &lt;strong&gt;assumptions&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Meetings are called to discuss outcomes, not assumptions. But
assumptions almost always need to be called into question too.&lt;/p&gt;
&lt;p&gt;If you have clarity personally but you observe confusion and
disengagement, &lt;strong&gt;ask questions and summarize&lt;/strong&gt;. Someone must be aware
of the group and be willing to sound dumb.&lt;/p&gt;
&lt;p&gt;If you aren't aware of confusion or disengagement, start paying
attention. Addressing doesn't need to be hard and is personally
meaningful.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Address confusion and disengagement in meetings by asking questions and summarizing, whether you&amp;#39;re confused or not. Question outcomes _and_ assumptions. &lt;a href="https://t.co/2OPifEBSq5"&gt;https://t.co/2OPifEBSq5&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1200972237756674049?ref_src=twsrc%5Etfw"&gt;December 1, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/confusion-disengagement-in-meetings.html</guid><pubDate>Sat, 30 Nov 2019 00:00:00 +0000</pubDate></item><item><title>Interpreting Go</title><link>http://notes.eatonphil.com/interpreting-go.html</link><description>&lt;p&gt;After spending some time at work on tooling for keeping documentation
in sync with Go struct definitions I had enough exposure to Go's
built-in parsing package that next steps were clear: write an
interpreter. &lt;a href="http://notes.eatonphil.com/interpreting-typescript.html"&gt;It's a great way to get more comfortable with a
language's
AST.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this post we'll use the Go parser package to interpret the AST
directly (as opposed to compiling to a bytecode VM) with enough to
support a recursive implementation of the fibonacci algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;package main

func fib(a int) int {
  if a == 1 {
    return 0
  }

  if a == 2 {
    return 1
  }

  return fib(a-1) + fib(a-2)
}

func main() {
  println(fib(15))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  You'll note this isn't actually valid Go because we are using an
  undefined function &lt;code&gt;println&lt;/code&gt;. We'll provide that for the
  runtime to make things easier on ourselves.
&lt;/p&gt;&lt;p&gt;The fibonacci algorithm is my goto minimal program that forces us to
deal with basic aspects of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function definitions&lt;/li&gt;
&lt;li&gt;Function calls&lt;/li&gt;
&lt;li&gt;Function arguments&lt;/li&gt;
&lt;li&gt;Function return values&lt;/li&gt;
&lt;li&gt;If/else&lt;/li&gt;
&lt;li&gt;Assignment&lt;/li&gt;
&lt;li&gt;Arithmetic and boolean operators&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We'll do this in around 200 LoC. Project code is available on
&lt;a href="https://github.com/eatonphil/goi"&gt;Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A follow-up post will cover support for an iterative fibonacci
implementation with support for basic aspects of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local variables&lt;/li&gt;
&lt;li&gt;Loops&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="first-steps"&gt;First steps&lt;/h3&gt;&lt;p&gt;I always start exploring an AST by practicing error-driven
development. It's helpful to have the Go
&lt;a href="https://golang.org/pkg/go/ast/"&gt;AST&lt;/a&gt;,
&lt;a href="https://golang.org/pkg/go/parser/"&gt;parser&lt;/a&gt;, and
&lt;a href="https://golang.org/pkg/go/token/"&gt;token&lt;/a&gt; package docs handy as well.&lt;/p&gt;
&lt;p&gt;We'll focus on single-file programs and start with
&lt;a href="https://golang.org/pkg/go/parser/#ParseFile"&gt;parser.ParseFile&lt;/a&gt;. This
function will return an
&lt;a href="https://golang.org/pkg/go/ast/#File"&gt;*ast.File&lt;/a&gt;. This in turn
contains a list of
&lt;a href="https://golang.org/pkg/go/ast/#Decl"&gt;Decl&lt;/a&gt;s. Unfortunately Go stops
being helpful at this point because we have no clue what is going to
implement this &lt;code&gt;Decl&lt;/code&gt; interface. So we'll switch on the
concrete type and error until we know what we need to know.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;package main

import (
  &amp;quot;go/ast&amp;quot;
  &amp;quot;go/parser&amp;quot;
  &amp;quot;go/token&amp;quot;
  &amp;quot;io/ioutil&amp;quot;
  &amp;quot;log&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;reflect&amp;quot;
)

func interpret(f *ast.File) {
  for _, decl := range f.Decls {
    switch d := decl.(type) {
    default:
      log.Fatalf(&amp;quot;Unknown decl type (%s): %+v&amp;quot;, reflect.TypeOf(d), d)
    }
  }
}

func main() {
  fset := token.NewFileSet() // positions are relative to fset

  src, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    log.Fatalf(&amp;quot;Unable to read file: %s&amp;quot;, err.Error())
  }

  f, err := parser.ParseFile(fset, os.Args[1], src, 0)
  if err != nil {
    log.Fatalf(&amp;quot;Unable to parse file: %s&amp;quot;, err.Error())
  }

  interpret(f)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build and run:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 09:43:48 Unknown decl type (*ast.FuncDecl): &amp;amp;{Doc:&amp;lt;nil&amp;gt; Recv:&amp;lt;nil&amp;gt; Name:fib Type:0xc000096320 Body:0xc00009a3c0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool! This is the declaration of the &lt;code&gt;fib&lt;/code&gt; function and its
type is &lt;a href="https://golang.org/pkg/go/ast/#FuncDecl"&gt;*ast.FuncDecl&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="interpreting-ast.funcdecl"&gt;Interpreting ast.FuncDecl&lt;/h3&gt;&lt;p&gt;A function declaration is going to need to add its name to a context
map, mapped to a function reference for use in function calls. Since
Go throws everything into the same context namespace this we can
simply pass around a map of strings to &lt;code&gt;value&lt;/code&gt;s where a
&lt;code&gt;value&lt;/code&gt; can be any Go value. To facilitate this, we'll
define a &lt;code&gt;value&lt;/code&gt; struct to hold an integer to represent
"kind" and an empty interface "value". When a value is referenced it
will have to switch on the "kind" and then cast the "value".&lt;/p&gt;
&lt;p&gt;Additionally, and unlike a value-oriented language like Scheme, we'll
need to track a set of &lt;code&gt;return&lt;/code&gt; values at all stages
through interpretation so, when set, we can short circuit execution.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;type kind uint

const (
  i64 kind = iota
  fn
  bl
)

type value struct {
  kind  kind
  value interface{}
}

type context map[string]value

func (c context) copy() context {
  cpy := context{}
  for key, value := range c {
    cpy[key] = value
  }

  return cpy
}

type ret struct {
  set bool
  vs  []value
}

func (r *ret) setValues(vs []value) {
  r.vs = vs
  r.set = true
}

func interpretFuncDecl(ctx context, r *ret, fd *ast.FuncDecl) {
  ctx[fd.Name.String()] = value{
    fn,
    func(ctx context, r *ret, args []value) {},
  }
}

func interpret(ctx context, f *ast.File) {
  for _, decl := range f.Decls {
    switch d := decl.(type) {
    case *ast.FuncDecl:
      interpretFuncDecl(ctx, nil, d)
    default:
      log.Fatalf(&amp;quot;Unknown decl type (%s): %+v&amp;quot;, reflect.TypeOf(d), d)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have the idea of return management and contexts set out,
let's fill out the actual function declaration callback. Inside we'll
need to copy the the context so variables declared inside the function
are not visible outside. Then we'll iterate over the parameters and
map them in context to the associated argument. Finally we'll
interpret the body.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretBlockStmt(ctx context, r *ret, fd *ast.BlockStmt) {}

func interpretFuncDecl(ctx context, r *ret, fd *ast.FuncDecl) {
  ctx[fd.Name.String()] = value{
    fn,
    func(ctx context, r *ret, args []value) {
      childCtx := ctx.copy()
      for i, param := range fd.Type.Params.List {
        childCtx[param.Names[0].String()] = args[i]
      }

      interpretBlockStmt(childCtx, r, fd.Body)
    },
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we'll add a call to the interpreted &lt;code&gt;main&lt;/code&gt; to the end
of the interpreter's &lt;code&gt;main&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func main() {
  fset := token.NewFileSet() // positions are relative to fset

  src, err := ioutil.ReadFile(os.Args[1])
  if err != nil {
    log.Fatalf(&amp;quot;Unable to read file: %s&amp;quot;, err.Error())
  }

  f, err := parser.ParseFile(fset, os.Args[1], src, 0)
  if err != nil {
    log.Fatalf(&amp;quot;Unable to parse file: %s&amp;quot;, err.Error())
  }

  ctx := context{}
  interpret(ctx, f)
  var r ret
  ctx[&amp;quot;main&amp;quot;].value.(func(context, *ret, []value))(ctx, &amp;amp;r, []value{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next step!&lt;/p&gt;
&lt;h3 id="interpreting-ast.blockstmt"&gt;Interpreting ast.BlockStmt&lt;/h3&gt;&lt;p&gt;For this AST node, we'll iterate over each statement and interpret
it. If the return value has been set we'll execute the loop to
short circuit execution.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretStmt(ctx context, r *ret, stmt ast.Stmt) {}

func interpretBlockStmt(ctx context, r *ret, bs *ast.BlockStmt) {
  for _, stmt := range bs.List {
    interpretStmt(ctx, r, stmt)
    if r.set {
      return
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next step!&lt;/p&gt;
&lt;h3 id="interpreting-ast.stmt"&gt;Interpreting ast.Stmt&lt;/h3&gt;&lt;p&gt;Since &lt;a href="https://golang.org/pkg/go/ast/#Stmt"&gt;ast.Stmt&lt;/a&gt; is another
interface, we're back to error-driven development.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretStmt(ctx context, r *ret, stmt ast.Stmt) {
  switch s := stmt.(type) {
  default:
    log.Fatalf(&amp;quot;Unknown stmt type (%s): %+v&amp;quot;, reflect.TypeOf(s), s)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the trigger:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:15:14 Unknown stmt type (*ast.ExprStmt): &amp;amp;{X:0xc0000a02c0}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! Checking the docs on
&lt;a href="https://golang.org/pkg/go/ast/#ExprStmt"&gt;ast.ExprStmt&lt;/a&gt; we'll just
skip directly to a call to a new function &lt;code&gt;interpretExpr&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretExpr(ctx context, r *ret, expr ast.Expr) {}

func interpretStmt(ctx context, r *ret, stmt ast.Stmt) {
  switch s := stmt.(type) {
  case *ast.ExprStmt:
    interpretExpr(ctx, r, s.X)
  default:
    log.Fatalf(&amp;quot;Unknown stmt type (%s): %+v&amp;quot;, reflect.TypeOf(s), s)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Moving on!&lt;/p&gt;
&lt;h3 id="interpreting-ast.expr"&gt;Interpreting ast.Expr&lt;/h3&gt;&lt;p&gt;We've got another
&lt;a href="https://golang.org/pkg/go/ast/#Expr"&gt;interface&lt;/a&gt;. Let's error!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretExpr(ctx context, r *ret, expr ast.Expr) {
  switch e := expr.(type) {
  default:
    log.Fatalf(&amp;quot;Unknown expr type (%s): %+v&amp;quot;, reflect.TypeOf(e), e)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the trigger:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:19:16 Unknown expr type (*ast.CallExpr): &amp;amp;{Fun:println Lparen:146 Args:[0xc0000a2280] Ellipsis:0 Rparen:154}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool! For a call we'll evaluate the arguments, evaluate the function
expression itself, cast the resulting value to a function, and call
it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretCallExpr(ctx context, r *ret, ce *ast.CallExpr) {
  var fnr ret
  interpretExpr(ctx, &amp;amp;fnr, ce.Fun)
  fn := fnr.values[0]

  values := []value{}
  for _, arg := range ce.Args {
    var vr ret
    interpretExpr(ctx, &amp;amp;vr, arg)
    values = append(values, vr.values[0])
  }

  fn.value.(func(context, *ret, []value))(ctx, r, values)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  All of this casting is unsafe because we aren't doing a
  type-checking stage. But we can ignore this because if a
  type-checking stage were introduced (which it need to be at some
  point), it would prevent bad casts from happening.
&lt;/p&gt;&lt;h3 id="handling-more-ast.expr-implementations"&gt;Handling more ast.Expr implementations&lt;/h3&gt;&lt;p&gt;Let's give the interpreter a shot again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:28:17 Unknown expr type (*ast.Ident): println
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll need to add &lt;a href="https://golang.org/pkg/go/ast/#Ident"&gt;ast.Ident&lt;/a&gt;
support to &lt;code&gt;interpretCallExpr&lt;/code&gt;. This will be a simple
lookup in context. We'll also add a &lt;code&gt;setValue&lt;/code&gt; helper since
the &lt;code&gt;ret&lt;/code&gt; value is serving double-duty as a value passing
mechanism and also a function's return value (solely where multiple
value are a thing).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;...


func (r *ret) setValue(v value) {
  r.values = []value{v}
  r.set = true
}

...

func interpretExpr(ctx context, r *ret, expr ast.Expr) {
  switch e := expr.(type) {
  case *ast.CallExpr:
    interpretCallExpr(ctx, r, e)
  case *ast.Ident:
    r.setValue(ctx[e.Name])
  default:
    log.Fatalf(&amp;quot;Unknown expr type (%s): %+v&amp;quot;, reflect.TypeOf(e), e)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is also a good time to add the &lt;code&gt;println&lt;/code&gt; builtin to
our top-level context.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func main() {
  ...

  ctx := context{}
  interpret(ctx, f)
  ctx["println"] = value{
    fn,
    func(ctx context, r *ret, args []value) {
      var values []interface{}
      for _, arg := range args {
        values = append(values, arg.value)
      }

      fmt.Println(values...)
    },
  }

  var r ret
  ctx["main"].value.(func(context, *ret, []value))(ctx, &amp;amp;r, []value{})
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="more-ast.expr-implementations"&gt;More ast.Expr implementations&lt;/h3&gt;&lt;p&gt;Running the interpreter again we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:41:59 Unknown expr type (*ast.BasicLit): &amp;amp;{ValuePos:151 Kind:INT Value:15}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Easy enough: we'll switch on the "kind" and parse a string int to an
int and wrap it in our value type.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretExpr(ctx context, r *ret, expr ast.Expr) {
  switch e := expr.(type) {
  case *ast.CallExpr:
    interpretCallExpr(ctx, r, e)
  case *ast.Ident:
    r.setValue(ctx[e.Name])
  case *ast.BasicLit:
    switch e.Kind {
    case token.INT:
      i, _ := strconv.ParseInt(e.Value, 10, 64)
      r.setValue(value{i64, i})
    default:
      log.Fatalf(&amp;quot;Unknown basiclit type: %+v&amp;quot;, e)
    }
  default:
    log.Fatalf(&amp;quot;Unknown expr type (%s): %+v&amp;quot;, reflect.TypeOf(e), e)
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we run again:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:48:46 Unknown stmt type (*ast.IfStmt): &amp;amp;{If:38 Init:&amp;lt;nil&amp;gt; Cond:0xc0000ac150 Body:0xc0000ac1b0 Else:&amp;lt;nil&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool, more control flow!&lt;/p&gt;
&lt;h3 id="interpreting-ast.ifstmt"&gt;Interpreting ast.IfStmt&lt;/h3&gt;&lt;p&gt;For &lt;a href="https://golang.org/pkg/go/ast/#IfStmt"&gt;ast.IfStmt&lt;/a&gt; we interpret
the condition and, depending on the condition, interpret the body or
the else node. In order to make empty else interpreting easier, we'll
also add a nil short-circuit to &lt;code&gt;interpretStmt&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretIfStmt(ctx context, r *ret, is *ast.IfStmt) {
  interpretStmt(ctx, nil, is.Init)

  var cr ret
  interpretExpr(ctx, &amp;amp;cr, is.Cond)
  c := cr.valus[0]

  if c.value.(bool) {
    interpretBlockStmt(ctx, r, is.Body)
    return
  }

  interpretStmt(ctx, r, is.Else)
}


func interpretStmt(ctx context, r *ret, stmt ast.Stmt) {
  if stmt == nil {
    return
  }

  switch s := stmt.(type) {
  case *ast.IfStmt:
    interpretIfStmt(ctx, r, s)

  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's try it out:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 10:56:28 Unknown expr type (*ast.BinaryExpr): &amp;amp;{X:a OpPos:43 Op:== Y:0xc00008a120}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great!&lt;/p&gt;
&lt;h3 id="interpreting-ast.binaryexpr"&gt;Interpreting ast.BinaryExpr&lt;/h3&gt;&lt;p&gt;An &lt;a href="https://golang.org/pkg/go/ast/#BinaryExpr"&gt;ast.BinaryExpr&lt;/a&gt; has an
&lt;code&gt;Op&lt;/code&gt; field that we'll switch on to decide what operations
to do. We'll interpret the left side and then the right side and
finally perform the operation and return the result. The three binary
operations we use in this program are &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;
and &lt;code&gt;-&lt;/code&gt;. We'll look these up in &lt;a href="https://golang.org/pkg/go/token/#Token"&gt;go/token
docs&lt;/a&gt; to discover the
associated constants.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretBinaryExpr(ctx context, r *ret, bexpr *ast.BinaryExpr) {
  var xr, yr ret
  interpretExpr(ctx, &amp;amp;xr, bexpr.X)
  x := xr.values[0]
  interpretExpr(ctx, &amp;amp;yr, bexpr.Y)
  y := yr.values[0]

  switch bexpr.Op {
  case token.ADD:
    r.setValue(value{i64, x.value.(int64) + y.value.(int64)})
  case token.SUB:
    r.setValue(value{i64, x.value.(int64) - y.value.(int64)})
  case token.EQL:
    r.setValue(value{bl, x.value.(int64) == y.value.(int64)})
  default:
    log.Fatalf(&amp;quot;Unknown binary expression type: %+v&amp;quot;, bexpr)
  }
}

func interpretExpr(ctx context, r *ret, expr ast.Expr) {
  switch e := expr.(type) {
  case *ast.BinaryExpr:
    interpretBinaryExpr(ctx, r, e)

  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's try one more time!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
2019/10/12 11:06:19 Unknown stmt type (*ast.ReturnStmt): &amp;amp;{Return:94 Results:[0xc000070540]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Awesome, last step.&lt;/p&gt;
&lt;h3 id="interpreting-ast.returnstmt"&gt;Interpreting ast.ReturnStmt&lt;/h3&gt;&lt;p&gt;Based on the
&lt;a href="https://golang.org/pkg/go/ast/#ReturnStmt"&gt;ast.ReturnStmt&lt;/a&gt; definition
we'll have to interpret each expression and set all of them to the
&lt;code&gt;ret&lt;/code&gt; value.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs golang"&gt;func interpretReturnStmt(ctx context, r *ret, s *ast.ReturnStmt) {
  var values []value
  for _, expr := range s.Results {
    var r ret
    interpretExpr(ctx, &amp;amp;r, expr)
    values = append(values, r.values[0])
  }

  r.setValues(values)

  return
}

func interpretStmt(ctx context, r *ret, stmt ast.Stmt) {
  if stmt == nil {
    return
  }

  switch s := stmt.(type) {
  case *ast.ReturnStmt:
    interpretReturnStmt(ctx, r, s)

  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And let's try one last time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ go build goi.go
$ ./goi fib.go
377
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking good. :) Let's try with another input:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat fib.go
package main

func fib(a int) int {
  if a == 1 {
    return 0
  }

  if a == 2 {
    return 1
  }

  return fib(a-1) + fib(a-2)
}

func main() {
  println(fib(14))
}
$ ./goi fib.go
233
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We've got the basics of an interpreter for Golang.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet" data-conversation="none"&gt;&lt;p lang="en" dir="ltr"&gt;Here&amp;#39;s a blog post on building a simple AST interpreter for Go to support running a recursive fibonacci implementation &lt;a href="https://t.co/5Zz388d8ZN"&gt;https://t.co/5Zz388d8ZN&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1183039387170430976?ref_src=twsrc%5Etfw"&gt;October 12, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/interpreting-go.html</guid><pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate></item><item><title>Administering Kubernetes is hard</title><link>http://notes.eatonphil.com/administering-kubernetes-is-hard.html</link><description>&lt;p&gt;Kubernetes is easy to use after some exposure; it's pretty convenient
too. But it is super hard to set up.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://eksctl.io"&gt;eksctl&lt;/a&gt; is a good tool for folks who don't want to
spend hours/days/weeks debugging VPC configuration in 1000s of lines
of CloudFormation. None of the other tools seem to be that much easier
to use (kops, kubeadm, etc.).&lt;/p&gt;
&lt;p&gt;But even with EKS and eksctl you are constrained to Amazon Linux
worker nodes. AMIs are practically impossible to discover.&lt;/p&gt;
&lt;p&gt;I haven't spent much time with GKE.&lt;/p&gt;
&lt;p&gt;And while eksctl operates on the right level for developers needing to
administrate small/medium-sized systems, it... doesn't exist outside
EKS.&lt;/p&gt;
&lt;p&gt;It is unfortunate the only major container orchestration system is
this complex to administer. The user-facing APIs are pretty solid and
guide toward sustainable system design. It is &lt;em&gt;really&lt;/em&gt; hard to see the
value for most companies with medium-sized deployments tasked with
administration. Among serious proprietary alternatives, sure, there's
ECS and Google App Engine. But there's little advantage in existing
Kubernetes user knowledge. The OSS alternatives don't have the
adoption to seem like a good investment.&lt;/p&gt;
&lt;p&gt;OpenStack's &lt;a href="https://wiki.openstack.org/wiki/Magnum"&gt;magnum&lt;/a&gt; or
OpenShift seem like possible high-level providers for a generic
environment. But neither are particularly known for stability.&lt;/p&gt;
&lt;p&gt;In all, the ecosystem has gotten friendlier. There will probably be a
time in the future (3-5 years from now?) when Kubernetes is fairly
easy to administer.&lt;/p&gt;
&lt;p&gt;I'd love to hear your thoughts and experiences administering
Kubernetes.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/administering-kubernetes-is-hard.html</guid><pubDate>Mon, 30 Sep 2019 00:00:00 +0000</pubDate></item><item><title>Unit testing C code with gtest</title><link>http://notes.eatonphil.com/unit-testing-c-code-with-gtest.html</link><description>&lt;p&gt;This post covers building and testing a minimal, but still useful, C
project. We'll use &lt;a href="https://github.com/google/googletest"&gt;Google's
gtest&lt;/a&gt; and
&lt;a href="https://cmake.org"&gt;CMake&lt;/a&gt; for testing C code. This will serve as a
foundation for some upcoming posts/projects on programming Linux,
userland networking and interpreters.&lt;/p&gt;
&lt;p class="note"&gt;
  The first version of this post only included one module to
  test. The &lt;code&gt;test/CMakeLists.txt&lt;/code&gt; would also only expose a
  single pass-fail status for all modules. The second version of this
  post extends the &lt;code&gt;test/CMakeLists.txt&lt;/code&gt; to expose
  each &lt;code&gt;test/*.cpp&lt;/code&gt; file as its own CMake test so that
  results are displayed by &lt;code&gt;ctest&lt;/code&gt; per file. The second
  version also splits the original &lt;code&gt;src/testy.c&lt;/code&gt;
  and &lt;code&gt;include/testy/testy.h&lt;/code&gt; module into
  a &lt;code&gt;widget&lt;/code&gt; and &lt;code&gt;customer&lt;/code&gt; module to
  demonstrate the changes to the CMake configuration.
&lt;/p&gt;&lt;h3 id="the-"testy"-sample-project"&gt;The "testy" sample project&lt;/h3&gt;&lt;p&gt;In this project, we'll put source code in &lt;code&gt;src/&lt;/code&gt; and publicly
exported symbols (functions, structs, etc.) in header files in
&lt;code&gt;include/testy/&lt;/code&gt;. There will be a &lt;code&gt;main.c&lt;/code&gt; in the &lt;code&gt;src/&lt;/code&gt;
directory. Tests are written in C++ (since gtest is a C++ testing
framework) and are in the &lt;code&gt;test/&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Here's an overview of the source and test code.&lt;/p&gt;
&lt;h4 id="src/widget.c"&gt;src/widget.c&lt;/h4&gt;&lt;p&gt;This file has some library code that we should be able to test.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#include &amp;quot;testy/widget.h&amp;quot;

int private_ok_value = 2;

int widget_ok(int a, int b) {
  return a + b == private_ok_value;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="include/testy/widget.h"&gt;include/testy/widget.h&lt;/h4&gt;&lt;p&gt;This file handles exported symbols for widget code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#ifndef _WIDGET_H_
#define _WIDGET_H_

int widget_ok(int, int);

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="src/customer.c"&gt;src/customer.c&lt;/h4&gt;&lt;p&gt;This file has some more library code that we should be able to test.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#include &amp;quot;testy/customer.h&amp;quot;

int customer_check(int a) {
  return a == 5;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="include/testy/customer.h"&gt;include/testy/customer.h&lt;/h4&gt;&lt;p&gt;This file handles exported symbols for customer code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#ifndef _CUSTOMER_H_
#define _CUSTOMER_H_

int customer_check(int);

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="src/main.c"&gt;src/main.c&lt;/h4&gt;&lt;p&gt;This is the entrypoint to a program built around libtesty.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c"&gt;#include &amp;quot;testy/customer.h&amp;quot;
#include &amp;quot;testy/widget.h&amp;quot;

int main() {
  if (widget_ok(1, 1)) {
    return customer_check(5);
  }

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="test/widget.cpp"&gt;test/widget.cpp&lt;/h4&gt;&lt;p&gt;This is one of our test files. It registers test cases and uses gtest
to make assertions. We need to wrap the &lt;code&gt;testy/widget.h&lt;/code&gt; include in an
&lt;code&gt;extern "C"&lt;/code&gt; to stop C++ from
&lt;a href="https://www.geeksforgeeks.org/extern-c-in-c/"&gt;name-mangling&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;quot;gtest/gtest.h&amp;quot;

extern &amp;quot;C&amp;quot; {
#include &amp;quot;testy/widget.h&amp;quot;
}

TEST(widget, ok) {
  ASSERT_EQ(widget_ok(1, 1), 1);
}

TEST(testy, not_ok) {
  ASSERT_EQ(widget_ok(1, 2), 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see a good high-level overview of gtest testing utilities like
&lt;code&gt;ASSERT_EQ&lt;/code&gt; and &lt;code&gt;TEST&lt;/code&gt;
&lt;a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="test/customer.cpp"&gt;test/customer.cpp&lt;/h4&gt;&lt;p&gt;This is another one of our test files.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;quot;gtest/gtest.h&amp;quot;

extern &amp;quot;C&amp;quot; {
#include &amp;quot;testy/customer.h&amp;quot;
}

TEST(customer, ok) {
  ASSERT_EQ(customer_check(5), 1);
}

TEST(testy, not_ok) {
  ASSERT_EQ(customer_check(0), 0);  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="test/main.cpp"&gt;test/main.cpp&lt;/h4&gt;&lt;p&gt;This is a standard entrypoint for the test runner.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;quot;gtest/gtest.h&amp;quot;

int main(int argc, char **argv) {
  ::testing::InitGoogleTest(&amp;amp;argc, argv);
  return RUN_ALL_TESTS();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="building-with-cmake"&gt;Building with CMake&lt;/h3&gt;&lt;p&gt;&lt;a href="https://cmake.org"&gt;CMake&lt;/a&gt; is a build tool that (among other things)
produces a Makefile we can run to build our code. We will also use it
for dependency management. But fundementally we use it because gtest
requires it.&lt;/p&gt;
&lt;p&gt;CMake options/rules are defined in a CMakeLists.txt file. We'll have
one in the root directory, one in the test directory, and a template
for one that will handle the gtest dependency.&lt;/p&gt;
&lt;p&gt;A first draft of the top-level CMakeLists.txt might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cmake"&gt;cmake_minimum_required(VERSION 3.1)

project(testy)

##
### Source definitions ###
##

include_directories(&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;)

file(GLOB sources &amp;quot;${PROJECT_SOURCE_DIR}/src/*.c&amp;quot;)

add_executable(testy ${sources})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;include_directory&lt;/code&gt; will make sure we compile with the &lt;code&gt;-I&lt;/code&gt; flag
set up correctly for our include directory.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;add_executable&lt;/code&gt; sets up the binary name to produce from the
given sources. And we're using the &lt;code&gt;file&lt;/code&gt; helper to get a glob match
of C files rather than listing them all out verbatim in the
&lt;code&gt;add_executable&lt;/code&gt; call.&lt;/p&gt;
&lt;h4 id="building-and-running"&gt;Building and running&lt;/h4&gt;&lt;p&gt;CMake pollutes the current directory, and is fine running in a
different directory, so we'll make a &lt;code&gt;build/&lt;/code&gt; directory so we don't
pollute root. Then we'll build a Makefile with CMake, run Make, and
run our program.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is AppleClang 10.0.1.10010046
-- The CXX compiler identification is AppleClang 10.0.1.10010046
-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc
-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++
-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/philipeaton/tmp/testy/build
$ make
[ 25%] Building C object CMakeFiles/testy.dir/src/customer.c.o
[ 50%] Building C object CMakeFiles/testy.dir/src/widget.c.o
[ 75%] Building C object CMakeFiles/testy.dir/src/main.c.o
[100%] Linking C executable testy
[100%] Built target testy
$ ./testy
$ echo $?
1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="cmakelists.txt.in"&gt;CMakeLists.txt.in&lt;/h3&gt;&lt;p&gt;This template file handles downloading the gtest dependency from
github.com pinned to a release. It will be copied into a subdirectory
during the &lt;code&gt;cmake ..&lt;/code&gt; step.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cmake"&gt;cmake_minimum_required(VERSION 3.1)

project(googletest-download NONE)

include(ExternalProject)
ExternalProject_Add(googletest
  GIT_REPOSITORY    https://github.com/google/googletest.git
  GIT_TAG           release-1.8.1
  SOURCE_DIR        &amp;quot;${CMAKE_BINARY_DIR}/googletest-src&amp;quot;
  BINARY_DIR        &amp;quot;${CMAKE_BINARY_DIR}/googletest-build&amp;quot;
  CONFIGURE_COMMAND &amp;quot;&amp;quot;
  BUILD_COMMAND     &amp;quot;&amp;quot;
  INSTALL_COMMAND   &amp;quot;&amp;quot;
  TEST_COMMAND      &amp;quot;&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can tell CMake about it and how to build, within the top-level
CMakeLists.txt file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cmake"&gt;cmake_minimum_required(VERSION 3.1)

project(testy)

##
### Test definitions ###
##

configure_file(CMakeLists.txt.in
        googletest-download/CMakeLists.txt)
execute_process(COMMAND ${CMAKE_COMMAND} -G &amp;quot;${CMAKE_GENERATOR}&amp;quot; .
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/googletest-download )
execute_process(COMMAND ${CMAKE_COMMAND} --build .
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}/googletest-download )

add_subdirectory(${CMAKE_BINARY_DIR}/googletest-src
        ${CMAKE_BINARY_DIR}/googletest-build)

enable_testing()
add_subdirectory(test)

##
### Source definitions ###
##

include_directories(&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;)

file(GLOB sources
  &amp;quot;${PROJECT_SOURCE_DIR}/include/testy/*.h&amp;quot;
  &amp;quot;${PROJECT_SOURCE_DIR}/src/*.c&amp;quot;)

add_executable(testy ${sources})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;add_subdirectory&lt;/code&gt; calls register a directory that contains its
own CMakeLists.txt. It would fail now without a &lt;code&gt;CMakeLists.txt&lt;/code&gt; file
in the &lt;code&gt;test/&lt;/code&gt; directory.&lt;/p&gt;
&lt;h3 id="test/cmakelists.txt"&gt;test/CMakeLists.txt&lt;/h3&gt;&lt;p&gt;This final file registers a &lt;code&gt;unit_test&lt;/code&gt; executable compiling against
the source and test code, and includes the project header files.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cmake"&gt;include_directories(&amp;quot;${PROJECT_SOURCE_DIR}/include&amp;quot;)

file(GLOB sources &amp;quot;${PROJECT_SOURCE_DIR}/src/*.c&amp;quot;)
list(REMOVE_ITEM sources &amp;quot;${PROJECT_SOURCE_DIR}/src/main.c&amp;quot;)

file(GLOB tests &amp;quot;${PROJECT_SOURCE_DIR}/test/*.cpp&amp;quot;)
list(REMOVE_ITEM tests &amp;quot;${PROJECT_SOURCE_DIR}/test/main.cpp&amp;quot;)

foreach(file ${tests})
  set(name)
  get_filename_component(name ${file} NAME_WE)
  add_executable(&amp;quot;${name}_tests&amp;quot;
    ${sources}
    ${file}
    &amp;quot;${PROJECT_SOURCE_DIR}/test/main.cpp&amp;quot;)
  target_link_libraries(&amp;quot;${name}_tests&amp;quot; gtest_main)
  add_test(NAME ${name} COMMAND &amp;quot;${name}_tests&amp;quot;)
endforeach()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have to register a test for each file otherwise each file's tests
won't show up by default (i.e. without a &lt;code&gt;--verbose&lt;/code&gt; flag).&lt;/p&gt;
&lt;h4 id="building-and-running-tests"&gt;Building and running tests&lt;/h4&gt;&lt;p&gt;Similar to building and running the source, we run CMake in a
subdirectory but run &lt;code&gt;make test&lt;/code&gt; or &lt;code&gt;ctest&lt;/code&gt; after building all sources
and tests with &lt;code&gt;make&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cd build
$ cmake ..
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/philipeaton/tmp/testy/build/googletest-download
Scanning dependencies of target googletest
[ 11%] Creating directories for &amp;#39;googletest&amp;#39;
[ 22%] Performing download step (git clone) for &amp;#39;googletest&amp;#39;
Cloning into &amp;#39;googletest-src&amp;#39;...
Note: checking out &amp;#39;release-1.8.1&amp;#39;.

You are in &amp;#39;detached HEAD&amp;#39; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &amp;lt;new-branch-name&amp;gt;

HEAD is now at 2fe3bd99 Merge pull request #1433 from dsacre/fix-clang-warnings
[ 33%] No patch step for &amp;#39;googletest&amp;#39;
[ 44%] Performing update step for &amp;#39;googletest&amp;#39;
[ 55%] No configure step for &amp;#39;googletest&amp;#39;
[ 66%] No build step for &amp;#39;googletest&amp;#39;
[ 77%] No install step for &amp;#39;googletest&amp;#39;
[ 88%] No test step for &amp;#39;googletest&amp;#39;
[100%] Completed &amp;#39;googletest&amp;#39;
[100%] Built target googletest
-- Found PythonInterp: /usr/local/bin/python (found version &amp;quot;2.7.16&amp;quot;)
-- Looking for pthread.h
-- Looking for pthread.h - found
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD
-- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Success
-- Found Threads: TRUE
-- Configuring done
-- Generating done
-- Build files have been written to: /Users/philipeaton/tmp/testy/build
$ make
[  4%] Building C object CMakeFiles/testy.dir/src/customer.c.o
[  9%] Building C object CMakeFiles/testy.dir/src/widget.c.o
[ 13%] Building C object CMakeFiles/testy.dir/src/main.c.o
[ 18%] Linking C executable testy
[ 18%] Built target testy
[ 22%] Building CXX object googletest-build/googlemock/gtest/CMakeFiles/gtest.dir/src/gtest-all.cc.o
[ 27%] Linking CXX static library libgtest.a
[ 27%] Built target gtest
[ 31%] Building CXX object googletest-build/googlemock/CMakeFiles/gmock.dir/src/gmock-all.cc.o
[ 36%] Linking CXX static library libgmock.a
[ 36%] Built target gmock
[ 40%] Building CXX object googletest-build/googlemock/CMakeFiles/gmock_main.dir/src/gmock_main.cc.o
[ 45%] Linking CXX static library libgmock_main.a
[ 45%] Built target gmock_main
[ 50%] Building CXX object googletest-build/googlemock/gtest/CMakeFiles/gtest_main.dir/src/gtest_main.cc.o
[ 54%] Linking CXX static library libgtest_main.a
[ 54%] Built target gtest_main
[ 59%] Building C object test/CMakeFiles/customer_tests.dir/__/src/customer.c.o
[ 63%] Building C object test/CMakeFiles/customer_tests.dir/__/src/widget.c.o
[ 68%] Building CXX object test/CMakeFiles/customer_tests.dir/customer.cpp.o
[ 72%] Building CXX object test/CMakeFiles/customer_tests.dir/main.cpp.o
[ 77%] Linking CXX executable customer_tests
[ 77%] Built target customer_tests
Scanning dependencies of target widget_tests
[ 81%] Building C object test/CMakeFiles/widget_tests.dir/__/src/customer.c.o
[ 86%] Building C object test/CMakeFiles/widget_tests.dir/__/src/widget.c.o
[ 90%] Building CXX object test/CMakeFiles/widget_tests.dir/widget.cpp.o
[ 95%] Building CXX object test/CMakeFiles/widget_tests.dir/main.cpp.o
[100%] Linking CXX executable widget_tests
[100%] Built target widget_tests
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After running &lt;code&gt;cmake&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt;, we're finally ready to run &lt;code&gt;ctest&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ ctest
Test project /Users/philipeaton/tmp/testy/build
    Start 1: customer
1/2 Test #1: customer ..........................   Passed    0.01 sec
    Start 2: widget
2/2 Test #2: widget ............................   Passed    0.00 sec

100% tests passed, 0 tests failed out of 2

Total Test time (real) =   0.01 sec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we're in a good place with most of the challenges of unit testing
C code (i.e. ignoring mocks) past us.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;In preparation for a couple new articles on some C projects, here&amp;#39;s a foundational post on building C code and writing/running unit tests with gtest and cmake &lt;a href="https://t.co/aMVyr7LO73"&gt;https://t.co/aMVyr7LO73&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1167826536298405894?ref_src=twsrc%5Etfw"&gt;August 31, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/unit-testing-c-code-with-gtest.html</guid><pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate></item><item><title>Writing an x86 emulator from scratch in JavaScript: 2. system calls</title><link>http://notes.eatonphil.com/emulator-basics-system-calls.html</link><description>&lt;p class="note"&gt;
  Previously in emulator basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/emulator-basics-a-stack-and-register-machine.html"&gt;1. a stack and register machine&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll extend &lt;a href="https://github.com/eatonphil/x86e"&gt;x86e&lt;/a&gt; to
support the exit and write Linux system calls, or syscalls. A syscall
is a function handled by the kernel that allows the process to
interact with data outside of its memory. The &lt;code&gt;SYSCALL&lt;/code&gt;
instruction takes arguments in the same order that the
regular &lt;code&gt;CALL&lt;/code&gt; instruction does.  But &lt;code&gt;SYSCALL&lt;/code&gt;
additionally requires the &lt;code&gt;RAX&lt;/code&gt; register to contain the
integer number of the syscall.&lt;/p&gt;
&lt;p&gt;Historically, there have been a number of different ways to make
syscalls. All methods perform variations on a software interrupt.
Before AMD64, on x86 processors, there was the &lt;code&gt;SYSENTER&lt;/code&gt;
instruction. And before that there there was only &lt;code&gt;INT 80h&lt;/code&gt;
to trigger the interrupt with the syscall handler (since interrupts
can be used for more than just syscalls).  The various instructions
around interrupts have been added for efficiency as the processors and
use by operating systems evolved.&lt;/p&gt;
&lt;p&gt;Since this is a general need and AMD64 processors are among the most
common today, you'll see similar code in every modern operating system
such as FreeBSD, OpenBSD, NetBSD, macOS, and Linux. (I have no
background in Windows.) The calling convention may differ (e.g. which
arguments are in which registers) and the syscall numbers differ.
Even within Linux both the calling convention and the syscall numbers
differ between x86 (32-bit) and AMD64/x86_64 (64-bit) versions.&lt;/p&gt;
&lt;p&gt;See this &lt;a href="https://stackoverflow.com/a/15169141/1507139"&gt;StackOverflow
post&lt;/a&gt; for some more
detail.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/eatonphil/2d16bc3dae33bff8a8d7f2a9d13025c3"&gt;Code for this post in full is available as a
Gist.&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="exit"&gt;Exit&lt;/h4&gt;&lt;p&gt;The exit syscall is how a child process communicates with the process
that spawned it (its parent) when the child is finished running. Exit
takes one argument, called the exit code or status code. It is an
arbitrary signed 8-bit integer. If the high bit is set (i.e. the
number is negative), this is interpreted to mean the process exited
abnormally such as due to a segfault. Shells additionally
interpret any non-zero exit code as a "failure". Otherwise, and
ignoring these two common conventions, it can be used to mean anything
the programmer wants.&lt;/p&gt;
&lt;p class="note"&gt;
  The wait syscall is how the parent process can block until exit is
  called by the child and receive its exit code.
&lt;/p&gt;&lt;p&gt;On AMD64 Linux the syscall number is 60. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  MOV RDI, 0
  MOV RAX, 60
  SYSCALL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This calls exit with a status code of 0.&lt;/p&gt;
&lt;h4 id="write"&gt;Write&lt;/h4&gt;&lt;p&gt;The write syscall is how a process can send data to file descriptors,
which are integers representing some file-like object. By default, a
Linux process is given access to three file descriptors with
consistent integer values: stdin is 0, stdout is 1, and stderr is 2.
Write takes three arguments: the file descriptor integer to write
to, a starting address to memory that is interpreted as a byte array,
and the number of bytes to write to the file descriptor beginning at
the start address.&lt;/p&gt;
&lt;p&gt;On AMD64 Linux the syscall number is 1. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  MOV RDI, 1   ; stdout
  MOV RSI, R12 ; address of string
  MOV RDX, 8   ; 8 bytes to write
  MOV RAX, 1   ; write
  SYSCALL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This writes 8 bytes to stdout starting from the string whose address
is in R12.&lt;/p&gt;
&lt;h3 id="implementing-syscalls"&gt;Implementing syscalls&lt;/h3&gt;&lt;p&gt;Our emulator is simplistic and is currently only implementing process
emulation, not full CPU emulation. So the syscalls themselves will be
handled in JavaScript. First we'll write out stubs for the two
syscalls we are adding. And we'll provide a map from syscall id to the
syscall.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const SYSCALLS_BY_ID = {
  1: function sys_write(process) {},
  60: function sys_exit(process) {},
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to add an instruction handler to our instruction switch. In
doing so we must convert the value in &lt;code&gt;RAX&lt;/code&gt; from a BigInt
to a regular Number so we can look it up in the syscall map.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;syscall&amp;#39;: {
        const idNumber = Number(process.registers.RAX);
        SYSCALLS_BY_ID[idNumber](process);
        process.registers.RIP++;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="exit"&gt;Exit&lt;/h4&gt;&lt;p&gt;Exit is really simple. It will be implemented by calling Node's
&lt;code&gt;global.process.exit()&lt;/code&gt;. Again we'll need to convert the
register's BigInt value to a Number.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const SYSCALLS_BY_ID = {
  1: function sys_write(process) {},
  60: function sys_exit(process) {
    global.process.exit(Number(process.registers.RDI));
  },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="write"&gt;Write&lt;/h4&gt;&lt;p&gt;Write will be implemented by iterating over the process memory as
bytes and by calling &lt;code&gt;write()&lt;/code&gt; on the relevant file
descriptor. We'll store a map of these on the process object and
supply stdout, stderr, and stdin proxies on startup.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function main(file) {
  ...

  const process = {
    registers,
    memory,
    instructions,
    labels,
    fd: {
      // stdout
      1: global.process.stdout,
    }
  };

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The base address is stored in &lt;code&gt;RSI&lt;/code&gt;, the number of bytes to
write are stored in &lt;code&gt;RDX&lt;/code&gt;. And the file descriptor to write
to is stored in &lt;code&gt;RDI&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const SYSCALLS_BY_ID = {
  1: function sys_write(process) {
    const msg = BigInt(process.registers.RSI);
    const bytes = Number(process.registers.RDX);
    for (let i = 0; i &amp;lt; bytes; i++) {
      const byte = readMemoryBytes(process, msg + BigInt(i), 1);
      const char = String.fromCharCode(Number(byte));
      process.fd[Number(process.registers.RDI)].write(char);
    }
  },
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="all-together"&gt;All together&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat exit3.asm
main:
  MOV RDI, 1
  MOV RSI, 2
  ADD RDI, RSI

  MOV RAX, 60 ; exit
  SYSCALL
$ node emulator.js exit3.asm
$ echo $?
3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat hello.asm
main:
  PUSH 10  ; \n
  PUSH 33  ; !
  PUSH 111 ; o
  PUSH 108 ; l
  PUSH 108 ; l
  PUSH 101 ; e
  PUSH 72  ; H

  MOV RDI, 1   ; stdout
  MOV RSI, RSP ; address of string
  MOV RDX, 56  ; 7 8-bit characters in the string but PUSH acts on 64-bit integers
  MOV RAX, 1   ; write
  SYSCALL

  MOV RDI, 0
  MOV RAX, 60
  SYSCALL
$ node emulator.js hello.asm
Hello!
$
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="next-steps"&gt;Next steps&lt;/h3&gt;&lt;p&gt;We still aren't setting flags appropriately to support conditionals,
so that's low-hanging fruit. There are some other fun syscalls to
implement that would also give us access to an emulated VGA card so we
could render graphics. Syntactic support for string constants would
also be convenient and more efficient.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post in the emulator basics series up: implementing some syscalls starting with sys_exit and sys_write so we can print a nice hello message. &lt;a href="https://t.co/NEfId0lnJx"&gt;https://t.co/NEfId0lnJx&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/javascript?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#javascript&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/x86?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#x86&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1152689255900176386?ref_src=twsrc%5Etfw"&gt;July 20, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/emulator-basics-system-calls.html</guid><pubDate>Sat, 20 Jul 2019 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 6. LLVM system calls</title><link>http://notes.eatonphil.com/compiler-basics-llvm-system-calls.html</link><description>&lt;p class="note"&gt;
  Previously in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-lisp-to-assembly.html"&gt;1. lisp to assembly&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-functions.html"&gt;2. user-defined functions and variables&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm.html"&gt;3. LLVM&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-conditionals.html"&gt;4. LLVM conditionals and compiling fibonacci&lt;/a&gt;
  &lt;br /&gt;
  Next in compiler basics:
  &lt;br /&gt;
  &lt;a href="/compiler-basics-an-x86-upgrade.html"&gt;5. an x86 upgrade&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll extend the &lt;a href="https://github.com/eatonphil/ulisp"&gt;ulisp
compiler&lt;/a&gt;'s LLVM backend to
support printing integers to stdout.&lt;/p&gt;
&lt;h3 id="exit-code-limitations"&gt;Exit code limitations&lt;/h3&gt;&lt;p&gt;Until now we've validated program state by setting the exit code to
the result of the program computation. But the exit code is an eight
bit integer. What if we want to validate a computation that produces
a result larger than 255?&lt;/p&gt;
&lt;p&gt;To do this we need a way to print integers. This is challenging
because printing normally deals with byte arrays. libc's
&lt;code&gt;printf&lt;/code&gt;, for example, takes a byte array as its first
argument.&lt;/p&gt;
&lt;p&gt;The shortest path forward is to add support for system calls so we can
print one character at a time. Here's a version of a &lt;code&gt;print&lt;/code&gt;
form that hacks around not having arrays to send each integer in a
number to stdout.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def print-char (c)
     ; First argument is stdout
     ; Second argument is a pointer to a char array (of length one)
     ; Third argument is the length of the char array
     (syscall/sys_write 1 &amp;amp;c 1))

(def print (n)
     (if (&amp;gt; n 9)
         (print (/ n 10)))

     ; 48 is the ASCII code for &amp;#39;0&amp;#39;
     (print-char (+ 48 (% n 10))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to support this we need to add the
&lt;code&gt;syscall/sys_write&lt;/code&gt;, &lt;code&gt;&gt;&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;,
and &lt;code&gt;/&lt;/code&gt; builtin forms. We'll also need to add support for
taking the address of a variable.&lt;/p&gt;
&lt;p&gt;All &lt;a href="https://github.com/eatonphil/ulisp"&gt;code is available on Github&lt;/a&gt;
as is the &lt;a href="https://github.com/eatonphil/ulisp/commit/213b83b8e952c210ba408bf38e59ae677d19e643"&gt;particular commit related to this
post&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="references"&gt;References&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;sys_write&lt;/code&gt; syscall requires us to pass the memory
address of the byte array to write. We don't support arrays, but we
can treat an individual variable as an array of length one by passing
the variable's address.&lt;/p&gt;
&lt;p&gt;If we were compiling to C we could just pass the address of a local
variable. But LLVM doesn't allow us to take the address of variables
directly. We need to push the variable onto the LLVM stack to get an
address.&lt;/p&gt;
&lt;p class="note"&gt;
  Under the hood LLVM will likely optimize this into a local variable
  reference instead of first pushing to the stack.
&lt;/p&gt;&lt;p&gt;Since LLVM IR is typed, the value representing the address of a local
variable will be a pointer type. We'll need to refer to all uses of
this value as a pointer. So we'll need to modify ulisp to track local
types rather than hard-coding &lt;code&gt;i64&lt;/code&gt; everywhere.&lt;/p&gt;
&lt;h4 id="scope"&gt;Scope&lt;/h4&gt;&lt;p&gt;To begin we'll modify the &lt;code&gt;Scope&lt;/code&gt; class to track types. We
only need to do this on registration. Afterward, we'll have to find
all uses of local variables to make sure they use the
local's &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; fields appropriately.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {

  ...

  register(local) {
    let copy = local.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);
    let n = 1;
    while (this.locals[copy]) {
      copy = local + n++;
    }

    this.locals[local] = {
      value: copy,
      type: &amp;#39;i64&amp;#39;,
    };
    return this.locals[local];
  }

  ...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We won't go through every use of a &lt;code&gt;Scope&lt;/code&gt; variable in this
post, but you can find it in the related &lt;a href="https://github.com/eatonphil/ulisp/commit/213b83b8e952c210ba408bf38e59ae677d19e643"&gt;commit to
ulisp&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id="reference"&gt;Reference&lt;/h4&gt;&lt;p&gt;The long-term approach for handling a reference syntactically is
probably to rewrite &lt;code&gt;&amp;x&lt;/code&gt; to &lt;code&gt;(&amp; x)&lt;/code&gt; in the
parser. The lazy approach we'll take for now is to handle a reference
as a special kind of identifier in &lt;code&gt;compileExpression&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We'll use the LLVM &lt;code&gt;alloca&lt;/code&gt; instruction to create space on
the stack. This will return a pointer and will turn the destination
variable into a pointer type. Then we'll use &lt;code&gt;store&lt;/code&gt; to set
the value at the address to the current value of the variable being
referenced.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {

  ...

  compileExpression(exp, destination, context) {

    ...

    // Is a reference, push onto the stack and return its address
    if (exp.startsWith(&amp;#39;&amp;amp;&amp;#39;)) {
      const symbol = exp.substring(1);
      const tmp = context.scope.symbol();
      this.compileExpression(symbol, tmp, context);
      this.emit(1, `%${destination.value} = alloca ${tmp.type}, align 4`);
      destination.type = tmp.type + &amp;#39;*&amp;#39;;
      this.emit(1, `store ${tmp.type} %${tmp.value}, ${destination.type} %${destination.value}, align 4`);
      return;
    }

    ...

  }

  ...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we're set to take the address of any code.&lt;/p&gt;
&lt;h3 id="system-calls"&gt;System calls&lt;/h3&gt;&lt;p&gt;LLVM IR provides no high-level means for making system calls. The
only way is to use inline assembly. This syntax is based on GCC inline
assembly and is confusing, with few explained examples, and unhelpful
error messages.&lt;/p&gt;
&lt;p&gt;Thankfully the assembly code needed for a syscall is only one line,
one word: the &lt;code&gt;syscall&lt;/code&gt; assembly instruction. We use inline
assembly variable-to-register mapping functionality to line up all the
parameters for the syscall. Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;%result = call i64 asm sideeffect &amp;quot;syscall&amp;quot;, &amp;quot;=r,{rax},{rdi},{rsi},{rdx}&amp;quot; (i64 %raxArg, i64 %rdiArg, i64 %rsiArg, i64 %rdxArg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This says to execute the inline assembly string,
"syscall". The &lt;code&gt;sideeffect&lt;/code&gt; flag means that this assembly
should always be run even if the result isn't used. &lt;code&gt;=r&lt;/code&gt;
means the inline assembly returns a value, and the rest of the string
is the list of registers that arguments should be mapped to. Finally
we call the function with all the LLVM variables we want to be mapped.&lt;/p&gt;
&lt;p class="note"&gt;
  Eventually we should also use the inline assembly syntax to list
  registers that are modified so that LLVM can know to save them
  before and after.
&lt;/p&gt;&lt;h4 id="code"&gt;Code&lt;/h4&gt;&lt;p&gt;We'll add a mapping for &lt;code&gt;syscall/sys_write&lt;/code&gt; and a helper
function for generating syscall code using the example above as a
template. We'll suport 64-bit Darwin and Linux kernels.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const SYSCALL_TABLE = {
  darwin: {
    sys_write: 0x2000004,
    sys_exit: 0x2000001,
  },
  linux: {
    sys_write: 1,
    sys_exit: 60,
  },
}[process.platform];

class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;if&amp;#39;: this.compileIf.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),
      &amp;#39;*&amp;#39;: this.compileOp(&amp;#39;mul&amp;#39;),
      &amp;#39;%&amp;#39;: this.compileOp(&amp;#39;urem&amp;#39;),
      &amp;#39;&amp;lt;&amp;#39;: this.compileOp(&amp;#39;icmp slt&amp;#39;),
      &amp;#39;=&amp;#39;: this.compileOp(&amp;#39;icmp eq&amp;#39;),
      &amp;#39;syscall/sys_write&amp;#39;: this.compileSyscall(SYSCALL_TABLE.sys_write),
    };
  }

  ...

  compileSyscall(id) {
    return (args, destination, context) =&amp;gt; {
      const argTmps = args.map((arg) =&amp;gt; {
          const tmp = context.scope.symbol();
          this.compileExpression(arg, tmp, context);
          return tmp.type + &amp;#39; %&amp;#39; + tmp.value;
      }).join(&amp;#39;, &amp;#39;);
      const regs = [&amp;#39;rdi&amp;#39;, &amp;#39;rsi&amp;#39;, &amp;#39;rdx&amp;#39;, &amp;#39;r10&amp;#39;, &amp;#39;r8&amp;#39;, &amp;#39;r9&amp;#39;];
      const params = args.map((arg, i) =&amp;gt; `{${regs[i]}}`).join(&amp;#39;,&amp;#39;);
      const idTmp = context.scope.symbol().value;
      this.emit(1, `%${idTmp} = add i64 ${id}, 0`)
      this.emit(1, `%${destination.value} = call ${destination.type} asm sideeffect &amp;quot;syscall&amp;quot;, &amp;quot;=r,{rax},${params},~{dirflag},~{fpsr},~{flags}&amp;quot; (i64 %${idTmp}, ${argTmps})`);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="&lt;code&gt;&gt;&lt;/code&gt;,-&lt;code&gt;/&lt;/code&gt;"&gt;&lt;code&gt;&gt;&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Finally, we have a few new operations to add support for. But they'll
be pretty simple using the &lt;code&gt;compileOp&lt;/code&gt; helper function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;if&amp;#39;: this.compileIf.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),
      &amp;#39;*&amp;#39;: this.compileOp(&amp;#39;mul&amp;#39;),
      &amp;#39;/&amp;#39;: this.compileOp(&amp;#39;udiv&amp;#39;),
      &amp;#39;%&amp;#39;: this.compileOp(&amp;#39;urem&amp;#39;),
      &amp;#39;&amp;lt;&amp;#39;: this.compileOp(&amp;#39;icmp slt&amp;#39;),
      &amp;#39;&amp;gt;&amp;#39;: this.compileOp(&amp;#39;icmp sgt&amp;#39;),
      &amp;#39;=&amp;#39;: this.compileOp(&amp;#39;icmp eq&amp;#39;),
      &amp;#39;syscall/sys_write&amp;#39;: this.compileSyscall(SYSCALL_TABLE.sys_write),
    };
  }

  ...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="print"&gt;print&lt;/h3&gt;&lt;p&gt;We're ready to give our print function a shot.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.lisp
(def print-char (c)
     ; First argument is stdout
     ; Second argument is a pointer to a char array (of length one)
     ; Third argument is the length of the char array
     (syscall/sys_write 1 &amp;amp;c 1))

(def print (n)
     (if (&amp;gt; n 9)
         (print (/ n 10)))

     ; 48 is the ASCII code for &amp;#39;0&amp;#39;
     (print-char (+ 48 (% n 10))))

(def main ()
     (print 1234)
     0)
$ node ulisp.js test.lisp
$ ./build/a.out
1234
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks good! In the next post we'll talk about tail call elimination.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;It&amp;#39;s been a slow month for the blog. But new post on compiler basics is up! Printing integers to stdout and making syscalls in LLVM (all without arrays). This was a pre-req for playing with tail-call elimination (post coming soon) &lt;a href="https://t.co/fDtblUZRI8"&gt;https://t.co/fDtblUZRI8&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1142808835700252678?ref_src=twsrc%5Etfw"&gt;June 23, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-llvm-system-calls.html</guid><pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate></item><item><title>Writing an x86 emulator from scratch in JavaScript: 1. a stack and register machine</title><link>http://notes.eatonphil.com/emulator-basics-a-stack-and-register-machine.html</link><description>&lt;p class="note"&gt;
  Better yet, take a look at this post walking through emulating x86 ELF binaries in Go:
  &lt;br /&gt;
  &lt;a href="/emulating-amd64-starting-with-elf.html"&gt;Emulating linux/AMD64 userland: interpreting an ELF binary&lt;/a&gt;
  &lt;br /&gt;
  &lt;br /&gt;
  Next up in emulator basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/emulator-basics-system-calls.html"&gt;2. system calls&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll create a small virtual machine in JavaScript and
use it to run a simple C program compiled with GCC for an x86_64 (or
AMD64) CPU running Linux.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/x86e"&gt;All source code is available on Github.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="virtual-machine-data-storage"&gt;Virtual machine data storage&lt;/h3&gt;&lt;p&gt;Our virtual machine will have two means of storing data: registers and
an integer stack. Each register can store a 64-bit integer. The stack
is an array of 8-bit (or 1 byte) integers.&lt;/p&gt;
&lt;p&gt;We'll make the following registers available for modification and use
by the program(mer):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;RDI, RSI, RSP, RBP, RAX, RBX, RCX, RDX, R8, R9, R10, R11, R12, R13, R14, R15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;RSP&lt;/code&gt; register is used by the virtual machine for
tracking the location of the last entry in the stack. It will be
modified by the virtual machine when it encounters the
&lt;code&gt;POP&lt;/code&gt;, &lt;code&gt;PUSH&lt;/code&gt;, &lt;code&gt;CALL&lt;/code&gt; and
&lt;code&gt;RET&lt;/code&gt; instructions we'll support. We'll get into the
specifics shortly.&lt;/p&gt;
&lt;p&gt;And we'll make the following registers available for use (but not
modification) by the program(mer):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;RIP, CS, DS, FS, SS, ES, GS, CF, ZF, PF, AF, SF, TF, IF, DF, OF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each of these has a special meaning but we'll focus on
&lt;code&gt;RIP&lt;/code&gt;. The &lt;code&gt;RIP&lt;/code&gt; register contains the address
of the instruction currently being interpreted by our virtual
machine. After every instruction the virtual machine will increment
the value in this register -- except for a few special instructions
like &lt;code&gt;CALL&lt;/code&gt; and &lt;code&gt;RET&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="memory-addresses"&gt;Memory addresses&lt;/h4&gt;&lt;p&gt;It will become useful to provide direct access to memory with a special
syntax. We'll focus just on 64-bit addresses that will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  MOV QWORD PTR [RBP - 8], 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This asks for the value &lt;code&gt;12&lt;/code&gt; to be written into the memory
address at &lt;code&gt;RBP - 8&lt;/code&gt; bytes. The &lt;code&gt;QWORD PTR&lt;/code&gt; part
clarifies that we want to write 8 bytes worth of the value. Since
&lt;code&gt;12&lt;/code&gt; is less than 8 bytes, the rest will be filled with
zeros.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  ADD RAX, QWORD PTR [RBP - 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This asks for eight bytes starting from the memory address &lt;code&gt;RBP -
8&lt;/code&gt; to be added to the value in &lt;code&gt;RAX&lt;/code&gt; and stored back
in &lt;code&gt;RAX&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="virtual-machine-instruction-set"&gt;Virtual machine instruction set&lt;/h3&gt;&lt;p&gt;In our virtual machine we'll define support for the following instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MOV $REGISTER, $REGISTER or $MEMORY ADDRESS or $LITERAL NUMBER&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction copies the second value into the first.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD $REGISTER, $REGISTER or $MEMORY ADDRESS&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction adds the second value into the first and stores the result into the first.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUSH $REGISTER&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction will decrement the &lt;code&gt;RSP&lt;/code&gt; register by 8 bytes and store the value at the bottom of the stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POP $REGISTER&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction will increment the &lt;code&gt;RSP&lt;/code&gt; register by 8 bytes, remove the last element in the stack (at the bottom), and store it into the register.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CALL $LABEL&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction will push the value in the &lt;code&gt;RIP&lt;/code&gt; register (plus one) onto the stack and set the &lt;code&gt;RIP&lt;/code&gt; register to the line of code of the label. More on this later.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RET&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;This instruction will remove the value at the bottom of the stack and store it in the &lt;code&gt;RIP&lt;/code&gt; register.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now we have more than enough instructions to write some interesting
programs for the virtual machine.&lt;/p&gt;
&lt;h3 id="virtual-machine-semantics"&gt;Virtual machine semantics&lt;/h3&gt;&lt;p&gt;We'll make one last assumption before explaining further. In our
programs, there must be a &lt;code&gt;main&lt;/code&gt; label which must contain
a &lt;code&gt;RET&lt;/code&gt; instruction. Once we hit the terminal
&lt;code&gt;RET&lt;/code&gt;, we will exit the virtual machine and set the exit
code to the value stored in the &lt;code&gt;RAX&lt;/code&gt; register.&lt;/p&gt;
&lt;p&gt;Let's look at a simple program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;main: ; the required main label
  MOV RAX, 1 ; store 1 in RAX
  MOV RDI, 2 ; store 2 in RDI
  ADD RAX, RDI ; store the result of adding RAX and RDI in RAX
  RET ; give control back to the virtual machine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run this program, first we initialize a stack (we'll give it
1000 elements) and set the &lt;code&gt;RSP&lt;/code&gt; register to 1000 (the top
of the stack). Then we look for the &lt;code&gt;main&lt;/code&gt; label and set
the &lt;code&gt;RIP&lt;/code&gt; register to 1, the line number after the label
appears (0). Then until the &lt;code&gt;RIP&lt;/code&gt; register is 1000 again,
we interpret the instruction at the line number stored in the
&lt;code&gt;RIP&lt;/code&gt; register. Once the &lt;code&gt;RIP&lt;/code&gt; register hits
1000, we exit the program setting &lt;code&gt;RAX&lt;/code&gt; as the exit code.&lt;/p&gt;
&lt;h4 id="one-more-example"&gt;One more example&lt;/h4&gt;&lt;p&gt;Now let's look at one more program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;plus:
  ADD RDI, RSI
  MOV RAX, RDI
  RET

main:
  MOV RDI, 1
  MOV RSI, 2
  CALL plus
  RET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our virtual machine will start at the line after the
&lt;code&gt;main&lt;/code&gt; label. Then it will store &lt;code&gt;1&lt;/code&gt; into
&lt;code&gt;RDI&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; into &lt;code&gt;RSI&lt;/code&gt;. Then it
will jump to the second line in the program to add &lt;code&gt;RDI&lt;/code&gt;
and &lt;code&gt;RSI&lt;/code&gt; and store the result in &lt;code&gt;RDI&lt;/code&gt;. Then it
will copy &lt;code&gt;RDI&lt;/code&gt; into &lt;code&gt;RAX&lt;/code&gt; and return control to
the final line. This last &lt;code&gt;RET&lt;/code&gt; will in turn return control
to the virtual machine. Then the program will exit with exit code
&lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;Now that we've finished up describing our virtual machine language and
semantics, we need to parse the instructions into a format we can
easily interpret.&lt;/p&gt;
&lt;p&gt;To do this we'll iterate over the program skip any lines that start
with a dot. These are virtual machine directives that are important
for us to ignore for now. We'll also remove any characters including
and following a semi-colon or hash-tag, until the end of the
line. These are comments.&lt;/p&gt;
&lt;p&gt;We'll store a dictionary of label names to line numbers (the line
number of the label plus one) and without the colon.&lt;/p&gt;
&lt;p&gt;And we'll store the instructions as an array of objects composed of an
operation and optional operands.&lt;/p&gt;
&lt;h4 id="code"&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class="hljs javascript"&gt;function parse(program) {
  const labels = {};
  const instructions = [];

  const lines = program.split(&amp;#39;\n&amp;#39;);

  for (let i = 0; i &amp;lt; lines.length; i++) {
    let line = lines[i].trim(); // Remove any trailing, leading whitespace
    // TODO: handle each line
  }

  return { labels, instructions };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First let's handle the directives we want to ignore:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  for (let i = 0; i &amp;lt; lines.length; i++) {
    let line = lines[i].trim(); // Remove any trailing, leading whitespace

    if (line.startsWith(&amp;#39;.&amp;#39;)) {
      continue;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then comments:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  for (let i = 0; i &amp;lt; lines.length; i++) {
    let line = lines[i].trim(); // Remove any trailing, leading whitespace

    if (line.startsWith(&amp;#39;.&amp;#39;) || line.startsWith(&amp;#39;;&amp;#39;) || line.startsWith(&amp;#39;#&amp;#39;)) {
      continue;
    }

    if (line.includes(&amp;#39;;&amp;#39;)) {
      line = line.split(&amp;#39;;&amp;#39;)[0];
    }

    if (line.includes(&amp;#39;#&amp;#39;)) {
      line = line.split(&amp;#39;#&amp;#39;)[0];
    }

    if (!line) {
      continue;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then labels:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;  for (let i = 0; i &amp;lt; lines.length; i++) {
    let line = lines[i].trim(); // Remove any trailing, leading whitespace

    if (line.startsWith(&amp;#39;.&amp;#39;) || line.startsWith(&amp;#39;;&amp;#39;) || line.startsWith(&amp;#39;#&amp;#39;)) {
      continue;
    }

    if (line.includes(&amp;#39;;&amp;#39;)) {
      line = line.split(&amp;#39;;&amp;#39;)[0];
    }

    if (line.includes(&amp;#39;#&amp;#39;)) {
      line = line.split(&amp;#39;#&amp;#39;)[0];
    }

    if (!line) {
      continue;
    }

    if (line.includes(&amp;#39;:&amp;#39;)) {
      const label = line.split(&amp;#39;:&amp;#39;)[0];
      labels[label] = instructions.length;
      continue;
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally instruction parsing plus the rest:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function parse(program) {
  const labels = {};
  const instructions = [];

  const lines = program.split(&amp;#39;\n&amp;#39;);

  for (let i = 0; i &amp;lt; lines.length; i++) {
    let line = lines[i].trim(); // Remove any trailing, leading whitespace

    if (line.startsWith(&amp;#39;.&amp;#39;) || line.startsWith(&amp;#39;;&amp;#39;)) {
      continue;
    }

    if (line.includes(&amp;#39;;&amp;#39;)) {
      line = line.split(&amp;#39;;&amp;#39;)[0];
    }

    if (line.includes(&amp;#39;:&amp;#39;)) {
      const label = line.split(&amp;#39;:&amp;#39;)[0];
      labels[label] = instructions.length;
      continue;
    }

    const operation = line.split(/\s/)[0].toLowerCase();
    const operands = line.substring(operation.length).split(&amp;#39;,&amp;#39;).map(t =&amp;gt; t.trim());
    instructions.push({
      operation,
      operands,
    });
  }

  return { labels, instructions };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hurray! A brittle parser.&lt;/p&gt;
&lt;h3 id="interpreting"&gt;Interpreting&lt;/h3&gt;&lt;p&gt;We've already described the semantics a few times. So let's get
started with the foundation and initialization.&lt;/p&gt;
&lt;p&gt;We'll use
&lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt"&gt;BigInt&lt;/a&gt;s
because JavaScript integers are 53-bits wide. This isn't incredibly
important in our basic programs but it will quickly became painful
without.&lt;/p&gt;
&lt;p&gt;And we'll make process memory available as an array of 8-bit integers.
In order to make this easy to use, we'll also provide helper function
for writing to and reading from memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const fs = require(&amp;#39;fs&amp;#39;);

const REGISTERS = [
  &amp;#39;RDI&amp;#39;, &amp;#39;RSI&amp;#39;, &amp;#39;RSP&amp;#39;, &amp;#39;RBP&amp;#39;, &amp;#39;RAX&amp;#39;, &amp;#39;RBX&amp;#39;, &amp;#39;RCX&amp;#39;, &amp;#39;RDX&amp;#39;, &amp;#39;RIP&amp;#39;, &amp;#39;R8&amp;#39;,
  &amp;#39;R9&amp;#39;, &amp;#39;R10&amp;#39;, &amp;#39;R11&amp;#39;, &amp;#39;R12&amp;#39;, &amp;#39;R13&amp;#39;, &amp;#39;R14&amp;#39;, &amp;#39;R15&amp;#39;, &amp;#39;CS&amp;#39;, &amp;#39;DS&amp;#39;, &amp;#39;FS&amp;#39;,
  &amp;#39;SS&amp;#39;, &amp;#39;ES&amp;#39;, &amp;#39;GS&amp;#39;, &amp;#39;CF&amp;#39;, &amp;#39;ZF&amp;#39;, &amp;#39;PF&amp;#39;, &amp;#39;AF&amp;#39;, &amp;#39;SF&amp;#39;, &amp;#39;TF&amp;#39;, &amp;#39;IF&amp;#39;, &amp;#39;DF&amp;#39;, &amp;#39;OF&amp;#39;,
];

function writeMemoryBytes(process, address, value, size) {
  for (let i = 0n; i &amp;lt; size; i++) {
    value &amp;gt;&amp;gt;= i * 8n;
    process.memory[address + i] = value &amp;amp; 0xFFn;
  }
}

function readMemoryBytes(process, address, size) {
  let value = 0n;
  for (let i = 0n; i &amp;lt; size; i++) {
    value |= (process.memory[address + i] || 0n) &amp;lt;&amp;lt; (i * 8n);
  }
  return value;
}

function interpret(process) {
  // TODO: interpret
}

function main(file) {
  const memory = new Array(10000);
  const code = fs.readFileSync(file).toString();
  const { instructions, labels } = parse(code);

  const registers = REGISTERS.reduce((rs, r) =&amp;gt; ({ ...rs, [r]: 0n }), {});
  registers.RIP = BigInt(labels.main === undefined ? labels._main : labels.main);
  registers.RSP = BigInt(memory.length - 8);

  const process = {
    registers,
    memory,
    instructions,
    labels,
  };

  writeMemoryBytes(process, registers.RSP, registers.RSP, 8);

  interpret(process);
  return Number(registers.RAX);
}

process.exit(main(process.argv[2]));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We'll accept &lt;code&gt;_main&lt;/code&gt; as an entry point as well as
&lt;code&gt;main&lt;/code&gt; to support our macOS users. If you know why our
macOS users use &lt;code&gt;_main&lt;/code&gt; I'd love to know.&lt;/p&gt;
&lt;p&gt;To interpret, we grab the instruction pointed to in &lt;code&gt;RIP&lt;/code&gt;
and switch on the operation.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function interpret(process) {
  do {
    const instruction = process.instructions[process.registers.RIP];
    switch (instruction.operation.toLowerCase()) {
      case &amp;#39;mov&amp;#39;:
        break;
      case &amp;#39;add&amp;#39;:
        break;
      case &amp;#39;call&amp;#39;:
        break;
      case &amp;#39;ret&amp;#39;:
        break;
      case &amp;#39;push&amp;#39;:
        break;
      case &amp;#39;pop&amp;#39;:
        break;
    }
  } while (process.registers.RIP != BigInt(readMemoryBytes(process, memory.length - 8, 8)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-mov"&gt;Interpreting MOV&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  MOV RAX, 1
  MOV RAX, RDI
  MOV QWORD PTR [RBP - 8], 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction will store a value into a register or address and
increment &lt;code&gt;RIP&lt;/code&gt;. If the left-hand side is a memory address
we will write to memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;mov&amp;#39;: {
        const lhs = interpretValue(process, instruction.operands[0], { lhs: true });
        const rhs = interpretValue(process, instruction.operands[1]);
        if (REGISTERS.includes(lhs)) {
          process.registers[lhs] = rhs;
        } else {
          writeMemoryBytes(process, lhs.address, rhs, lhs.size);
        }
        process.registers.RIP++;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're delegating to a helper function to handle registers vs. memory
addresses vs. literals appropriately. Without memory addresses it's a
simple function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function interpretValue(process, value, { lhs } = { lhs: false }) {
  if (REGISTERS.includes(value)) {
    if (lhs) {
      return value;
    } else {
      return process.registers[value];
    }
  }

  return BigInt.asIntN(64, value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to do some hacking to support memory addresses:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function interpretValue(process, value, { lhs } = { lhs: false }) {
  if (REGISTERS.includes(value)) {
    if (lhs) {
      return value;
    } else {
      return process.registers[value];
    }
  }

  if (value.startsWith(&amp;#39;QWORD PTR [&amp;#39;)) {
    const offsetString = value.substring(&amp;#39;QWORD PTR [&amp;#39;.length, value.length - 1).trim();
    if (offsetString.includes(&amp;#39;-&amp;#39;)) {
      const [l, r] = offsetString.split(&amp;#39;-&amp;#39;).map(l =&amp;gt; interpretValue(process, l.trim()));
      const address = l - r;
      const bytes = 8; // qword is 8 bytes
      if (lhs) {
        return { address, size: bytes };
      } else {
        return readMemoryBytes(process, address, bytes);
      }
    }

    throw new Error(&amp;#39;Unsupported offset calculation: &amp;#39; + value);
  }

  return BigInt.asIntN(64, value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-add"&gt;Interpreting ADD&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  ADD RAX, RDI
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction will combine both registers and store the result in
the first, then increment the &lt;code&gt;RIP&lt;/code&gt; register.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;add&amp;#39;: {
        const lhs = interpretValue(process, instruction.operands[0], { lhs: true });
        const rhs = interpretValue(process, instruction.operands[1]);
        process.registers[lhs] += rhs;
        process.registers.RIP++;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-call"&gt;Interpreting CALL&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  CALL plus
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction store &lt;code&gt;RIP&lt;/code&gt; (plus one, to continue after
the call instruction) on the stack and sets &lt;code&gt;RIP&lt;/code&gt; to the
location specified by the label.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;call&amp;#39;: {
        process.registers.RSP -= 8n;
        writeMemoryBytes(process, process.registers.RSP, process.registers.RIP + 1n, 8);
        const label = instruction.operands[0];
        process.registers.RIP = process.labels[label];
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-ret"&gt;Interpreting RET&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  RET
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction removes the last element from the stack and stores it
in the &lt;code&gt;RIP&lt;/code&gt; register.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;ret&amp;#39;: {
        const value = readMemoryBytes(process, process.registers.RSP, 8);
        process.registers.RSP += 8n;
        process.registers.RIP = value;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-push"&gt;Interpreting PUSH&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  PUSH RAX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction stores the value in the register on the stack and
increments &lt;code&gt;RIP&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;push&amp;#39;: {
        const value = interpretValue(process, instruction.operands[0]);
        process.registers.RSP -= 8n;
        writeMemoryBytes(process, process.registers.RSP, value, 8);
        process.registers.RIP++;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="interpreting-pop"&gt;Interpreting POP&lt;/h4&gt;&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;  POP RAX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This instruction removes the last element from the stack and stores it
into the register specified. Then it increments &lt;code&gt;RIP&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;      case &amp;#39;pop&amp;#39;: {
        const lhs = interpretValue(process, instruction.operands[0], { lhs: true });
        const value = readMemoryBytes(process, process.registers.RSP, 8);
        process.registers.RSP += 8n;
        process.registers[lhs] = value;
        process.registers.RIP++;
        break;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="all-together"&gt;All together&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test1.asm
main: ; the required main label
  MOV RAX, 1 ; store 1 in RAX
  MOV RDI, 2 ; store 2 in RDI
  ADD RAX, RDI ; store the result of adding RAX and RDI in RAX
  RET ; give control back to the virtual machine
$ node emulator.js test1.asm
$ echo $?
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, let's see what we can do with a simple C program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat plus.c
long main() {
  long a = 5;
  long b = 6;
  return a + b;
}
$ gcc -S -masm=intel -o plus.s plus.c
$ node emulator.js plus.s
$ echo $?
11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we've got the start of a working x86_64/AMD64 emulator.&lt;/p&gt;
&lt;h3 id="next-steps"&gt;Next steps&lt;/h3&gt;&lt;p&gt;We aren't setting flags appropriately to support conditionals, so
that's low-hanging fruit. Additionally, syscalls open up a new world
(that we'll end up needing since exit codes are limited to 8-bits of
information). Additionally, our parsing is brittle. Dealing with ELF
files may be a better direction to go and also enables more. We'll
explore these aspects and others in follow-up posts.&lt;/p&gt;
&lt;h3 id="human-interest"&gt;Human interest&lt;/h3&gt;&lt;p&gt;I originally intended to build a GameBoy emulator because the hardware
is simple and uniform. But I found it easiest to start hacking
together an AMD64 emulator because AMD64 is well-documented and gcc is
easy enough to use. I'm still interested though unless/until I figure
out how to emulate a graphics card for AMD64.&lt;/p&gt;
&lt;p&gt;It's tricky! But not that tricky. I built a &lt;a href="https://github.com/eatonphil/x86e"&gt;graphical
debugger&lt;/a&gt; around this emulator to
help out with the logic and off-by-one errors. But ultimately it's
been surprising to me how easy it is to get started -- especially when
I'm not concerned about absolute correctness (yet).&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Here&amp;#39;s my first post on a series on emulator basics. It&amp;#39;s baby&amp;#39;s first stack and register virtual machine and it turns out it runs x86 code. &lt;a href="https://t.co/WiWmGedawt"&gt;https://t.co/WiWmGedawt&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/linux?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#linux&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/assembly?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#assembly&lt;/a&gt; &lt;a href="https://t.co/xjiMkhgpdN"&gt;https://t.co/xjiMkhgpdN&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1132036835964870657?ref_src=twsrc%5Etfw"&gt;May 24, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/emulator-basics-a-stack-and-register-machine.html</guid><pubDate>Tue, 21 May 2019 00:00:00 +0000</pubDate></item><item><title>Tail call elimination</title><link>http://notes.eatonphil.com/tail-call-elimination.html</link><description>&lt;p&gt;In this post we'll explore what tail calls are, why they are useful,
and how they can be eliminated in an interpreter, a compiler targeting
C++, and a compiler targeting LLVM IR.&lt;/p&gt;
&lt;h3 id="tail-calls"&gt;Tail calls&lt;/h3&gt;&lt;p&gt;A tail call is a function call made at the end of a block that
returns the value of the call (some languages do not force this
&lt;code&gt;return&lt;/code&gt; requirement). Here are a few examples.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function tailCallEx1() {
  // Loops forever but is a tail call.
  return tailCallEx1();
}

function tailCallEx2(x) {
  if (x) {
    return tailCallEx2(x - 1);
  }

  return 1;
}

function tailCallEx3(x) {
  return x &amp;amp;&amp;amp; tailCallEx(x - 1) || 1;
}

function tailCallEx4(x) {
  switch (x) {
    case 0:
      return 1;
    default:
      return tailCallEx4(x - 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here are some examples of non-tail calls.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function nonTailCallEx1(x) {
  if (x) {
    // Not a tail call because the call is not the value returned.
    return 1 + nonTailCallEx1(x - 1);
  }

  return 0;
}

function nonTailCallEx2(x) {
  if (x) {
    const r = nonTailCallEx2(x - 1);
    // Not a tail call because the value is not *immediately* returned.
    console.log(r);
    return r;
  }

  return 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="why-is-this-important?"&gt;Why is this important?&lt;/h3&gt;&lt;p&gt;Some languages can rewrite a recursive tail call as a jump/branch/goto instead
of a function call. This allows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Potential performance gain if function calls have large overhead&lt;/li&gt;
&lt;li&gt;No stack overflows due to no nested function call stacks&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="implementation-1:-interpreter"&gt;Implementation 1: Interpreter&lt;/h3&gt;&lt;p&gt;Given a tail call recursive fibonacci:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function fibonacci(a, b, n) {
  if (n === 0) {
    return a;
  }

  if (n === 1) {
    return b;
  }

  return fibonacci(b, a + b, n - 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is how we could transform (by hand) this without a tail call.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function fibonacci(a, b, n) {
  while (true) {
    if (n === 0) {
      return a;
    }

    if (n === 1) {
      return b;
    }

    const a1 = b;
    const b1 = a + b;
    const n1 = n - 1;
    a = a1;
    b = b1;
    n = n1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this was written in a language with labels and goto we could
simplify the code slightly by doing that. But it is the same effect as
a loop.&lt;/p&gt;
&lt;p&gt;Since we're in an interpreter (that isn't JIT compiling), we cannot
pick between these two and must merge them. So we put all function
bodies in a loop and break if it isn't a tail call. Otherwise we line
up the paremeters and let the loop take us back.&lt;/p&gt;
&lt;p&gt;Here is an example of this strategy used in a &lt;a href="https://github.com/eatonphil/bsdscheme"&gt;Scheme
interpreter&lt;/a&gt; written in D.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs d"&gt;// Define a new function with name `name` and add it to the context.
Value namedLambda(Value arguments, Context ctx, string name) {
  auto funArguments = car(arguments);
  auto funBody = cdr(arguments);

  Value defined(Value parameters, void** rest) {
    Context newCtx = ctx.dup;

    // Copy the runtime calling context to the new context.
    Context runtimeCtx = cast(Context)(*rest);
    auto runtimeCallingContext = runtimeCtx.callingContext;
    newCtx.callingContext = runtimeCallingContext.dup;

    Value result;
    // Loop forever, will break immediately if not a tail call
    bool tailCalling = false;
    while (true) {
      if (valueIsList(funArguments)) {
        auto keyTmp = valueToList(funArguments);
        auto valueTmp = valueToList(parameters);
        while (true) {
          auto key = valueToSymbol(keyTmp[0]);
          auto value = valueTmp[0];

          newCtx.set(key, value);

          // TODO: handle arg count mismatch
          if (valueIsList(keyTmp[1])) {
            keyTmp = valueToList(keyTmp[1]);
            valueTmp = valueToList(valueTmp[1]);
          } else {
            break;
          }
        }
      } else if (valueIsSymbol(funArguments)) {
        auto key = valueToSymbol(funArguments);
        newCtx.set(key, car(parameters));
      } else if (!valueIsNil(funArguments)) {
        error(&amp;quot;Expected symbol or list in lambda formals&amp;quot;, funArguments);
      }

      if (!tailCalling) {
        newCtx.callingContext.push(Tuple!(string, Delegate)(name, &amp;amp;defined));
      }

      result = eval(withBegin(funBody), cast(void**)[newCtx]);

      // In a tail call, let the loop carry us back.
      if (newCtx.doTailCall == &amp;amp;defined) {
        tailCalling = true;
        parameters = result;
        newCtx.doTailCall = null;
      } else {
        break; // Not in a tail call, we&amp;#39;re done a regular function call.
      }
    }

    return result;
  }

  return makeFunctionValue(name, &amp;amp;defined, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  We can not eliminate mutually recursive tail calls with this
  method. We could use continuation-passing style but that would not
  have addressed the concern: not making a function call.
&lt;/p&gt;&lt;h3 id="implementation-2:-compiling-to-c++"&gt;Implementation 2: Compiling to C++&lt;/h3&gt;&lt;p&gt;The strategy here is the same as in the interpreter except for that
since tail call recursive functions are known at compile time, we can
generate non-generalized code in function bodies.&lt;/p&gt;
&lt;p&gt;Here is how a &lt;a href="https://github.com/eatonphil/jsc"&gt;JavaScript compiler&lt;/a&gt;
transforms the above fibonacci implementation into C++:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void tco_fib(const FunctionCallbackInfo&amp;lt;Value&amp;gt; &amp;amp;args) {
  Isolate *isolate = args.GetIsolate();
  double tco_n = toNumber(args[0]);
  double tco_a = toNumber(args[1]);
  double tco_b = toNumber(args[2]);

tail_recurse_1:

    ;

  bool sym_if_test_58 = (tco_n == 0);
  if (sym_if_test_58) {
    args.GetReturnValue().Set(Number::New(isolate, tco_a));
    return;
  }

  bool sym_if_test_70 = (tco_n == 1);
  if (sym_if_test_70) {
    args.GetReturnValue().Set(Number::New(isolate, tco_b));
    return;
  }

  Local&amp;lt;Value&amp;gt; sym_arg_83 = Number::New(isolate, (tco_n - 1));
  Local&amp;lt;Value&amp;gt; sym_arg_92 = Number::New(isolate, (tco_a + tco_b));
  tco_n = toNumber(sym_arg_83);
  tco_a = tco_b;
  tco_b = toNumber(sym_arg_92);
  goto tail_recurse_1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is implemented by checking every function call. If the function
call is in tail call position, we generate code for jumping to the
beginning of the function.  Otherwise, we generate a call as usual.&lt;/p&gt;
&lt;p&gt;Here is how the tail call check and code-generation is done in the 
&lt;a href="https://github.com/eatonphil/jsc/blob/master/src/compile/compile.ts#L186"&gt;compiler&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs ts"&gt;function compileCall(
  context: Context,
  destination: Local,
  ce: ts.CallExpression,
) {
  let tcoLabel;
  let tcoParameters;
  if (ce.expression.kind === ts.SyntaxKind.Identifier) {
    const id = identifier(ce.expression as ts.Identifier);
    const safe = context.locals.get(mangle(context.moduleName, id));

    if (safe &amp;amp;&amp;amp; context.tco[safe.getCode()]) {
      const safeName = safe.getCode();
      tcoLabel = context.tco[safeName].label;
      tcoParameters = context.tco[safeName].parameters;
    }
  }

  ...

  if (ce.expression.kind === ts.SyntaxKind.Identifier) {
    const id = identifier(ce.expression as ts.Identifier);
    const mangled = mangle(context.moduleName, id);
    const safe = context.locals.get(mangled);

    if (safe) {
      if (tcoLabel) {
        args.forEach((arg, i) =&amp;gt; {
          compileParameter(
            context,
            tcoParameters[i],
            i,
            i === args.length - 1,
            arg,
          );
        });

        context.emitStatement(`goto ${tcoLabel}`);
        context.emit(&amp;#39;&amp;#39;, 0);
        destination.tce = true;
        return;
      }
    }
  }

  ...

  // Otherwise generate regular function call
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This requires you to have been building up the state throughout the
AST to know whether or not any particular call is in tail position.&lt;/p&gt;
&lt;h3 id="implementation-3:-compiling-to-llvm-ir"&gt;Implementation 3: Compiling to LLVM IR&lt;/h3&gt;&lt;p&gt;LLVM IR is the most boring because all you do is mark any tail call as
being a tail call. Then so long as the call meets some
&lt;a href="https://llvm.org/docs/LangRef.html#id320"&gt;requirements&lt;/a&gt;, the key one
being that the result of the call must be returned immediately, LLVM
will generate a jump instead of a call for you.&lt;/p&gt;
&lt;p&gt;Given the following lisp-y implementation of the same tail call recursive
fibonacci function (compiler &lt;a href="https://github.com/eatonphil/ulisp"&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def fib (a b n)
     (if (= n 0)
         a
       (fib b (+ a b) (- n 1))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We generate the following LLVM IR:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;define i64 @fib(i64 %a, i64 %b, i64 %n) {
  %ifresult13 = alloca i64, align 4
  %sym14 = add i64 %n, 0
  %sym15 = add i64 0, 0
  %sym12 = icmp eq i64 %sym14, %sym15
  br i1 %sym12, label %iftrue16, label %iffalse17
iftrue16:
  %sym18 = add i64 %a, 0
  store i64 %sym18, i64* %ifresult13, align 4
  br label %ifend19
iffalse17:
  %sym21 = add i64 %b, 0
  %sym23 = add i64 %a, 0
  %sym24 = add i64 %b, 0
  %sym22 = add i64 %sym23, %sym24
  %sym26 = add i64 %n, 0
  %sym27 = add i64 1, 0
  %sym25 = sub i64 %sym26, %sym27
  ; NOTE the `tail` before `call` here
  %sym20 = tail call i64 @fib(i64 %sym21, i64 %sym22, i64 %sym25)
  ret i64 %sym20
  store i64 %sym20, i64* %ifresult13, align 4
  br label %ifend19
ifend19:
  %sym11 = load i64, i64* %ifresult13, align 4
  ret i64 %sym11
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only difference between supporting tail call elimination in is
whether the &lt;code&gt;call&lt;/code&gt; instruction is preceeded by a
&lt;code&gt;tail&lt;/code&gt; directive. That makes the
&lt;a href="https://github.com/eatonphil/ulisp/blob/master/src/backend/llvm.js#L198"&gt;implementation&lt;/a&gt;
very simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const isTailCall = module.exports.TAIL_CALL_ENABLED &amp;amp;&amp;amp;
                   context.tailCallTree.includes(validFunction.value);
const maybeTail = isTailCall ? &amp;#39;tail &amp;#39; : &amp;#39;&amp;#39;;
this.emit(1, `%${destination.value} = ${maybeTail}call ${validFunction.type} @${validFunction.value}(${safeArgs})`);
if (isTailCall) {
  this.emit(1, `ret ${destination.type} %${destination.value}`);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="generated-assembly"&gt;Generated assembly&lt;/h4&gt;&lt;p&gt;The resulting generated code (run through
&lt;a href="https://llvm.org/docs/CommandGuide/llc.html"&gt;llc&lt;/a&gt;) for that call will
be:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs asm"&gt;...
    add rax, rsi
    dec rdx
    mov rdi, rsi
    mov rsi, rax
    jmp _fib               ## TAILCALL
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And if tail call elimination is disabled:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs asm"&gt;...
    add rax, rsi
    dec rdx
    mov rdi, rsi
    mov rsi, rax
    call    _fib
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="summary"&gt;Summary&lt;/h3&gt;&lt;p&gt;The last bit I haven't covered is how you track whether or not a call
is in tail position. That is difficult to cover in a blog post because
it's a matter of you propagating/not propagating at each syntax node
type. But generally speaking, if the syntax node is not in tail
position (e.g. not the last expression in a block), you drop the tail
state you've built up. When you make a function call, you add the
function name to the tail state.&lt;/p&gt;
&lt;p&gt;But I will be covering this in detail in the LLVM case in the next
post in my &lt;a href="http://notes.eatonphil.com/compiler-basics-llvm-conditionals.html"&gt;compiler
basics&lt;/a&gt;
series.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Put together a survey and summary of tail call elimination, the effect and implementation, in an interpreter, a compiler targeting C++, and a compiler targeting LLVM IR. &lt;a href="https://t.co/pXiLoXjw2u"&gt;https://t.co/pXiLoXjw2u&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1128640717679734784?ref_src=twsrc%5Etfw"&gt;May 15, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/tail-call-elimination.html</guid><pubDate>Tue, 14 May 2019 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 4. LLVM conditionals and compiling fibonacci</title><link>http://notes.eatonphil.com/compiler-basics-llvm-conditionals.html</link><description>&lt;p class="note"&gt;
  Previously in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-lisp-to-assembly.html"&gt;1. lisp to assembly&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-functions.html"&gt;2. user-defined functions and variables&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm.html"&gt;3. LLVM&lt;/a&gt;
  &lt;br /&gt;
  Next in compiler basics:
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-system-calls.html"&gt;5. LLVM system calls&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-an-x86-upgrade.html"&gt;6. an x86 upgrade&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll extend the
&lt;a href="https://github.com/eatonphil/ulisp"&gt;compiler&lt;/a&gt;'s LLVM backend to
support compiling conditionals such that we can support an
implementation of the fibonacci algorithm.&lt;/p&gt;
&lt;p&gt;Specifically we're aiming for the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat tests/fib.lisp
(def fib (n)
     (if (&amp;lt; n 2)
         n
       (+ (fib (- n 1)) (fib (- n 2)))))

(def main ()
     (fib 8))
$ node src/ulisp.js tests/fib.lisp
$ ./build/prog
$ echo $?
21
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do this we'll have to add the &lt;code&gt;&lt;&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and
&lt;code&gt;if&lt;/code&gt; built-ins.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/ulisp"&gt;All source code is available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="subtraction"&gt;Subtraction&lt;/h3&gt;&lt;p&gt;This is the easiest to add since we already support addition. They are
both arithmetic operations that produce an integer. We simply add a
mapping of &lt;code&gt;-&lt;/code&gt; to the LLVM instruction &lt;code&gt;sub&lt;/code&gt; so
our LLVM backend constructor (&lt;code&gt;src/backends/llvm.js&lt;/code&gt;) looks
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;...

class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;if&amp;#39;: this.compileIf.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="less-than"&gt;Less than&lt;/h3&gt;&lt;p&gt;The &lt;code&gt;&lt;&lt;/code&gt; builtin is a logical operation. These are handled
differently from arithmetic operations in LLVM IR. A logical operation
looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;%3 = icmp slt i32 %1, %2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This says that we're doing an integer comparison, &lt;code&gt;icmp&lt;/code&gt;,
(with signed less than, &lt;code&gt;slt&lt;/code&gt;) on the &lt;code&gt;i32&lt;/code&gt;
integers in variables &lt;code&gt;%1&lt;/code&gt; and &lt;code&gt;%2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can shim this into our existing &lt;code&gt;compileOp&lt;/code&gt; helper like
so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;...

class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;if&amp;#39;: this.compileIf.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),
      &amp;#39;&amp;lt;&amp;#39;: this.compileOp(&amp;#39;icmp slt&amp;#39;),

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="conditionals"&gt;Conditionals&lt;/h3&gt;&lt;p&gt;The last part we need to add is support for conditional execution of
code at runtime. Assembly-like languages handle this with "jumps" and
"labels". Jumping causes execution to continue at the address being
jumped to (instead of just the line following the jump
instruction). Labels give you a way of naming an address instead of
having to calculate it yourself. Our code will look vaguely like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;  %test = icmp slt i32 %n, %1
  br i1 %test, label %iftrue, label %iffalse
iftrue:
  ; do true stuff
iffalse:
  ; do false stuff

  ; do next stuff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;br&lt;/code&gt; instruction can jump (or branch) conditionally or
unconditionally. This snippet demonstrates a conditional jump.&lt;/p&gt;
&lt;p&gt;But there are a few things wrong with this pseudo-code. First off if
the condition is true, execution will just continue on into the false
section once finished. Second, LLVM IR actually requires all labels to
end with a branch instruction. So we'll add a new label after the true
and false section called &lt;code&gt;ifresult&lt;/code&gt; and jump to it
unconditionally after both.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;  %test = icmp slt i32 %n, %1
  br i1 %test, label %iftrue, label %iffalse
iftrue:
  ; do true stuff
  br label %ifresult
iffalse:
  ; do false stuff
  br label %ifresult
ifresult:
  ; do next stuff
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="scope"&gt;Scope&lt;/h3&gt;&lt;p&gt;One last thing we'll need to do before implementing the code
generation for this is to update our &lt;code&gt;Scope&lt;/code&gt; class to
accept symbol prefixes so we can pass our labels through Scope to make
sure they are unique but still have useful names.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;...

class Scope {

  ...

  symbol(prefix = &amp;#39;sym&amp;#39;) {
    const nth = Object.keys(this.locals).length + 1;
    return this.register(prefix + nth);
  }

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="compileif"&gt;compileIf&lt;/h3&gt;&lt;p&gt;Now we can add a primitive function mapping &lt;code&gt;if&lt;/code&gt; to a new
&lt;code&gt;compileIf&lt;/code&gt; helper and implement the helper.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;...

class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),
      &amp;#39;&amp;lt;&amp;#39;: this.compileOp(&amp;#39;icmp slt&amp;#39;),
      &amp;#39;if&amp;#39;: this.compileIf.bind(this),

...

  compileIf([test, thenBlock, elseBlock], destination, scope) {
    const testVariable = scope.symbol();

    // Compile expression and branch
    this.compileExpression(test, testVariable, scope);
    const trueLabel = scope.symbol(&amp;#39;iftrue&amp;#39;);
    const falseLabel = scope.symbol(&amp;#39;iffalse&amp;#39;);
    this.emit(1, `br i1 %${testVariable}, label %${trueLabel}, label %${falseLabel}`);

    // Compile true section
    this.emit(0, trueLabel + &amp;#39;:&amp;#39;);
    this.compileExpression(thenBlock, destination, scope);
    const endLabel = scope.symbol(&amp;#39;ifend&amp;#39;);
    this.emit(1, &amp;#39;br label %&amp;#39; + endLabel);
    this.emit(0, falseLabel + &amp;#39;:&amp;#39;);

    // Compile false section
    this.compileExpression(elseBlock, destination, scope);
    this.emit(1, &amp;#39;br label %&amp;#39; + endLabel);

    // Compile cleanup
    this.emit(0, endLabel + &amp;#39;:&amp;#39;);
  }
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this code generation sends the &lt;code&gt;destination&lt;code&gt;
variable into both the true and false sections. Let's try it out.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node src/ulisp.js tests/fib.lisp
llc: error: llc: build/prog.ll:19:3: error: multiple definition of local value named &amp;#39;sym5&amp;#39;
  %sym5 = add i32 %sym15, %sym16
  ^
child_process.js:665
    throw err;
    ^

Error: Command failed: llc -o build/prog.s build/prog.ll
llc: error: llc: build/prog.ll:19:3: error: multiple definition of local value named &amp;#39;sym5&amp;#39;
  %sym5 = add i32 %sym15, %sym16
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's annoying. An unfortunate aspect of LLVM's required
single-static assignment form is that you cannot reuse variable names
within a function even if it is not possible for the variable to be
actually reused.&lt;/p&gt;
&lt;p&gt;To work around this we need to allocate memory on the stack, store the
result in each true/false section in this location, and read from this
location afterward to store it in the destination variable.&lt;/p&gt;
&lt;h3 id="stack-memory-instructions"&gt;Stack memory instructions&lt;/h3&gt;&lt;p&gt;LLVM IR gives us &lt;code&gt;alloca&lt;/code&gt; to allocate memory on the stack,
&lt;code&gt;store&lt;/code&gt; to store memory at a stack address, and
&lt;code&gt;load&lt;/code&gt; to read the value at a stack address into a
variable. Here's a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;%myvar = add i32 42, 0
%stackaddress = alloca i32, align 4
store i32 %myvar, i32* %stackaddress, align 4
%newvar = load i32, i32* %stackaddress, align 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Such that &lt;code&gt;newvar&lt;/code&gt; is now 42.&lt;/p&gt;
&lt;h3 id="compileif-again"&gt;compileIf again&lt;/h3&gt;&lt;p&gt;Applying this back to our &lt;code&gt;compileIf&lt;/code&gt; helper gives us:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;...

  compileIf([test, thenBlock, elseBlock], destination, scope) {
    const testVariable = scope.symbol();
    const result = scope.symbol(&amp;#39;ifresult&amp;#39;);
    // Space for result
    this.emit(1, `%${result} = alloca i32, align 4`);

    // Compile expression and branch
    this.compileExpression(test, testVariable, scope);
    const trueLabel = scope.symbol(&amp;#39;iftrue&amp;#39;);
    const falseLabel = scope.symbol(&amp;#39;iffalse&amp;#39;);
    this.emit(1, `br i1 %${testVariable}, label %${trueLabel}, label %${falseLabel}`);

    // Compile true section
    this.emit(0, trueLabel + &amp;#39;:&amp;#39;);
    const tmp1 = scope.symbol();
    this.compileExpression(thenBlock, tmp1, scope);
    this.emit(1, `store i32 %${tmp1}, i32* %${result}, align 4`);
    const endLabel = scope.symbol(&amp;#39;ifend&amp;#39;);
    this.emit(1, &amp;#39;br label %&amp;#39; + endLabel);
    this.emit(0, falseLabel + &amp;#39;:&amp;#39;);

    // Compile false section
    const tmp2 = scope.symbol();
    this.compileExpression(elseBlock, tmp2, scope);
    this.emit(1, `store i32 %${tmp2}, i32* %${result}, align 4`);
    this.emit(1, &amp;#39;br label %&amp;#39; + endLabel);

    // Compile cleanup
    this.emit(0, endLabel + &amp;#39;:&amp;#39;);
    this.emit(1, `%${destination} = load i32, i32* %${result}, align 4`);
  }

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="trying-it-out"&gt;Trying it out&lt;/h3&gt;&lt;p&gt;We run our compiler one more time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node src/ulisp.js tests/fib.lisp
$ ./build/prog
$ echo $?
21
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And get what we expect!&lt;/p&gt;
&lt;h3 id="next-up"&gt;Next up&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Tail call optimization&lt;/li&gt;
&lt;li&gt;Lists and dynamic memory&lt;/li&gt;
&lt;li&gt;Strings?&lt;/li&gt;
&lt;li&gt;Foreign function calls?&lt;/li&gt;
&lt;li&gt;Self-hosting?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Latest post in the compiler basics series: using LLVM conditionals in compiling a fibonacci program &lt;a href="https://t.co/A72yEDQ8sd"&gt;https://t.co/A72yEDQ8sd&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1125072731408666624?ref_src=twsrc%5Etfw"&gt;May 5, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-llvm-conditionals.html</guid><pubDate>Sat, 04 May 2019 00:00:00 +0000</pubDate></item><item><title>Responsibility and ownership</title><link>http://notes.eatonphil.com/responsibility-and-ownership.html</link><description>&lt;p&gt;Responsibility is only possible by granting ownership and setting
expectations. If you don't turn over ownership, don't expect folks to
take responsibility. When you grant ownership and set expectations,
you'll be astounded what folks will accomplish without you.&lt;/p&gt;
&lt;p&gt;I am astounded.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/responsibility-and-ownership.html</guid><pubDate>Tue, 30 Apr 2019 00:00:00 +0000</pubDate></item><item><title>Interpreting TypeScript</title><link>http://notes.eatonphil.com/interpreting-typescript.html</link><description>&lt;p&gt;In addition to providing a static type system and compiler for a
superset of JavaScript, TypeScript makes much of its functionality
available programmatically. In this post we'll use the TypeScript
compiler API to build an interpreter. We'll build off of a &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API"&gt;TypeScript
wiki
article&lt;/a&gt;
and cover a few areas that were confusing to me as I built out
&lt;a href="https://github.com/eatonphil/jsc"&gt;a separate project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The end result we're building will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.ts # A program we can interpret
print(1 + 5);
$ tsc interpreter.ts # Build the source code for the interpreter
$ node interpreter.js test.ts # Run the interpreter against test program
6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/jsi"&gt;All code is available on Github.&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="setup"&gt;Setup&lt;/h3&gt;&lt;p&gt;To begin with, we need Node.js and some dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ yarn add typescript @types/node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can begin the first stage of an interpreter: parsing the code.&lt;/p&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;Parsing a fixed set of files is simple enough. We pass a list of files
to &lt;code&gt;createProgram&lt;/code&gt; along with compiler options. But, as a user, we
don't want to keep track of all files used by a program
(i.e. everything we import). The most ideal situation is to pass a
single-file entrypoint (something like a main.js) and have our
interpreter figure out all the imports and handle them
recursively. More on this later, for now we'll just parse the
single-file entrypoint.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;import * as ts from &amp;#39;typescript&amp;#39;;

const TS_COMPILER_OPTIONS = {
  allowNonTsExtensions: true,
};

function parse(fileName: string): ts.Program {
  return ts.createProgram([fileName], TS_COMPILER_OPTIONS);
}

function interpret(program: ts.Program) { // TODO }

function main(entrypoint: string) {
  const program = parse(entrypoint);
  interpret(program);
}

main(process.argv[2]);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interpret-and-ts.program"&gt;interpret and ts.Program&lt;/h3&gt;&lt;p&gt;A program contains all source files as well as any implicitly needed
TypeScript definition files (for us it will just be the TypeScript
definitions for the Node.js standard library).&lt;/p&gt;
&lt;p class="note"&gt;
  The program also gives us access to a type checker that we can use
  to query the type of any node in the program tree. We'll get into
  this in another post.
&lt;/p&gt;&lt;p&gt;Our interpret program will iterate over all the source files, ignoring
the TypeScript definition files, and call interpretNode on all the
elements of the source file.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode(node: ts.Node) { // TODO }

function interpret(program: ts.Program) {
  return program.getSourceFiles().map((source) =&amp;gt; {
    const { fileName } = source;
    if (fileName.endsWith(&amp;#39;.d.ts&amp;#39;)) {
      return;
    }

    const results = [];
    ts.forEachChild(source, (node) =&amp;gt; {
      results.push(interpretNode(node));
    });
    return results;
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interpretnode-and-ts.node"&gt;interpretNode and ts.Node&lt;/h3&gt;&lt;p&gt;A Node is a wrapper for most elements of what we consider a program to
be, such as a binary expression (&lt;code&gt;2 + 3&lt;/code&gt;), a literal
expression (&lt;code&gt;2&lt;/code&gt;), a function call expression
(&lt;code&gt;a(c)&lt;/code&gt;), and so forth. When exploring a parser, it takes
time to become familiar with the particular way that a parser breaks
out a program into a tree of nodes.&lt;/p&gt;
&lt;p&gt;As a concrete example, the following program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;print(a);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will be built into ts.Node tree along these lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Node: ExpressionStatement: print(a);
  Node: CallExpression: print, a
    Node: Identifier: print
    Node: Identifier: a
Node: EndOfFileToken
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And another example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;1 + 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Will be built into a ts.Node tree along these lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Node: Expression: 1 + 3
  Node: BinaryExpression: 1, 3, +
    Node: NumericLiteral: 1
    Node: NumericLiteral: 3
    Node: PlusToken
Node: EndOfFileToken
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But how would one come to know this?&lt;/p&gt;
&lt;h4 id="exploring-the-ts.node-tree"&gt;Exploring the ts.Node tree&lt;/h4&gt;&lt;p&gt;The easiest thing to do is throw an error on every Node type we don't
yet know about and fill in support for each program we throw at the
interpreter.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode(node: ts.Node) {
  switch (node.kind) {
    default:
      throw new Error(&amp;#39;Unsupported node type: &amp;#39; + ts.SyntaxKind[node.kind]);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let's run our interpreter against an input file,
&lt;code&gt;test.ts&lt;/code&gt;, that combines these two to make a
semi-interesting program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.ts
print(1 + 2);
$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: ExpressionStatement
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we see an outer wrapper, an ExpressionStatement. To proceed we
look up the definition of an ExpressionStatement in TypeScript source
code,
&lt;a href="https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts"&gt;src/compiler/types.ts&lt;/a&gt;
to be specific. This file will become our best friend. Hit ctrl-f and
look for "interface ExpressionStatement ". We see that it has only one
child, &lt;code&gt;expression&lt;/code&gt;, so we call &lt;code&gt;interpretNode&lt;/code&gt;
on this recursively:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode(node: ts.Node) {
  switch (node.kind) {
    case ts.SyntaxKind.ExpressionStatement: {
      const es = node as ts.ExpressionStatement;
      return interpretNode(es.expression);
    }
    default:
      throw new Error(&amp;#39;Unsupported node type: &amp;#39; + ts.SyntaxKind[node.kind]);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thankfully TypeScript will be very quick to call us out if we
misunderstand this structure.&lt;/p&gt;
&lt;p class="note"&gt;
  It's pretty weird to me that the ts.Node tree is organized such that
  I must cast at each ts.Node but that's what they do even in the
  TypeScript source so I don't think I'm misunderstanding.
&lt;/p&gt;&lt;p&gt;Now we recompile and run the interpreter against the program to
discover the next ts.Node type.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: CallExpression
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool! Back to
&lt;a href="https://github.com/Microsoft/TypeScript/blob/master/src/compiler/types.ts"&gt;src/compiler/types.ts&lt;/a&gt;.
Call expressions are complex enough that we'll break out handling them
into a separate function.&lt;/p&gt;
&lt;h3 id="interpretcall-and-ts.callexpression"&gt;interpretCall and ts.CallExpression&lt;/h3&gt;&lt;p&gt;From our reading of types.ts we need to handle the expression that
evaluates to a function, and we need to handle its parameters. We'll
just call &lt;code&gt;interpretNode&lt;/code&gt; on each of these to get their
real value. And finally we'll call the function with the arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretCall(ce: ts.CallExpression) {
  const fn = interpretNode(ce.expression);
  const args = ce.arguments.map(interpretNode);
  return fn(...args);
}

function interpretNode() {
  switch (node.kind) {
    ...
    case ts.SyntaxKind.CallExpression: {
      const ce = node as ts.CallExpression;
      return interpretCall(ce);
    }
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="node"&gt;
  Please ignore the fact that we are not correctly setting
  &lt;code&gt;this&lt;/code&gt; here.
&lt;/p&gt;&lt;p&gt;Recompile and let's see what's next!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: Identifier
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And back to types.ts.&lt;/p&gt;
&lt;h3 id="ts.identifier"&gt;ts.Identifier&lt;/h3&gt;&lt;p&gt;In order to support identifiers in general we'd need to have a context
we could use to look up the value of an identifier. But we don't have
a context like this right now so we'll add builtin support for a
&lt;code&gt;print&lt;/code&gt; function so we can get some output!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode() {
  switch (node.kind) {
    ...
    case ts.SyntaxKind.Identifier: {
      const id = (node as ts.Identifier).escapedText as string;
      if (id === &amp;#39;print&amp;#39;) {
        return function (...args) { console.log(...args); };
      }

      throw new Error(&amp;#39;Unsupported identifier: &amp;#39; + id);
    }
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recompile and let's see what's next!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: BinaryExpression
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're finally into the parameters.&lt;/p&gt;
&lt;h3 id="interpretbinaryexpression-and-ts.binaryexpression"&gt;interpretBinaryExpression and ts.BinaryExpression&lt;/h3&gt;&lt;p&gt;Looking into types.ts for this Node type suggests we may want to break
this out into its own function as well; there are a ton of operator
types. Within the &lt;code&gt;interpretBinaryExpression&lt;/code&gt; helper we'll
interpret each operand and then switch on the operator type. We'll
throw an error on operators we don't know about -- all of them at
first:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretBinaryExpression(be: ts.BinaryExpression) {
  const left = interpretNode(be.left);
  const right = interpretNode(be.right);
  switch (be.operatorToken.kind) {
    default:
      throw new Error(&amp;#39;Unsupported operator: &amp;#39; + ts.SyntaxKind[be.operatorToken.kind]);
  }
}

function interpretNode() {
  switch (node.kind) {
    ...
    case ts.SyntaxKind.BinaryExpression: {
      const be = node as ts.BinaryExpression;
      return interpretBinaryExpression(be);
    }
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We know the drill.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: FirstLiteralToken
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point we're actually failing first on an unknown &lt;strong&gt;node type&lt;/strong&gt;
rather than an operator. This is because we interpret the operands
(which are numeric literals) before we look up the operator. Time to
revisit types.ts!&lt;/p&gt;
&lt;h3 id="ts.firstliteraltoken,-ts.numericliteral"&gt;ts.FirstLiteralToken, ts.NumericLiteral&lt;/h3&gt;&lt;p&gt;Looking at types.ts shows us that &lt;code&gt;FirstLiteralToken&lt;/code&gt; is a
synonym for &lt;code&gt;NumericLiteral&lt;/code&gt;. The latter name is more
obvious, so let's add that to our supported Node list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode() {
  switch (node.kind) {
    ...
      case ts.SyntaxKind.NumericLiteral: {
      const nl = node as ts.NumericLiteral;
      return Number(nl.text);
    }
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we keep going!&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported operator: PlusToken
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're into unknown operator territory!&lt;/p&gt;
&lt;h3 id="interpretbinaryexpression-and-ts.plustoken"&gt;interpretBinaryExpression and ts.PlusToken&lt;/h3&gt;&lt;p&gt;A simple extension to our existing
&lt;code&gt;interpretBinaryExpression&lt;/code&gt;, we return the sum of the left
and right values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretBinaryExpression(be: ts.BinaryExpression) {
  const left = interpretNode(be.left);
  const right = interpretNode(be.right);
  switch (be.operatorToken.kind) {
    case ts.SyntaxKind.PlusToken:
      return left + right;
    default:
      throw new Error(&amp;#39;Unsupported operator: &amp;#39; + ts.SyntaxKind[be.operatorToken.kind]);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we give it another shot.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
...
Error: Unsupported node type: EndOfFileToken
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="ts.syntaxkind.endoffiletoken"&gt;ts.SyntaxKind.EndOfFileToken&lt;/h3&gt;&lt;p&gt;Our final Node type before a working program, we simply do nothing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs typescript"&gt;function interpretNode() {
  switch (node.kind) {
    ...
    case ts.SyntaxKind.EndOfFileToken:
      break;
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One more time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ tsc interpreter.ts
$ node interpreter.js test.ts
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A working program! And if we jiggle the test?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat test.ts
print(1 + 5);
$ node interpreter.js test.ts
6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're well on our way to interpreting TypeScript, and have gained some
familiarity with the TypeScript Compiler API.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/jsi"&gt;All code is available on Github.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Quick intro to the TypeScript Compiler API by writing an interpreter &lt;a href="https://t.co/QKz3XtOuP9"&gt;https://t.co/QKz3XtOuP9&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1117461518801604613?ref_src=twsrc%5Etfw"&gt;April 14, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/interpreting-typescript.html</guid><pubDate>Sun, 14 Apr 2019 00:00:00 +0000</pubDate></item><item><title>Writing a web server from scratch: 1. HTTP and sockets</title><link>http://notes.eatonphil.com/web-server-basics-http-and-sockets.html</link><description>&lt;p&gt;Say we have some HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs html"&gt;&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And say we'd like to be able to render this page in a web browser. If
the server is hosted locally we may want to enter
&lt;code&gt;localhost:9000/hello-world.html&lt;/code&gt; in the address bar, hit
enter, make a request (done by the browser), receive a response (sent
by some server), and render the result (done by the browser).&lt;/p&gt;
&lt;p&gt;Here is a minimal, often incomplete, and unsafe Node.js program (about
100 LoC) that would serve this (&lt;a href="https://github.com/eatonphil/uweb"&gt;code available on
Github&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const fs = require(&amp;#39;fs&amp;#39;);
const net = require(&amp;#39;net&amp;#39;);

const CRLF = &amp;#39;\r\n&amp;#39;;

const HELLO_WORLD = `&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;`;
const NOT_FOUND = `&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Not found&amp;lt;/h1&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;`;

class HTTPRequestHandler {
  constructor(connection) {
    this.connection = connection;
    this.request = {
      statusLine: null,
      headers: {},
      body: null,
    };
  }

  parse(buffer) {
    const lines = buffer.toString().split(CRLF);

    // Parse/store status line if necessary
    if (!this.request.statusLine) {
      const [method, path, protocol] = lines.shift().split(&amp;#39; &amp;#39;);
      this.request.statusLine = { method, path, protocol };
    }

    // Parse/store headers if the body hasn&amp;#39;t begun
    if (!this.request.body) {
      for (let line = lines.shift(); lines.length; line = lines.shift()) {
        // Reached the end of headers, double CRLF
        if (line === &amp;#39;&amp;#39;) {
          this.request.body = &amp;#39;&amp;#39;;
          break;
        }

        const [key, value] = line.split(&amp;#39;:&amp;#39;);

        const safeKey = key.toLowerCase();
        if (!this.request.headers[safeKey]) {
          this.request.headers[safeKey] = [];
        }

        this.request.headers[safeKey].push(value.trimStart());
      }
    }

    this.request.body += lines.join(CRLF);
  }

  requestComplete() {
    if (!this.request.statusLine || !Object.keys(this.request.headers).length || this.request.body === null) {
      return false;
    }

    const [contentLength] = this.request.headers[&amp;#39;content-length&amp;#39;] || [];
    if (this.request.statusLine.method !== &amp;#39;GET&amp;#39; &amp;amp;&amp;amp; this.request.body.length !== contentLength) {
      return false;
    }

    return true;
  }

  sendResponse() {
    const response = { status: 200, statusMessage: &amp;#39;OK&amp;#39;, body: &amp;#39;&amp;#39; };

    if (this.request.statusLine.path === &amp;#39;/hello-world.html&amp;#39;) {
      response.body = HELLO_WORLD;
    } else {
      response.status = 404;
      response.statusMessage = &amp;#39;NOT FOUND&amp;#39;;
      response.body = NOT_FOUND;
    }

    const serialized = &amp;#39;HTTP/1.1 ${response.status} ${response.statusMessage}&amp;#39; + CRLF +
                       &amp;#39;Content-Length: &amp;#39; + response.body.length + CRLF + CRLF +
                       response.body;
    this.connection.write(serialized);
  }

  handle(buffer) {
    this.parse(buffer);

    if (!this.requestComplete()) {
      return;
    }

    this.sendResponse();

    // Other-wise the connection may attempt to be re-used, we don&amp;#39;t support this.
    this.connection.end();
  }
}

function handleConnection(connection) {
  const handler = new HTTPRequestHandler(connection);
  connection.on(&amp;#39;data&amp;#39;, (buffer) =&amp;gt; handler.handle(buffer));
}

const server = net.createServer(handleConnection);

server.listen(&amp;#39;9000&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So what's going on?&lt;/p&gt;
&lt;h3 id="the-protocol"&gt;The protocol&lt;/h3&gt;&lt;p&gt;HTTP (version 1.1, specifically) is a convention for connecting over
TCP/IP and sending plain-text messages between two processes. HTTP
messages are broken into two categories: requests (the sender of a
request is called a "client") and responses (the sender of a response
is called a "server").&lt;/p&gt;
&lt;p&gt;HTTP is important because it is the default protocol of web
browsers. When we type in &lt;code&gt;localhost:9000/hello-world.html&lt;/code&gt;
and hit enter, the browser will open an TCP/IP connection to the
location &lt;code&gt;localhost&lt;/code&gt; on the port &lt;code&gt;9000&lt;/code&gt; and send
an HTTP request. If/when it receives the HTTP response from the server
it will try to render the response.&lt;/p&gt;
&lt;h4 id="an-http-request"&gt;An HTTP request&lt;/h4&gt;&lt;p&gt;A bare minimum HTTP/1.1 request (&lt;a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html"&gt;defined
here&lt;/a&gt;) based
on the request for &lt;code&gt;localhost:9000/hello-world.html&lt;/code&gt; is the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs text"&gt;GET /hello-world.html HTTP/1.1\r\nHost: localhost:9000\r\n\r\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p class="note"&gt;
  The spec explicitly requires the &lt;code&gt;\r\n&lt;/code&gt; combo to
  represent a newline instead of simply &lt;code&gt;\n&lt;/code&gt;.
&lt;/p&gt;&lt;p&gt;If we printed out this request it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs text"&gt;GET /hello-world.html HTTP/1.1
Host: localhost:9000
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="components-of-an-http-request"&gt;Components of an HTTP request&lt;/h4&gt;&lt;p&gt;An HTTP/1.1 request is made up of a few parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Mandatory]: The status line (the first line) followed by a CRLF (the &lt;code&gt;\r\n&lt;/code&gt; combo)&lt;/li&gt;
&lt;li&gt;[Mandatory]: HTTP headers separated by a CRLF and followed by an additional CRLF&lt;/li&gt;
&lt;li&gt;[Optional]: The request body&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The status line consists of the request method (e.g. GET, POST, PUT,
etc.), the path for the request, and the protocol -- all separated by
a space.&lt;/p&gt;
&lt;p&gt;An HTTP header is a key-value pair separated by a colon. Spaces
following the colon are ignored. The key is case insensitive. Only
the &lt;code&gt;Host&lt;/code&gt; header appears to be mandatory. Since these
headers are sent by the client they are intended for the server's use.&lt;/p&gt;
&lt;p&gt;The request body is text and is only relevant for requests of certain
methods (e.g. POST but not GET).&lt;/p&gt;
&lt;h4 id="an-http-response"&gt;An HTTP response&lt;/h4&gt;&lt;p&gt;A bare minimum HTTP/1.1 response (&lt;a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html"&gt;defined
here&lt;/a&gt;) based
on the file we wanted to send back is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs text"&gt;HTTP/1.1 200 OK\r\n\r\n&amp;lt;html&amp;gt;\n  &amp;lt;body&amp;gt;\n    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;\n  &amp;lt;/body&amp;gt;\n&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we printed out this response it would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs text"&gt;HTTP/1.1 200 OK

&amp;lt;html&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;Hello world!&amp;lt;/h1&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="components-of-an-http-response"&gt;Components of an HTTP response&lt;/h4&gt;&lt;p&gt;An HTTP/1.1 response is made up of a few parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[Mandatory]: The status line (the first line) followed by a CRLF&lt;/li&gt;
&lt;li&gt;[Optional]: HTTP headers separated by a CRLF and followed by an additional CRLF&lt;/li&gt;
&lt;li&gt;[Optional]: The request body&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The status line consists of the protocol, the status code, and the
status message -- all separated by a space.&lt;/p&gt;
&lt;p&gt;HTTP response headers are the same as HTTP request headers although in
a response they are directives from the server to the client. There
are many &lt;a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html"&gt;standard
headers&lt;/a&gt; that
are used for such things as setting cache rules, setting cookies,
settings response type (e.g. HTML vs CSS vs PNG so the browser knows
how to handle the response).&lt;/p&gt;
&lt;p&gt;The response body is similar to the HTTP request body.&lt;/p&gt;
&lt;h3 id="sockets"&gt;Sockets&lt;/h3&gt;&lt;p&gt;Most operating systems have a built-in means of connecting over TCP/IP
(and sending and receiving messages) called "sockets". Sockets allow
us to treat TCP/IP connections like files in memory. Most programming
languages have a built-in socket library. Node.js provides a
high-level interface for listening on a port and handling new
connections.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function handleConnection(connection) {
  connection.on(&amp;#39;data&amp;#39;, (buffer) =&amp;gt; doSomething???);
}

const server = net.createServer(handleConnection);

server.listen(&amp;#39;9000&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the program is listening, clients can open TCP/IP connections to
the address (&lt;code&gt;localhost&lt;/code&gt;) and port (&lt;code&gt;9000&lt;/code&gt;) and
our program takes over from there. Each connection is handled
separately and receives "data" events. Each data event includes new
bytes available for us to handle.&lt;/p&gt;
&lt;p&gt;Let's encapsulate the state of each connection in HTTPRequestHandler
class. Its function will be to parse data as it becomes available and
respond to the request when the request is done.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class HTTPRequestHandler {
  constructor(connection) {
    this.connection = connection;
  }

  parse(buffer) {}

  requestComplete() {}

  sendResponse() {}

  handle(buffer) {
    this.parse(buffer);

    if (!this.requestComplete()) {
      return;
    }

    this.sendResponse();

    // Other-wise the connection may attempt to be re-used, we don&amp;#39;t support this.
    this.connection.end();
  }
}

function handleConnection(connection) {
  const handler = new HTTPRequestHandler(connection);
  connection.on(&amp;#39;data&amp;#39;, (buffer) =&amp;gt; handler.handle(buffer));
}

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are three functions we need to implement
now: &lt;code&gt;parse(buffer)&lt;/code&gt;, &lt;code&gt;requestComplete()&lt;/code&gt;,
and &lt;code&gt;sendResponse&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="parse(buffer)"&gt;parse(buffer)&lt;/h4&gt;&lt;p&gt;This function will be responsible for progressively pulling out data
from the buffer. If the status line has not been received, it will try
to grab the status line. If the body has not yet started, it will
accumulate headers. Then it will continue accumulating the body until
we close the connection (this will happen implicitly when
&lt;code&gt;requestComplete()&lt;/code&gt; returns true).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class HTTPRequestHandler {
  constructor(connection) {
    this.connection = connection;
    this.request = {
      statusLine: null,
      headers: {},
      body: null,
    };
  }

  parse(buffer) {
    const lines = buffer.toString().split(CRLF);

    // Parse/store status line if necessary
    if (!this.request.statusLine) {
      const [method, path, protocol] = lines.shift().split(&amp;#39; &amp;#39;);
      this.request.statusLine = { method, path, protocol };
    }

    // Parse/store headers if the body hasn&amp;#39;t begun
    if (this.request.body === null) {
      for (let line = lines.shift(); lines.length; line = lines.shift()) {
        // Reached the end of headers, double CRLF
        if (line === &amp;#39;&amp;#39;) {
          this.request.body = &amp;#39;&amp;#39;;
          break;
        }

        const [key, value] = line.split(&amp;#39;:&amp;#39;);

        const safeKey = key.toLowerCase();
        if (!this.request.headers[safeKey]) {
          this.request.headers[safeKey] = [];
        }

        this.request.headers[safeKey].push(value.trimStart());
      }
    }

    this.request.body += lines.join(CRLF);
  }

...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="requestcomplete()"&gt;requestComplete()&lt;/h4&gt;&lt;p&gt;This function will look at the internal request state and return false
if the status line has not been received, no headers have been
received (although this is stricter than the HTTP/1.1 standard
requires), or if the body length is not equal to the value of the
&lt;code&gt;Content-Length&lt;/code&gt; header.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class HTTPRequestHandler {

...

  requestComplete() {
    if (!this.request.statusLine || !Object.keys(this.request.headers).length || this.request.body === null) {
      return false;
    }

    const [contentLength] = this.request.headers[&amp;#39;content-length&amp;#39;] || [];
    if (this.request.statusLine.method !== &amp;#39;GET&amp;#39; &amp;amp;&amp;amp; this.request.body.length !== contentLength) {
      return false;
    }

    return true;
  }

...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="sendresponse()"&gt;sendResponse()&lt;/h4&gt;&lt;p&gt;Finally we'll hard-code two responses (one for the valid request for
/hello-world.html and a catch-all 404 response for every other
request). These responses need to be serialized according the HTTP
response format described above and written to the connection.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class HTTPRequestHandler {

...

  sendResponse() {
    const response = { status: 200, statusMessage: 'OK', body: '' };

    if (this.request.statusLine.path === '/hello-world.html') {
      response.body = HELLO_WORLD;
    } else {
      response.status = 404;
      response.statusMessage = 'NOT FOUND';
      response.body = NOT_FOUND;
    }

    const serialized = 'HTTP/1.1 ${response.status} ${response.statusMessage}' + CRLF +
                       'Content-Length: ' + response.body.length + CRLF + CRLF +
                       response.body;
    this.connection.write(serialized);
  }  

...

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="run-it"&gt;Run it&lt;/h3&gt;&lt;p&gt;Now that we've got all the pieces we can finally run the initial program:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ node uweb.js &amp;amp;
$ open localhost:9000/hello-world.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we see the page! Try any other path and we receive a 404.&lt;/p&gt;
&lt;h3 id="review-and-next-steps"&gt;Review and next steps&lt;/h3&gt;&lt;p&gt;We covered the basics of HTTP/1.1: a very simple, plain-text protocol
oriented around requests and responses over a TCP/IP connection. We
realize we need to know little about anything but parsing and
formatting text on top of the TCP/IP blackbox called sockets. We
created a simple application that returns different responses based on
the request. But we're a far shot from a more general library, a web
framework. Future posts will explore this transition as well as
performance and more features.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/uweb"&gt;Code is available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;First post in a new series on web server basics starting with HTTP and sockets (using JavaScript/Node.js). &lt;a href="https://t.co/uBiNfOBJeZ"&gt;https://t.co/uBiNfOBJeZ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1114988522702823424?ref_src=twsrc%5Etfw"&gt;April 7, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/web-server-basics-http-and-sockets.html</guid><pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate></item><item><title>Writing a simple JSON path parser</title><link>http://notes.eatonphil.com/writing-a-simple-json-path-parser.html</link><description>&lt;p&gt;Let's say we want to implement a simple list filtering language so
we can enter &lt;code&gt;a.b = 12&lt;/code&gt; and return only results in a
list where the &lt;code&gt;a&lt;/code&gt; column is an object that contains a
field &lt;code&gt;b&lt;/code&gt; that is set to the value 12. What would a
&lt;code&gt;filter(jsonPath, equals, listOfObjects)&lt;/code&gt; function look
like?&lt;/p&gt;
&lt;p&gt;If we only needed to support object lookup, we might
implement &lt;code&gt;filter&lt;/code&gt; by splitting the &lt;code&gt;jsonPath&lt;/code&gt;
on periods and look at each object in the &lt;code&gt;listOfObjects&lt;/code&gt;
for matching values. It might look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function filter(jsonPath, equals, listOfObjects) {
  const parts = jsonPath.split(&amp;#39;.&amp;#39;);

  function filterSingle(object) {
    let objectAtPath = object;
    let i = 0;
    for (let part = parts[i]; part &amp;amp;&amp;amp; objectAtPath; part = parts[++i]) {
      objectAtPath = objectAtPath[part];
    }

    return i === parts.length &amp;amp;&amp;amp; objectAtPath === equals;
  }

  return listOfObjects.filter(filterSingle);
}

require(&amp;#39;assert&amp;#39;).deepEqual(
  filter(&amp;#39;foo.bar&amp;#39;, 12, [{ foo: { bar: 12 } }, { foo: null }]),
  [{ foo: { bar: 12 } }],
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That doesn't work too badly. We haven't handled edge cases like a
&lt;code&gt;jsonPath&lt;/code&gt; of &lt;code&gt;foo..bar&lt;/code&gt; or
&lt;code&gt;bar.&lt;/code&gt;. But those would not be difficult to handle:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function filter(jsonPath, equals, listOfObjects) {
  if (jsonPath.charAt(0) === &amp;#39;.&amp;#39;) {
    throw new Error(&amp;#39;JSON path cannot begin with a dot, in: &amp;#39; + jsonPath);
  } else if (jsonPath.charAt(jsonPath.length - 1) === &amp;#39;.&amp;#39;) {
    throw new Error(&amp;#39;JSON path cannot end with a dot, in: &amp;#39; + jsonPath);
  }

  const parts = jsonPath.split(&amp;#39;.&amp;#39;);
  if (parts.reduce((hasEmptyPart, part) =&amp;gt; hasEmptyPart || part.length === 0, false)) {
    throw new Error(&amp;#39;JSON path cannot contain an empty section, in: &amp;#39; + jsonPath);
  }

  function filterSingle(object) {
    let objectAtPath = object;
    let i = 0;
    for (let part = parts[i]; part &amp;amp;&amp;amp; objectAtPath; part = parts[++i]) {
      objectAtPath = objectAtPath[part];
    }

    return i === parts.length &amp;amp;&amp;amp; objectAtPath === equals;
  }

  return listOfObjects.filter(filterSingle);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we now handle the most obvious invalid path cases.&lt;/p&gt;
&lt;h3 id="arrays?"&gt;Arrays?&lt;/h3&gt;&lt;p&gt;If we want to support array path syntax, things get harder. For
example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;require(&amp;#39;assert&amp;#39;).deepEqual(
  filter(&amp;#39;foo.bar[0].biz&amp;#39;, 14, [{ foo: { bar: [ { biz: 14 }, { biz: 19 } ] } }, { foo: { bar: null } }]),
  [{ foo: { bar: [ { biz: 14 }, { biz: 19 } ] } }],
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could try to stick with the hammer that is
&lt;code&gt;String.prototype.split&lt;/code&gt; and write some really messy
code. :) Or we could switch to an approach that gives us more
control. Let's do that.&lt;/p&gt;
&lt;p&gt;We'll build a very simple lexer that will iterate over each character
accumulating characters into individual tokens that represent the
pieces of the path. Let's start by supporting the original
&lt;code&gt;jsonPath&lt;/code&gt; syntax and error-handling.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function getJsonPathParts(path) {
  const parts = [];
  let currentToken = &amp;#39;&amp;#39;;

  for (let i = 0; i &amp;lt; path.length; i++) {
    const c = path[i];
    switch (c) {
      case &amp;#39;.&amp;#39;: {
        if (!currentToken) {
          throw new Error(&amp;#39;JSON path cannot contain empty section, in: &amp;#39; + path);
        }
        parts.push(currentToken);
        currentToken = &amp;#39;&amp;#39;;
        break;
      }
      default: {
        currentToken += c;
        break;
      }
    }
  }

  if (!currentToken) {
    throw new Error(&amp;#39;JSON path cannot end with dot, in: &amp;#39; + path);
  }

  parts.push(currentToken);
  return parts;
}

function filter(jsonPath, equals, listOfObjects) {
  const parts = getJsonPathParts(jsonPath);

  function filterSingle(object) {
    let objectAtPath = object;
    let i = 0;
    for (let part = parts[i]; part &amp;amp;&amp;amp; objectAtPath; part = parts[++i]) {
      objectAtPath = objectAtPath[part];
    }

    return i === parts.length &amp;amp;&amp;amp; objectAtPath === equals;
  }

  return listOfObjects.filter(filterSingle);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not too bad!&lt;/p&gt;
&lt;h3 id="arrays?"&gt;Arrays?&lt;/h3&gt;&lt;p&gt;Right. Let's build on &lt;code&gt;getJsonPathParts&lt;/code&gt; to support array
syntax. Along with that we're going to impose some restrictions. The
object path parts must be only alphanumeric characters plus dashes and
underscores. The array index must only be numeric characters. Anything
else should throw an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function getJsonPathParts(path) {
  const parts = [];
  let currentToken = &amp;#39;&amp;#39;;
  let inArray = false;

  for (let i = 0; i &amp;lt; path.length; i++) {
    const c = path[i];
    switch (c) {
      case &amp;#39;.&amp;#39;: {
        if (currentToken === &amp;#39;&amp;#39;) {
          throw new Error(&amp;#39;JSON path cannot contain empty section, in: &amp;#39; + path);
        }

        parts.push(currentToken);
        currentToken = &amp;#39;&amp;#39;;
        break;
      }
      case &amp;#39;[&amp;#39;: {
        if (inArray) {
          throw new Error(&amp;#39;JSON path contains unexpected left bracket, in: &amp;#39; + path);
        }

        if (currentToken === &amp;#39;&amp;#39;) {
          throw new Error(&amp;#39;JSON path cannot contain empty section, in: &amp;#39; + path);
        }

        parts.push(currentToken);
        currentToken = &amp;#39;&amp;#39;;
        inArray = true;
        break;
      }
      case &amp;#39;]&amp;#39;: {
        if (!inArray) {
          throw new Error(&amp;#39;JSON path contains unexpected right bracket, in: &amp;#39; + path);
        }

        if (currentToken === &amp;#39;&amp;#39;) {
          throw new Error(&amp;#39;JSON path array index must not be empty, in: &amp;#39; + path);
        }

        // Array indices are recorded as numbers, not strings.
        currentToken = parseInt(currentToken, 10);
        inArray = false;
        break;
      }
      default: {
        const code = c.charCodeAt(0);

        if (inArray) {
          if (code &amp;gt;= &amp;#39;0&amp;#39;.charCodeAt(0) &amp;amp;&amp;amp; code &amp;lt;= &amp;#39;9&amp;#39;.charCodeAt(0)) {
            currentToken += c;
            continue;
          }

          throw new Error(&amp;#39;JSON path array index must be numeric, in: &amp;#39; + path);
        }

        if ((code &amp;gt;= &amp;#39;A&amp;#39;.charCodeAt(0) &amp;amp;&amp;amp; code &amp;lt;= &amp;#39;z&amp;#39;.charCodeAt(0)) ||
            (code &amp;gt;= &amp;#39;0&amp;#39;.charCodeAt(0) &amp;amp;&amp;amp; code &amp;lt;= &amp;#39;9&amp;#39;.charCodeAt(0)) ||
            [&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;].includes(c)) {
          currentToken += c;
          continue;
        }

        throw new Error(&amp;#39;JSON path part must contain only alphanumeric characters, in: &amp;#39; + path);
      }
    }
  }

  if (currentToken === &amp;#39;&amp;#39;) {
    throw new Error(&amp;#39;JSON path cannot end with dot, in: &amp;#39; + path);
  }

  parts.push(currentToken);
  return parts;
}

require(&amp;#39;assert&amp;#39;).deepEqual(getJsonPathParts(&amp;#39;foo.bar[0].biz&amp;#39;), [&amp;#39;foo&amp;#39;, &amp;#39;bar&amp;#39;, 0, &amp;#39;biz&amp;#39;]);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we've got a simple JSON path parser with decent error handling! Of
course we wouldn't want to use this little library in production until
we had some serious test coverage. But writing tests and calling out
my mistakes will be left here as an exercise for the reader. :)&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New (short) post on parsing JSON paths in JavaScript &lt;a href="https://t.co/mIjOMugA7C"&gt;https://t.co/mIjOMugA7C&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1111262461074784256?ref_src=twsrc%5Etfw"&gt;March 28, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-a-simple-json-path-parser.html</guid><pubDate>Wed, 27 Mar 2019 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 3. LLVM</title><link>http://notes.eatonphil.com/compiler-basics-llvm.html</link><description>&lt;p class="note"&gt;
  Previously in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-lisp-to-assembly.html"&gt;1. lisp to assembly&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-functions.html"&gt;2. user-defined functions and variables&lt;/a&gt;
  &lt;br /&gt;
  &lt;br/&gt;
  Next in compiler basics:
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-conditionals.html"&gt;4. LLVM conditionals and compiling fibonacci&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-system-calls.html"&gt;5. LLVM system calls&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-an-x86-upgrade.html"&gt;6. an x86 upgrade&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll extend the
&lt;a href="https://github.com/eatonphil/ulisp"&gt;compiler&lt;/a&gt; to emit &lt;a href="https://llvm.org/docs/LangRef.html"&gt;LLVM
IR&lt;/a&gt; as an option instead of x86
assembly.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/ulisp"&gt;All source code is available on Github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;LLVM IR is a portable, human-readable, typed, assembly-like syntax
that LLVM can apply &lt;a href="https://llvm.org/docs/Passes.html"&gt;optimizations&lt;/a&gt;
on before generating assembly for the target architecture. Many
language implementors choose to compile to LLVM IR specifically to
avoid needing to implement sophisticated optimizations.&lt;/p&gt;
&lt;p&gt;But the biggest reason I'm adding an LLVM backend is so that I can
punt on implementing &lt;a href="https://en.wikipedia.org/wiki/Register_allocation"&gt;register
allocation&lt;/a&gt;. This
is the technique that allows you to generically use as many registers
as possible before storing local variables on the stack. While
register allocation algorithms are not &lt;em&gt;that&lt;/em&gt; difficult, I got
bored/lazy trying to implement this for ulisp. And LLVM IR provides
"infinite" locals that get mapped as needed to registers and the stack
-- implementing register allocation.&lt;/p&gt;
&lt;h3 id="llvm-ir-basics"&gt;LLVM IR basics&lt;/h3&gt;&lt;p&gt;In LLVM IR, all local variables must be prefixed
with &lt;code&gt;%&lt;/code&gt;. All global variables (including function names)
must be prefixed with &lt;code&gt;&amp;#64;&lt;/code&gt;. LLVM IR must be in
&lt;a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/lectures/09-ssa.pdf"&gt;single-static
assignment&lt;/a&gt;
(SSA) form, which means that no variable is assigned
twice. Additionally, literals cannot be assigned to variables
directly. So we'll work around that by adding 0 to the
literal. Furthermore, we'll take advantage of
the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sub&lt;/code&gt;, and &lt;code&gt;mul&lt;/code&gt;
operations built into LLVM IR.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;; x = 4
%x = add i32 4, 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The type that the operation is operating on must be specified after
the operation name. In this case we are specifying
that &lt;code&gt;add&lt;/code&gt; is operating on and returning 32-bit integers.&lt;/p&gt;
&lt;p&gt;While this might seem very inefficient, we'll see in the end that
LLVM easily optimizes this away.&lt;/p&gt;
&lt;h4 id="function-definition"&gt;Function definition&lt;/h4&gt;&lt;p&gt;Functions are defined at the top-level and are much simpler than x86
assembly since the details of calling conventions are handled by LLVM.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;; (def plus (a b) (+ a b))
define i32 @plus (i32 a, i32 b) {
  %res = add i32 a, b
  ret i32 %res
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In ulisp, all functions will return a result (and the only supported
type for now are 32-bit integers). So we annotate the definition with
this return type (&lt;code&gt;i32&lt;/code&gt; in &lt;code&gt;define
i32&lt;/code&gt;). Finally, we return inside the function with
the &lt;code&gt;ret&lt;/code&gt; instruction that must also specify the type
(again &lt;code&gt;i32&lt;/code&gt;).&lt;/p&gt;
&lt;h4 id="generating-llvm-ir"&gt;Generating LLVM IR&lt;/h4&gt;&lt;p&gt;We are going to generate LLVM IR as text. But any large project will
benefit from generating LLVM IR via
&lt;a href="http://llvm.org/docs/ProgrammersManual.html"&gt;API&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="supporting-multiple-backends"&gt;Supporting multiple backends&lt;/h3&gt;&lt;p&gt;The goal is to be able to switch at compile-time between generating
x86 assembly or generating LLVM IR. So we'll need to reorganize ulisp
a little bit.&lt;/p&gt;
&lt;p&gt;We'll edit &lt;code&gt;src/ulisp.js&lt;/code&gt; to accept a second argument to
specify the backend (and from now on we'll default to LLVM).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const cp = require(&amp;#39;child_process&amp;#39;);
const fs = require(&amp;#39;fs&amp;#39;);

const { parse } = require(&amp;#39;./parser&amp;#39;);
const backends = require(&amp;#39;./backend&amp;#39;);

function main(args) {
  const input = fs.readFileSync(args[2]).toString();

  let backend;
  switch (args[3]) {
    case &amp;#39;llvm&amp;#39;:
    case undefined:
      backend = backends.llvm;
      break;
    case &amp;#39;x86&amp;#39;:
      backend = backends.x86;
      break;
    default:
      console.log(&amp;#39;Unsupported backend &amp;#39; + args[3]);
  }

  const [ast] = parse(input);
  const program = backend.compile(ast);

  try {
    fs.mkdirSync(&amp;#39;build&amp;#39;);
  } catch (e) {}
  backend.build(&amp;#39;build&amp;#39;, program);
}

main(process.argv);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="the-llvm-backend"&gt;The LLVM backend&lt;/h3&gt;&lt;p&gt;We'll add &lt;code&gt;src/backend/llvm.js&lt;/code&gt; and And expose
&lt;code&gt;compile&lt;/code&gt; and &lt;code&gt;build&lt;/code&gt; functions.&lt;/p&gt;
&lt;h4 id="compile(ast)"&gt;compile(ast)&lt;/h4&gt;&lt;p&gt;This will work the same as it did for the x86 backend, creating a new
&lt;code&gt;Compiler&lt;/code&gt; helper object, creating a scope manager (which
we'll get into in more detail shortly), and generating code from the
AST wrapped in a &lt;code&gt;begin&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.compile = function(ast) {
  const c = new Compiler();
  const scope = new Scope();
  c.compileBegin(ast, scope.symbol(), scope);
  return c.getOutput();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="build(builddir,-output)"&gt;build(buildDir, output)&lt;/h4&gt;&lt;p&gt;The job of &lt;code&gt;build&lt;/code&gt; will be to clean up the build directory,
write any output as needed to the directory, and compile the written
output. Since we're dealing with LLVM IR, we first call
&lt;a href="https://llvm.org/docs/CommandGuide/llc.html"&gt;llc&lt;/a&gt; on the IR file to
get an assembly file. Then we can call &lt;code&gt;gcc&lt;/code&gt; on the
assembly to get a binary output.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const cp = require(&amp;#39;child_process&amp;#39;);
const fs = require(&amp;#39;fs&amp;#39;);

...

module.exports.build = function(buildDir, program) {
  const prog = &amp;#39;prog&amp;#39;;
  fs.writeFileSync(buildDir + `/${prog}.ll`, program);
  cp.execSync(`llc -o ${buildDir}/${prog}.s ${buildDir}/${prog}.ll`);
  cp.execSync(`gcc -o ${buildDir}/${prog} ${buildDir}/${prog}.s`);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="taking-advantage-of-locals"&gt;Taking advantage of locals&lt;/h3&gt;&lt;p&gt;Before we get too far into the specifics of LLVM IR code generation,
let's build out the infrastructure to take advantage of "infinite"
locals. In particular, we want a local-manager (&lt;code&gt;Scope&lt;/code&gt;)
with four functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;register(local: name)&lt;/code&gt;: for tracking user variables and mapping to safe names&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symbol()&lt;/code&gt;: for tracking internal temporary variables&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get(local: name)&lt;/code&gt;: for returning the safe name of a user variable&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy()&lt;/code&gt;: for duplicating the local-tracker when we enter a new scope&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is important to track and map user variables into safe names so we
don't accidentally conflict between variable names used by the user
and names used by the compiler itself.&lt;/p&gt;
&lt;h4 id="register(local)"&gt;register(local)&lt;/h4&gt;&lt;p&gt;When we register, we'll want to replace any unsafe characters that
Lisp allows but LLVM likely won't. For now, we'll just replace any
dashes in the name (since dashes are fine in variables in Lisp) with
underscores. Then we'll add a number to the end of the local name
until we have a safe name that doesn't exist already. Finally we
return that safe name after storing the mapping.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {
  constructor() {
    this.locals = {};
  }

  register(local) {
    let copy = local.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);
    let n = 1;
    while (this.locals[copy]) {
      copy = local + n++;
    }

    this.locals[local] = copy;
    return copy;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="symbol()"&gt;symbol()&lt;/h4&gt;&lt;p&gt;This is a simple function that will return one new unused safe name
that we can store things in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {
  ...

  symbol() {
    const nth = Object.keys(this.locals).length + 1;
    return this.register(&amp;#39;sym&amp;#39; + nth);
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start off by making up a name based on the prefix &lt;code&gt;sym&lt;/code&gt;
and a suffix of the current key length and pass that into the
&lt;code&gt;register&lt;/code&gt; function to make sure we get a safe name.&lt;/p&gt;
&lt;h4 id="get(local)"&gt;get(local)&lt;/h4&gt;&lt;p&gt;This function is a very simple lookup to return the safe name for a
user variable. It is up to the caller of this function to handle if
the user variable does not exist in scope (and perhaps throw a
compiler error back to the programmer).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {
  ...

  get(local) {
    return this.locals[local];
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="copy()"&gt;copy()&lt;/h4&gt;&lt;p&gt;Finally, we want to expose a copy function so we can duplicate the
local storage before entering a new scope. (A variable inside a
function should not exist in scope outside the function.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Scope {
  ...

  copy() {
    const c = new Scope();
    c.locals = { ...this.locals };
    return c;
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="back-to-codegen!"&gt;Back to codegen!&lt;/h3&gt;&lt;p&gt;As mentioned in &lt;code&gt;module.exports.compile&lt;/code&gt;, we're going to
use a &lt;code&gt;Compiler&lt;/code&gt; that exposes a number of compiler helpers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;emit(depth, code)&lt;/code&gt;: an internal helper for outputting indented lines of code&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileBegin(ast, destination, scope)&lt;/code&gt;: compiles a begin block&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileExpression(ast, destination, scope)&lt;/code&gt;: compiles variable references, literals, and passes on function calls&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileCall(functionName, ast, destination, scope)&lt;/code&gt;: compiles a function call&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileDefine([functionName, parameters, ...body], destination, scope)&lt;/code&gt;: compiles a function definition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compileOp(op)&lt;/code&gt;: helper function for generating code for primitive operations like &lt;code&gt;add&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getOutput()&lt;/code&gt;: returns the code generated by the compiler&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="emit(depth,-code)"&gt;emit(depth, code)&lt;/h4&gt;&lt;p&gt;Like we had in the x86 backend, this will indent the code two spaces
&lt;code&gt;depth&lt;/code&gt; times and write it to the buffer we track generated
code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  constructor() {
    this.outBuffer = [];
  }

  emit(depth, code) {
    const indent = new Array(depth + 1).join(&amp;#39;  &amp;#39;);
    this.outBuffer.push(indent + code);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="compilebegin(ast,-destination,-scope)"&gt;compileBegin(ast, destination, scope)&lt;/h4&gt;&lt;p&gt;Our first compiler function actually does no code generation
itself. We'll call &lt;code&gt;compileExpression&lt;/code&gt; on each item within
the begin block. And we'll pass the &lt;code&gt;destination&lt;/code&gt; to the
last expression in the list so that the value of a begin block is set
to the value of its last expression. All other expressions will
receive a temporary variable to store results.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  ...

  compileBegin(body, destination, scope) {
    body.forEach((expression, i) =&amp;gt;
      this.compileExpression(
        expression,
        i === body.length - 1 ? destination : scope.symbol(),
        scope,
      ),
    );
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(begin 1 2) ; returns 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="compileexpression(ast,-destination,-scope)"&gt;compileExpression(ast, destination, scope)&lt;/h4&gt;&lt;p&gt;This is the most generic compile function. If the ast is a list
(representing a function call), it will pass compilation off to
&lt;code&gt;compileCall&lt;/code&gt;. Otherwise the only non-function call parts
of the language are variable references and numeric literals.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  ...

  compileExpression(exp, destination, scope) {
    // Is a nested function call, compile it
    if (Array.isArray(exp)) {
      this.compileCall(exp[0], exp.slice(1), destination, scope);
      return;
    }

    // If numeric literal, store to destination register by adding 0.
    if (Number.isInteger(exp)) {
      this.emit(1, `%${destination} = add i32 ${exp}, 0`);
      return;
    }

    // If is local, store to destination register similarly.
    const res = scope.get(exp);
    if (res) {
      this.emit(1, `%${destination} = add i32 %${res}, 0`);
    } else {
      throw new Error(
        &amp;#39;Attempt to reference undefined variable or unsupported literal: &amp;#39; +
          exp,
      );
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;1
...
a
...
(+ 1 a)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="compilecall(functionname,-arguments,-destination,-scope)"&gt;compileCall(functionName, arguments, destination, scope)&lt;/h4&gt;&lt;p&gt;Most function calls will automatically compile arguments before
calling the function. However, certain control-flow primitives don't
do this (e.g. &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, etc.). Macros in Lisp
allow you to add new control-flow primitives (even if you don't use it
to modify control-flow). But we will ignore user-defined primitives
for now.&lt;/p&gt;
&lt;p&gt;We'll keep a list of control-flow primitives and pass off compilation
to them if the function name matches a primitive. Otherwise, we'll
look up the function name in scope (to find its safe name), compile
the arguments, and call the function with the results of the
arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
    };
  }

  ...

  compileCall(fun, args, destination, scope) {
    if (this.primitiveFunctions[fun]) {
      this.primitiveFunctions[fun](args, destination, scope);
      return;
    }

    const validFunction = scope.get(fun);
    if (validFunction) {
      const safeArgs = args
        .map((a) =&amp;gt; {
          const res = scope.symbol();
          this.compileExpression(a, res, scope);
          return &amp;#39;i32 %&amp;#39; + res;
        })
        .join(&amp;#39;, &amp;#39;);
      this.emit(1, `%${destination} = call i32 @${validFunction}(${safeArgs})`);
    } else {
      throw new Error(&amp;#39;Attempt to call undefined function: &amp;#39; + fun);
    }
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yay LLVM for simplifying calls!&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(foo 1)
...
(+ 1 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="compiledefine([functionname,-parameters,-...body],-destination,-scope)"&gt;compileDefine([functionName, parameters, ...body], destination, scope)&lt;/h4&gt;&lt;p&gt;This is the last undefined compile function we've used. The call
signature may look funny but we write less code if we keep the
primitive signatures the same. In any case, JavaScript's destructuring
makes it pretty enough.&lt;/p&gt;
&lt;p&gt;Aside from code generation, we also need to add the function itself to
scope so we can look it up later in use. Additionally we need to
create a copy of the current scope for the body of the function. And
we'll add the parameter names themselves to the child scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  ...

  compileDefine([name, params, ...body], destination, scope) {
    // Add this function to outer scope
    const safeName = scope.register(name);

    // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
    const childScope = scope.copy();

    const safeParams = params.map((param) =&amp;gt;
      // Store parameter mapped to associated local
      childScope.register(param),
    );

    this.emit(
      0,
      `define i32 @${safeName}(${safeParams
        .map((p) =&amp;gt; `i32 %${p}`)
        .join(&amp;#39;, &amp;#39;)}) {`,
    );

    // Pass childScope in for reference when body is compiled.
    const ret = childScope.symbol();
    this.compileExpression(body[0], ret, childScope);

    this.emit(1, `ret i32 %${ret}`);
    this.emit(0, &amp;#39;}\n&amp;#39;);
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def plus (a b) (+ a b))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="compileop(op)"&gt;compileOp(op)&lt;/h4&gt;&lt;p&gt;The last function mentioned above will help us expose some useful
primitives.  This function will take a string builtin operation and
return a function that can be used to generate code when the operation
is called.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  ...

  compileOp(op) {
    return ([a, b], destination, scope) =&amp;gt; {
      const arg1 = scope.symbol();
      const arg2 = scope.symbol();
      this.compileExpression(a, arg1, scope);
      this.compileExpression(b, arg2, scope);
      this.emit(1, `%${destination} = ${op} i32 %${arg1}, %${arg2}`);
    };
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows us to add some builtin ops as primitives (even though they
aren't control-flow modifying).&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;class Compiler {
  constructor() {
    this.outBuffer = [];
    this.primitiveFunctions = {
      def: this.compileDefine.bind(this),
      begin: this.compileBegin.bind(this),
      &amp;#39;+&amp;#39;: this.compileOp(&amp;#39;add&amp;#39;),
      &amp;#39;-&amp;#39;: this.compileOp(&amp;#39;sub&amp;#39;),
      &amp;#39;*&amp;#39;: this.compileOp(&amp;#39;mul&amp;#39;),
    };
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(+ 1 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="hello-world!"&gt;Hello world!&lt;/h3&gt;&lt;p&gt;Putting it all together, we'll compile this Lisp program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def plus-two (a b)
     (+ a (+ b 2)))

(def main ()
     (plus-two 3 (plus-two 1 1)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get 9.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node src/ulisp.js tests/function_definition.lisp
$ ./build/prog
$ echo $?
9
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="generated-code"&gt;Generated code&lt;/h4&gt;&lt;p&gt;The generated LLVM can be found in &lt;code&gt;./build/prog.ll&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs llvm"&gt;define i32 @plus_two(i32 %a, i32 %b) {
  %sym7 = add i32 %a, 0
  %sym9 = add i32 %b, 0
  %sym10 = add i32 2, 0
  %sym8 = add i32 %sym9, %sym10
  %sym6 = add i32 %sym7, %sym8
  ret i32 %sym6
}

define i32 @main() {
  %sym6 = add i32 3, 0
  %sym8 = add i32 1, 0
  %sym9 = add i32 1, 0
  %sym7 = call i32 @plus_two(i32 %sym8, i32 %sym9)
  %sym5 = call i32 @plus_two(i32 %sym6, i32 %sym7)
  ret i32 %sym5
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see all these unnecessary &lt;code&gt;add, ... 0&lt;/code&gt;
instructions. But let's look at the x86 assembly that LLVM generates
in &lt;code&gt;build/prog.s&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs assembly"&gt;...

_plus_two:                              ## @plus_two
        .cfi_startproc
## %bb.0:
                                        ## kill: def $esi killed $esi def $rsi
                                        ## kill: def $edi killed $edi def $rdi
        leal    2(%rdi,%rsi), %eax
        retq
        .cfi_endproc
                                        ## -- End function
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we see that LLVM easily optimized the inefficiencies away. :)&lt;/p&gt;
&lt;h3 id="next-up"&gt;Next up&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Compiling conditionals&lt;/li&gt;
&lt;li&gt;Tail call optimization&lt;/li&gt;
&lt;li&gt;Lists and dynamic memory&lt;/li&gt;
&lt;li&gt;Strings?&lt;/li&gt;
&lt;li&gt;Foreign function calls?&lt;/li&gt;
&lt;li&gt;Self-hosting?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Adding an LLVM backend to ulisp (small Lisp compiler in JavaScript) &lt;a href="https://t.co/VIddKW1r3N"&gt;https://t.co/VIddKW1r3N&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1104795606365757442?ref_src=twsrc%5Etfw"&gt;March 10, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-llvm.html</guid><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate></item><item><title>AOT-compilation of Javascript with V8</title><link>http://notes.eatonphil.com/aot-compilation-of-javascript-with-v8.html</link><description>&lt;p&gt;tldr; I'm working on a AOT-compiled Javascript implementation called
&lt;a href="https://github.com/eatonphil/jsc"&gt;jsc&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Many dynamically typed programming languages have implementations that
compile to native binaries:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python: &lt;a href="https://cython.org/"&gt;Cython&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Common Lisp: &lt;a href="http://www.sbcl.org/"&gt;SBCL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Scheme: &lt;a href="https://www.call-cc.org/"&gt;Chicken Scheme&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The benefits of compiling dynamically typed languages are similar to
those of compiling statically typed languages:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Simplified deployment via a single binary&lt;/li&gt;
&lt;li&gt;Simplified foreign-function interfaces&lt;ul&gt;
&lt;li&gt;e.g. &lt;a href="https://wiki.call-cc.org/An%20extended%20FFI%20example"&gt;Embedded C/C++ strings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Predictable performance compared to JIT compiling interpreters&lt;/li&gt;
&lt;li&gt;Performance gains compared to non-JIT compiling interpreters&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I (re)discovered a common technique for compiling dynamic languages
while developing &lt;a href="https://github.com/eatonphil/bsdscheme"&gt;BSDScheme&lt;/a&gt;,
an interpreter and compiler for Scheme. In this technique, you use
core parts of the runtime code as a library that is imported and
referenced by compiled code.&lt;/p&gt;
&lt;p&gt;You save time building object-memory representations, memory
management, operations, interacting with existing libraries, etc. when
an interpreter already exists. The runtime as a library (plus existing
parser frontends) allows you to focus solely on code generation of
control flow.&lt;/p&gt;
&lt;h3 id="the-first-pass"&gt;The first pass&lt;/h3&gt;&lt;p&gt;I wrote the initial version of &lt;a href="https://github.com/eatonphil/jsc"&gt;jsc&lt;/a&gt;
in Rust using Dave Herman's
&lt;a href="https://github.com/dherman/esprit"&gt;esprit&lt;/a&gt; parser (supports a subset
of ES6 that includes all of ES5).&lt;/p&gt;
&lt;p&gt;The interesting parts of the runtime are taken care of by V8, e.g.:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V8::String&lt;/code&gt; - a Javascript string object&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V8::String::NewFromUtf8(isolate, "hello world!")&lt;/code&gt; - C++ string to Javascript string object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V8::Number&lt;/code&gt; - a Javascript number object&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V8::Number::New(isolate, 10)&lt;/code&gt; - C++ double to Javascript number object&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Heap allocations&lt;/li&gt;
&lt;li&gt;Calling convention&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And so on.&lt;/p&gt;
&lt;h4 id="an-example"&gt;An example&lt;/h4&gt;&lt;p&gt;This first version of jsc could take the following Javascript:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function fib(n, a, b) {
    if (n == 0) {
        return a;
    }

    if (n == 1) {
        return b;
    }

    return fib(n - 1, b, a + b);
}

function main() {
  console.log(fib(50, 0, 1));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And produce the following C++:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;iostream&amp;gt;

#include &amp;lt;node.h&amp;gt;

using v8::Array;
using v8::Boolean;
using v8::Context;
using v8::Exception;
using v8::Function;
using v8::FunctionTemplate;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Null;
using v8::Number;
using v8::Object;
using v8::String;
using v8::False;
using v8::True;
using v8::Value;

void fib_0(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = args.GetIsolate();
  Local&amp;lt;Value&amp;gt; n_1 = args[0];
  Local&amp;lt;Value&amp;gt; a_2 = args[1];
  Local&amp;lt;Value&amp;gt; b_3 = args[2];
tail_recurse_4:

  Local&amp;lt;Context&amp;gt; ctx_5 = isolate-&amp;gt;GetCurrentContext();
  Local&amp;lt;Object&amp;gt; global_6 = ctx_5-&amp;gt;Global();
  Local&amp;lt;Function&amp;gt; Boolean_7 = Local&amp;lt;Function&amp;gt;::Cast(global_6-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;Boolean&amp;quot;)));
  String::Utf8Value utf8value_tmp_8(n_1);
  std::string string_tmp_9(*utf8value_tmp_8);
  String::Utf8Value utf8value_tmp_10(Number::New(isolate, 0));
  std::string string_tmp_11(*utf8value_tmp_10);
  Local&amp;lt;Value&amp;gt; argv_12[] = { (n_1-&amp;gt;IsBoolean() || Number::New(isolate, 0)-&amp;gt;IsBoolean()) ? Boolean::New(isolate, n_1-&amp;gt;ToBoolean(isolate)-&amp;gt;Value() == Number::New(isolate, 0)-&amp;gt;ToBoolean(isolate)-&amp;gt;Value()) : ((n_1-&amp;gt;IsNumber() || Number::New(isolate, 0)-&amp;gt;IsNumber()) ? Boolean::New(isolate, n_1-&amp;gt;ToNumber(isolate)-&amp;gt;Value() == Number::New(isolate, 0)-&amp;gt;ToNumber(isolate)-&amp;gt;Value()) : ((n_1-&amp;gt;IsString() || Number::New(isolate, 0)-&amp;gt;IsString()) ? Boolean::New(isolate, string_tmp_9 == string_tmp_11) : (False(isolate)))) };
  Local&amp;lt;Value&amp;gt; result_13 = Boolean_7-&amp;gt;Call(Null(isolate), 1, argv_12);
  if (result_13-&amp;gt;ToBoolean()-&amp;gt;Value()) {
    // return a;
    args.GetReturnValue().Set(a_2);
    return;


  }

  Local&amp;lt;Context&amp;gt; ctx_14 = isolate-&amp;gt;GetCurrentContext();
  Local&amp;lt;Object&amp;gt; global_15 = ctx_14-&amp;gt;Global();
  Local&amp;lt;Function&amp;gt; Boolean_16 = Local&amp;lt;Function&amp;gt;::Cast(global_15-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;Boolean&amp;quot;)));
  String::Utf8Value utf8value_tmp_17(n_1);
  std::string string_tmp_18(*utf8value_tmp_17);
  String::Utf8Value utf8value_tmp_19(Number::New(isolate, 1));
  std::string string_tmp_20(*utf8value_tmp_19);
  Local&amp;lt;Value&amp;gt; argv_21[] = { (n_1-&amp;gt;IsBoolean() || Number::New(isolate, 1)-&amp;gt;IsBoolean()) ? Boolean::New(isolate, n_1-&amp;gt;ToBoolean(isolate)-&amp;gt;Value() == Number::New(isolate, 1)-&amp;gt;ToBoolean(isolate)-&amp;gt;Value()) : ((n_1-&amp;gt;IsNumber() || Number::New(isolate, 1)-&amp;gt;IsNumber()) ? Boolean::New(isolate, n_1-&amp;gt;ToNumber(isolate)-&amp;gt;Value() == Number::New(isolate, 1)-&amp;gt;ToNumber(isolate)-&amp;gt;Value()) : ((n_1-&amp;gt;IsString() || Number::New(isolate, 1)-&amp;gt;IsString()) ? Boolean::New(isolate, string_tmp_18 == string_tmp_20) : (False(isolate)))) };
  Local&amp;lt;Value&amp;gt; result_22 = Boolean_16-&amp;gt;Call(Null(isolate), 1, argv_21);
  if (result_22-&amp;gt;ToBoolean()-&amp;gt;Value()) {
    // return b;
    args.GetReturnValue().Set(b_3);
    return;


  }

  // return fib(n - 1, b, a + b);
  Local&amp;lt;Value&amp;gt; arg_23 = (n_1-&amp;gt;IsNumber() || Number::New(isolate, 1)-&amp;gt;IsNumber()) ? (Number::New(isolate, n_1-&amp;gt;ToNumber(isolate)-&amp;gt;Value() - Number::New(isolate, 1)-&amp;gt;ToNumber(isolate)-&amp;gt;Value())) : Local&amp;lt;Number&amp;gt;::Cast(Null(isolate));
  Local&amp;lt;Value&amp;gt; arg_24 = b_3;
  Local&amp;lt;Value&amp;gt; arg_25 = (a_2-&amp;gt;IsString() || b_3-&amp;gt;IsString()) ? Local&amp;lt;Value&amp;gt;::Cast(String::Concat(a_2-&amp;gt;ToString(), b_3-&amp;gt;ToString())) : Local&amp;lt;Value&amp;gt;::Cast((a_2-&amp;gt;IsNumber() || b_3-&amp;gt;IsNumber()) ? (Number::New(isolate, a_2-&amp;gt;ToNumber(isolate)-&amp;gt;Value() + b_3-&amp;gt;ToNumber(isolate)-&amp;gt;Value())) : Local&amp;lt;Number&amp;gt;::Cast(Null(isolate)));
  Local&amp;lt;FunctionTemplate&amp;gt; ftpl_27 = FunctionTemplate::New(isolate, fib_0);
  Local&amp;lt;Function&amp;gt; fn_26 = ftpl_27-&amp;gt;GetFunction();
  fn_26-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;fib_0&amp;quot;));
  n_1 = arg_23;
  a_2 = arg_24;
  b_3 = arg_25;
  goto tail_recurse_4;

}

void jsc_main(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = args.GetIsolate();
tail_recurse_5:

  // console.log(fib(50, 0, 1))
  Local&amp;lt;Value&amp;gt; dot_parent_7 = isolate-&amp;gt;GetCurrentContext()-&amp;gt;Global()-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;console&amp;quot;));
  Local&amp;lt;String&amp;gt; property_8 = String::NewFromUtf8(isolate, &amp;quot;log&amp;quot;);
  while (dot_parent_7-&amp;gt;IsObject() &amp;amp;&amp;amp; !dot_parent_7.As&amp;lt;Object&amp;gt;()-&amp;gt;HasOwnProperty(isolate-&amp;gt;GetCurrentContext(), property_8).ToChecked()) {
    dot_parent_7 = dot_parent_7.As&amp;lt;Object&amp;gt;()-&amp;gt;GetPrototype();
  }
  Local&amp;lt;Value&amp;gt; dot_result_6 = dot_parent_7.As&amp;lt;Object&amp;gt;()-&amp;gt;Get(isolate-&amp;gt;GetCurrentContext(), property_8).ToLocalChecked();
  Local&amp;lt;Value&amp;gt; arg_9 = Number::New(isolate, 50);
  Local&amp;lt;Value&amp;gt; arg_10 = Number::New(isolate, 0);
  Local&amp;lt;Value&amp;gt; arg_11 = Number::New(isolate, 1);
  Local&amp;lt;FunctionTemplate&amp;gt; ftpl_13 = FunctionTemplate::New(isolate, fib_0);
  Local&amp;lt;Function&amp;gt; fn_12 = ftpl_13-&amp;gt;GetFunction();
  fn_12-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;fib_0&amp;quot;));
  Local&amp;lt;Value&amp;gt; argv_14[] = { arg_9, arg_10, arg_11 };
  Local&amp;lt;Value&amp;gt; result_15 = fn_12-&amp;gt;Call(Null(isolate), 3, argv_14);
  Local&amp;lt;Value&amp;gt; arg_16 = result_15;
  Local&amp;lt;Function&amp;gt; fn_17 = Local&amp;lt;Function&amp;gt;::Cast(dot_result_6);
  Local&amp;lt;Value&amp;gt; argv_18[] = { arg_16 };
  Local&amp;lt;Value&amp;gt; result_19 = fn_17-&amp;gt;Call(dot_parent_7, 1, argv_18);
  result_19;

}

void Init(Local&amp;lt;Object&amp;gt; exports) {
  NODE_SET_METHOD(exports, &amp;quot;jsc_main&amp;quot;, jsc_main);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Init)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This output gets compiled (by jsc) as a &lt;a href="https://nodejs.org/api/addons.html"&gt;Node
addon&lt;/a&gt; using
&lt;a href="https://github.com/nodejs/node-gyp"&gt;node-gyp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The compiled addon is loaded by a single-line Javascript file generated by jsc:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ rm -rf build
$ jsc fib.js
$ cat build/fib.js
require(&amp;quot;build/Release/fib.node&amp;quot;).jsc_main()
$ node build/fib.js
12586269025
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="analysis"&gt;Analysis&lt;/h4&gt;&lt;p&gt;The code was a mess of bad formatting, unnecessary locals, inefficient
basic operations (e.g. huge, often unnecessary Boolean conversions),
and so on. The unnecessary locals was partially a by-product of
single-pass code generation. And the unnecessary conversions was
partly due to ignoring types (even types of literals that you don't
need Typescript/Flow to provide).&lt;/p&gt;
&lt;p&gt;After I got this proof-of-concept working for basic examples, I wanted
to rewrite it around &lt;a href="https://github.com/eatonphil/one-pass-code-generation-in-v8/blob/master/One-pass%20Code%20Generation%20in%20V8.pdf"&gt;destination-driven code
generation&lt;/a&gt;,
a technique by Kent Dybvig used in V8's baseline compiler. And after a
few weeks not getting far in a refactor in Rust, I rewrote the
compiler in Typescript.&lt;/p&gt;
&lt;h3 id="the-second-pass"&gt;The second pass&lt;/h3&gt;&lt;p&gt;Written in Typescript and using the &lt;a href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API"&gt;Typescript compiler
API&lt;/a&gt;,
this second iteration was built to do destination-driven code
generation and leaf type propagation. Destination-driven code
generation allows a single-pass code generator to reduce redundant
reassignments. And leaf type propagation allows simple, obvious
optimizations such as just calling &lt;code&gt;V8::Boolean::IsTrue()&lt;/code&gt;
on a statically-known boolean rather than calling
&lt;code&gt;V8::Value::Equals()&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="example"&gt;Example&lt;/h4&gt;&lt;p&gt;Given the same fibonacci Javascript program from before, this
iteration produces the following C++:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;quot;lib.cc&amp;quot;

void tco_fib(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; _args) {
  Isolate* isolate = _args.GetIsolate();
  std::vector&amp;lt;Local&amp;lt;Value&amp;gt;&amp;gt; args(_args.Length());;
  for (int i = 0; i &amp;lt; _args.Length(); i++) args[i] = _args[i];
tail_recurse_0:

  Local&amp;lt;Number&amp;gt; sym_rhs_4 = Number::New(isolate, 0);
  Local&amp;lt;Boolean&amp;gt; sym_anon_2 = args[0]-&amp;gt;StrictEquals(sym_rhs_4) ? True(isolate) : False(isolate);
  if (sym_anon_2-&amp;gt;IsTrue()) {
    _args.GetReturnValue().Set(args[1]);
    return;
  }

  Local&amp;lt;Number&amp;gt; sym_rhs_11 = Number::New(isolate, 1);
  Local&amp;lt;Boolean&amp;gt; sym_anon_9 = args[0]-&amp;gt;StrictEquals(sym_rhs_11) ? True(isolate) : False(isolate);
  if (sym_anon_9-&amp;gt;IsTrue()) {
    _args.GetReturnValue().Set(args[2]);
    return;
  }

  Local&amp;lt;Number&amp;gt; sym_rhs_19 = Number::New(isolate, 1);
  Local&amp;lt;Value&amp;gt; sym_arg_17 = genericMinus(isolate, args[0], sym_rhs_19);
  Local&amp;lt;Value&amp;gt; sym_arg_21 = genericPlus(isolate, args[1], args[2]);
  args[0] = sym_arg_17;
  args[1] = args[2];
  args[2] = sym_arg_21;
  goto tail_recurse_0;

  return;
}

void jsc_main(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; _args) {
  Isolate* isolate = _args.GetIsolate();
  std::vector&amp;lt;Local&amp;lt;Value&amp;gt;&amp;gt; args(_args.Length());;
  for (int i = 0; i &amp;lt; _args.Length(); i++) args[i] = _args[i];
tail_recurse_1:

  Local&amp;lt;Number&amp;gt; sym_arg_29 = Number::New(isolate, 100);
  Local&amp;lt;Number&amp;gt; sym_arg_30 = Number::New(isolate, 0);
  Local&amp;lt;Number&amp;gt; sym_arg_31 = Number::New(isolate, 1);
  Local&amp;lt;Value&amp;gt; sym_args_32[] = { sym_arg_29, sym_arg_30, sym_arg_31 };
  Local&amp;lt;Function&amp;gt; sym_fn_33 = FunctionTemplate::New(isolate, tco_fib)-&amp;gt;GetFunction();
  sym_fn_33-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;tco_fib&amp;quot;));
  Local&amp;lt;Value&amp;gt; sym_arg_28 = sym_fn_33-&amp;gt;Call(sym_fn_33, 3, sym_args_32);

  Local&amp;lt;Value&amp;gt; sym_args_34[] = { sym_arg_28 };
  Local&amp;lt;Value&amp;gt; sym_parent_37 = isolate-&amp;gt;GetCurrentContext()-&amp;gt;Global()-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;console&amp;quot;));
  Local&amp;lt;Value&amp;gt; sym_anon_36 = sym_parent_37.As&amp;lt;Object&amp;gt;()-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;log&amp;quot;));
  Local&amp;lt;Function&amp;gt; sym_fn_35 = Local&amp;lt;Function&amp;gt;::Cast(sym_anon_36);
  Local&amp;lt;Value&amp;gt; sym_anon_27 = sym_fn_35-&amp;gt;Call(sym_fn_35, 1, sym_args_34);

  return;
}

void Init(Local&amp;lt;Object&amp;gt; exports) {
  NODE_SET_METHOD(exports, &amp;quot;jsc_main&amp;quot;, jsc_main);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Init)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="analysis"&gt;Analysis&lt;/h4&gt;&lt;p&gt;Common code (&lt;code&gt;genericPlus&lt;/code&gt;, &lt;code&gt;genericMinus&lt;/code&gt;) and
all imports have been pulled into &lt;code&gt;lib.cc&lt;/code&gt; for clarity. And
the entire result is run through
&lt;a href="https://clang.llvm.org/docs/ClangFormat.html"&gt;clang-format&lt;/a&gt; if it is
present on the system.&lt;/p&gt;
&lt;p&gt;The benefit of leaf type propagation can be seen everywhere a local is
declared that is not &lt;code&gt;Local&lt;Value&gt;&lt;/code&gt; and specifically in if
tests on statically known booleans:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;...
Local&amp;lt;Boolean&amp;gt; sym_anon_2 = args[0]-&amp;gt;StrictEquals(sym_rhs_4) ? True(isolate) : False(isolate);
  if (sym_anon_2-&amp;gt;IsTrue()) {
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's obvious to a human that there is another optimization you could
do here by not wrapping this check in a &lt;code&gt;V8::Boolean&lt;/code&gt; at
all. The only types tracked in destinations are V8 types, not yet C++
types. But not needing to passing this through a &lt;code&gt;bool
toBoolean(Value v)&lt;/code&gt; wrapper is still an improvement.&lt;/p&gt;
&lt;p&gt;In general, unboxing has not really been explore. But the ultimate
goal is to use Typescript types to produce function- or block-level
unboxed versions -- perhaps using a toggle in code to specify safety à
la Common Lisp.&lt;/p&gt;
&lt;h3 id="next-steps"&gt;Next steps&lt;/h3&gt;&lt;p&gt;I broke tests and regressed on syntax support in the Typescript port,
so that's the first step. The second step is enough syntax to support
more interesting benchmarks than the fibonacci example (which has
comparative performance to Node.js/V8 but isn't saying much).&lt;/p&gt;
&lt;p&gt;After that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unboxed expressions&lt;/li&gt;
&lt;li&gt;Unboxed blocks&lt;/li&gt;
&lt;li&gt;Foreign-function interface&lt;/li&gt;
&lt;li&gt;Self-hosting&lt;/li&gt;
&lt;li&gt;Node-API compatible runtime without Node&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Companion blog post to my talk on an AOT-compiled Javascript implementation built on Typescript &lt;a href="https://t.co/0aHVJ9UzYh"&gt;https://t.co/0aHVJ9UzYh&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1100397733867859968?ref_src=twsrc%5Etfw"&gt;February 26, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/aot-compilation-of-javascript-with-v8.html</guid><pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate></item><item><title>Transparency and communication on small teams</title><link>http://notes.eatonphil.com/transparency-and-communication-on-small-teams.html</link><description>&lt;p&gt;I saw a post on
&lt;a href="https://dev.to/vcarl/symptoms-of-a-dysfunctional-team-1c0"&gt;dev.to&lt;/a&gt;
that talks about dysfunctional teams. This is a response that focuses
specifically on how to prevent burnout from overworking. This is aimed
at senior/lead engineers and engineering/project managers -- because
everyone in a leadership role is responsible for the health of the
team and the company.&lt;/p&gt;
&lt;p&gt;In an otherwise good company with hard-working, ethical employees,
overworking happens because of imperfect communication. If neither of
those premises hold, you have more serious issues and have no need for
this post.&lt;/p&gt;
&lt;p&gt;The primary subjects of poor communication are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Capacity/capabilities&lt;/li&gt;
&lt;li&gt;Priorities&lt;/li&gt;
&lt;li&gt;Results&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If any member of the team (or worse, the entire team) is not honestly
reporting on their capacity and capability, this will drive them to
overwork to make up for what they couldn't accomplish on work hours.&lt;/p&gt;
&lt;p&gt;If any member of the team (or worse, the entire team) is not honestly
and publicly reporting on what they understand to be the priorities,
they will end up needing to work overtime if true priorities become
apparent too late.&lt;/p&gt;
&lt;p&gt;And if any member of the team (or worse, the entire team) is not
honestly and publicly reporting on what they &lt;strong&gt;accomplished&lt;/strong&gt;, they
will end up needing to work overtime if discrepancies become apparent
too late.&lt;/p&gt;
&lt;h3 id="solution"&gt;Solution&lt;/h3&gt;&lt;p&gt;Put a sprint process in place and schedule &lt;strong&gt;at least&lt;/strong&gt; one meeting
every sprint. Discover every political, technical, and structural
stakeholder and find a time they can attend this meeting. At this
meeting you will cover at a high level (perhaps with some demos) what
was accomplished in the sprint and what you intend to accomplish in
the next sprint.&lt;/p&gt;
&lt;p&gt;If any stakeholder cannot make this meeting, find a time to sync up
with him/her separately.&lt;/p&gt;
&lt;p&gt;Your sprints should not last more than two weeks because any longer is
too long to go before talking to/reviewing with your stakeholders.&lt;/p&gt;
&lt;p&gt;Finally, publish a report on what you accomplished this sprint (and
also what you did not accomplish!) and what you plan to accomplish the
next sprint. For example, I send an email to the engineering
organization with two docs at the end of each sprint: 1) a review doc
listing tasks accomplished/not accomplished and 2) a list of tasks
planned for the next sprint. This gives your stakeholders (and anyone
else interested) an opportunity to review the contents of the meeting
at their leisure.&lt;/p&gt;
&lt;p&gt;Doing this can be difficult and embarrassing at first. Hard-working,
ethical employees never want to be seen as not accomplishing their
share of work. But the most important thing for the mid-to-long-term
health of these employees is to get them reporting honestly.&lt;/p&gt;
&lt;p&gt;This helps make it clear where these employees can legitimately
improve (i.e. receive more training) and where it's necessary to hire
more or different employees. You'll likely need to put pressure on
every team member to report honestly and to do so without fear.&lt;/p&gt;
&lt;p&gt;And as a result of doing this, you've done everything you can as a
senior/lead member of a small team to push responsibility for your
team's work up to your stakeholders. This is the best position to be
in.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;tldr; don&amp;#39;t let your folks overwork unnecessarily when you could be reporting more frequently/honestly on understood priorities and accomplishments achieved/not achieved &lt;a href="https://t.co/PeTe2Bq0Xz"&gt;https://t.co/PeTe2Bq0Xz&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1087722536236957697?ref_src=twsrc%5Etfw"&gt;January 22, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/transparency-and-communication-on-small-teams.html</guid><pubDate>Tue, 22 Jan 2019 00:00:00 +0000</pubDate></item><item><title>Windows</title><link>http://notes.eatonphil.com/windows.html</link><description>&lt;p&gt;It has been six years since I last used Windows for any remotely
serious software development. I've used Ubuntu, Arch, or FreeBSD
since. But eventually I spent so much time working around common
workplace tasks that I decided to put Windows 10 Pro on my work
laptop.&lt;/p&gt;
&lt;h3 id="windows-subsystem-for-linux"&gt;Windows Subsystem for Linux&lt;/h3&gt;&lt;p&gt;Introduced in 2016, this technology allows Windows to run unmodified
Linux binaries. The core feat being &lt;a href="https://blogs.msdn.microsoft.com/wsl/2016/06/08/wsl-system-calls/"&gt;syscall
translation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It works nearly flawlessly. This means I can do all my Go, Node,
PostgreSQL development on Windows without a virtual machine using
bash, tmux, git, emacs, etc.&lt;/p&gt;
&lt;p&gt;I've seen a few minor exceptions over the course of regular software
development in WSL:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Microsoft/WSL/issues/2249"&gt;ss/netstat does not work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/hashicorp/vagrant/issues/8700"&gt;vagrant does not work&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;More generally, Linux programs are heavily file-oriented. And Windows
I/O &lt;a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829"&gt;is not designed well for
that&lt;/a&gt;.
In the worst cases (installing/adding Node packages) it can take
minutes to do operations that would take Linux seconds.&lt;/p&gt;
&lt;h3 id="vagrant"&gt;Vagrant&lt;/h3&gt;&lt;p&gt;Vagrant-Windows interoperability is abysmal.&lt;/p&gt;
&lt;p&gt;As noted above, you cannot manage Hyper-V from vagrant within WSL. So
you're stuck using Powershell. Even then, managing synced files from
vagrant is a nightmare. The default sync method requires you to sign
in using your &lt;strong&gt;Windows Live&lt;/strong&gt; username and password on every
reboot. But Node package installation attempts some file operations
that are not supported over the default synced, network filesystem.&lt;/p&gt;
&lt;p&gt;When I switched to rsync vagrant wouldn't reliable sync when the
virtual machine went down and came back up.&lt;/p&gt;
&lt;p&gt;After hours of trying to get some files synced with vagrant I gave up.&lt;/p&gt;
&lt;h3 id="hyper-v"&gt;Hyper-V&lt;/h3&gt;&lt;p&gt;Hyper-V's GUI is much more complex/feature-complete than VirtualBox.
It even provides a Ubuntu-quick-install that I used to jump right in.
I don't recommend using this though because it gives you no option but
an 11GB hard disk. I didn't realize this until I went through an hour
or two of post-install customization only to run out of space. Too
lazy to boot into a live CD to grow the root filesystem I reinstalled
with a more suitable 64GB drive and went through the hour-long
post-install customization process again.&lt;/p&gt;
&lt;p&gt;Networking in Hyper-V is more complex/feature-complete than VirtualBox
as well. To access a Hyper-V machine you must create a new virtual
network interface manually and associate it. Static IP address appear
to be controlled at the host networking level (e.g. Control Panel)
instead of within the Hyper-V interface. This highlights how these
virtual interfaces are first-class, but overcomplicates the process of
getting started.&lt;/p&gt;
&lt;p&gt;Ultimately I gave up on a static IP address and decided to reboot less
frequently.&lt;/p&gt;
&lt;p&gt;Performance-wise Hyper-V machines are exactly as expected: excellent.&lt;/p&gt;
&lt;h3 id="misc"&gt;Misc&lt;/h3&gt;&lt;p&gt;Docker support on Windows needs work. It took me a while to understand
how Docker interacts with the WSL filesystem and what I needed to do
to allow Docker to mount. The complexity is similar on macOS when you
want to mount privileged directories like /var, but the experience is
worse on Windows.&lt;/p&gt;
&lt;p&gt;Apparently Windows does have tiling window managers, but I have not
tried one out yet.&lt;/p&gt;
&lt;p&gt;Powershell, a language with real types, is pretty compelling. But I
have not spent enough time with it to be efficient. And since WSL is
mostly good enough I don't really plan to.&lt;/p&gt;
&lt;p&gt;Windows doesn't allow you to delete any files that are "in use". This
is kinda cool except for that the errors you get when trying to delete
files that are in use are useless. They are even more useless when you
get the plain "could not delete directory" when you try to delete a
directory with some file inside it that is in use. I had to start
deleting files within by hand until I found the one I realized was in
use.&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;&lt;p&gt;If you have never run Linux or FreeBSD, don't use this post as an
excuse not to. You should run Linux or FreeBSD for the experience. But
if you've reached diminishing returns in your Linux/FreeBSD use,
Windows as a development environment has come a long way. It may be
the best platform available for software development, the profession.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Some notes on my experience having replaced Arch Linux with Windows on my work laptop &lt;a href="https://t.co/8asxZmspwR"&gt;https://t.co/8asxZmspwR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1086994000182153222?ref_src=twsrc%5Etfw"&gt;January 20, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/windows.html</guid><pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 2. user-defined functions and variables</title><link>http://notes.eatonphil.com/compiler-basics-functions.html</link><description>&lt;p class="note"&gt;
  Previously in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-lisp-to-assembly.html"&gt;1. lisp to assembly&lt;/a&gt;
  &lt;br/&gt;
  &lt;br/&gt;
  Next in compiler basics:
  &lt;br/&gt;
  &lt;a href="/compiler-basics-llvm.html"&gt;3. LLVM&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-conditionals.html"&gt;4. LLVM conditionals and compiling fibonacci&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-system-calls.html"&gt;5. LLVM system calls&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-an-x86-upgrade.html"&gt;6. an x86 upgrade&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll extend the compiler to support defining functions
and variables. Additionally, we'll require the program's entrypoint to
be within a &lt;code&gt;main&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The resulting code can be found
&lt;a href="https://github.com/eatonphil/ulisp"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="function-definition"&gt;Function definition&lt;/h3&gt;&lt;p&gt;The simplest function definition we need to support is for our &lt;code&gt;main&lt;/code&gt;
function. This will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;$ cat basic.lisp
(def main ()
     (+ 1 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where compiling and running it should produce a return code of 3:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node ulisp.js basic.lisp
$ ./build/a.out
$ echo $?
3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="parsing-function-definitions"&gt;Parsing function definitions&lt;/h3&gt;&lt;p&gt;The entire language is defined in S-expressions and we already parse
S-expressions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;$ node
&amp;gt; const { parse } = require(&amp;#39;./parser&amp;#39;);
&amp;gt; JSON.stringify(parse(&amp;#39;(def main () (+ 1 2))&amp;#39;));
&amp;#39;[[[&amp;quot;def&amp;quot;,&amp;quot;main&amp;quot;,[],[&amp;quot;+&amp;quot;,1,2]]],&amp;quot;&amp;quot;]&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we're done!&lt;/p&gt;
&lt;h3 id="code-generation"&gt;Code generation&lt;/h3&gt;&lt;p&gt;There are two tricky parts to code generation once function
definitions are introduced:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Functions definitions are not expressions (in assembly)&lt;/li&gt;
&lt;li&gt;Function calling conventions for the &lt;strong&gt;callee&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Variable scope&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="function-definitions"&gt;Function definitions&lt;/h4&gt;&lt;p&gt;A function definition looks like a function call. So we'll need to
keep a list of "primitive" functions that handle what looks like
function calls differently.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_define() {
  // TODO
}

const primitive_functions = {
  def: compile_define,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then in our &lt;code&gt;compile_call&lt;/code&gt; function we need to see if the function
being "called" is in this list. If so, we allow the associated
callback to handle compilation.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_call(fun, args, destination) {
  if (primitive_functions[fun]) {
    primitive_functions[fun](args, destination);
    return;
  }

  // Save param registers
  args.map((_, i) =&amp;gt; emit(1, `PUSH ${PARAM_REGISTERS[i]}`));

  // Compile registers and store as params
  args.map((arg, i) =&amp;gt; compile_expression(arg, PARAM_REGISTERS[i], scope));

  emit(1, `CALL ${BUILTIN_FUNCTIONS[fun] || scope[fun]}`);

  // Restore param registers
  args.map((_, i) =&amp;gt; emit(1, `POP ${PARAM_REGISTERS[args.length - i - 1]}`));

  if (destination &amp;amp;&amp;amp; destination !== &amp;#39;RAX&amp;#39;) {
    emit(1, `MOV ${destination}, RAX`);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can begin thinking about &lt;code&gt;compile_define&lt;/code&gt;. It takes &lt;code&gt;args&lt;/code&gt;
which will be a list of three elements containing the function's:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;parameters&lt;/li&gt;
&lt;li&gt;and body&lt;/li&gt;
&lt;/ul&gt;
&lt;p class="note"&gt;
  It does not use destination because we're treating function
  definitions as statements for now and not as expressions. If we were
  treating it as an expression, we might store the address of the
  function in the destination register.

  We keep destination around to keep the primitive function signatures
  consistent.
&lt;/p&gt;&lt;p&gt;Based on how we called functions before and how we defined the
hard-coded &lt;code&gt;add&lt;/code&gt; function, we know what a function definition in
assembly generally looks like. And we know the arguments to the
function when called will be in RDI, RSI, and RDX.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_define([name, parameters, body]) {
  // Function name becomes a label we can CALL
  emit(0, `${name}:`);

  // Something to do with RDI, RSI, RDX and the parameters variable?

  // We renamed compile_argument to compile_expression to be more general
  compile_expression(body[0], &amp;#39;RAX&amp;#39;);

  // Maybe some cleanup to do with RDI, RSI, RDX?

  emit(1, &amp;#39;RET\n&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not a bad first sketch. But how do we match up &lt;code&gt;RDI&lt;/code&gt;, &lt;code&gt;RSI&lt;/code&gt;, &lt;code&gt;RDX&lt;/code&gt; and
the user-defined &lt;code&gt;parameters&lt;/code&gt; variable names? For example in the
following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def plus-two (a)
     (+ a 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's clear to us that &lt;code&gt;a&lt;/code&gt; must match up to &lt;code&gt;RDI&lt;/code&gt;. In order to do this
we need to track all variables in a &lt;code&gt;scope&lt;/code&gt; dictionary mapping the
variable name to the register where it's stored.&lt;/p&gt;
&lt;p&gt;Additionally, keeping track of scope can help us fail quickly in the
following scenario:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def plus-two (a)
     (+ b 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The variable &lt;code&gt;b&lt;/code&gt; is used but never defined. It has not been added to
the scope dictionary. So our compiler can fail quickly saying there is
an undefined variable being referenced.&lt;/p&gt;
&lt;p&gt;Taking this a step further, what if we want to catch the following
too:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(def plus-two (a)
     (plus a 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We're trying to call &lt;code&gt;plus&lt;/code&gt; but it has not been defined. We should be
able to fail quickly here too. But that means we're need to track the
scope of function &lt;strong&gt;names&lt;/strong&gt; in addition to variables. We'll choose to
track function names and variable names in the same scope dictionary.&lt;/p&gt;
&lt;p class="note"&gt;
  This is the distinction between a lisp-1 and a lisp-2. We are a
  lisp-1 like Scheme because we have a single scope. Common Lisp is a
  lisp-2 because it stores function name scope separately from
  variable name scope.
&lt;/p&gt;&lt;h3 id="implementing-scope"&gt;Implementing scope&lt;/h3&gt;&lt;p&gt;We need to revise every compile function to accept a scope dictionary
(specifically: &lt;code&gt;compile&lt;/code&gt;, &lt;code&gt;compile_expression&lt;/code&gt;, &lt;code&gt;compile_call&lt;/code&gt;, and
&lt;code&gt;compile_define&lt;/code&gt;). If a variable is referenced, we need to look up
it's location in the scope dictionary. If a variable is defined
(e.g. a function name or a function parameter) we need to add a
mapping to the scope dictionary.&lt;/p&gt;
&lt;p&gt;Modifying &lt;code&gt;compile_expression&lt;/code&gt; is easiest:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_expression(arg, destination, scope) {
  // Is a nested function call, compile it
  if (Array.isArray(arg)) {
    compile_call(arg[0], arg.slice(1), destination, scope);
    return;
  }

  if (scope[arg] || Number.isInteger(arg)) {
    emit(1, `MOV ${destination}, ${scope[arg] || arg}`);
  } else {
    throw new Error(&amp;#39;Attempt to reference undefined variable or unsupported literal: &amp;#39; + arg);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we modify &lt;code&gt;compile_call&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_call(fun, args, destination, scope) {
  if (primitive_functions[fun]) {
    primitive_functions[fun](args, destination, scope);
    return;
  }

  // Save param registers
  args.map((_, i) =&amp;gt; emit(1, `PUSH ${PARAM_REGISTERS[i]}`));

  // Compile registers and store as params
  args.map((arg, i) =&amp;gt; compile_expression(arg, PARAM_REGISTERS[i], scope));

  const validFunction = BUILTIN_FUNCTIONS[fun] || scope[fun];
  if (validFunction) {
    emit(1, `CALL ${validFunction}`);
  } else {
    throw new Error(&amp;#39;Attempt to call undefined function: &amp;#39; + fun);
  }

  // Restore param registers
  args.map((_, i) =&amp;gt; emit(1, `POP ${PARAM_REGISTERS[args.length - i - 1]}`));

  if (destination &amp;amp;&amp;amp; destination !== &amp;#39;RAX&amp;#39;) {
    emit(1, `MOV ${destination}, RAX`);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then &lt;code&gt;compile_define&lt;/code&gt; where we modify scope for the first time:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_define([name, params, ...body], destination, scope) {
  // Add this function to outer scope
  scope[name] = name.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);

  // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
  const childScope = { ...scope };

  emit(0, `${scope[name]}:`);

  params.forEach(function (param, i) {
    const register = PARAM_REGISTERS[i];
    // Store parameter mapped to associated register
    childScope[param] = register;
  });

  // Pass childScope in for reference when body is compiled.
  compile_expression(body[0], &amp;#39;RAX&amp;#39;, childScope);

  emit(1, &amp;#39;RET\n&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally we need to modify the entrypoint &lt;code&gt;compile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.compile = function (ast) {
  emit_prefix();
  // Pass in new, empty scope mapping
  compile_call(ast[0], ast.slice(1), &amp;#39;RAX&amp;#39;, {});
  emit_postfix();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And scope-wise we're pretty good!&lt;/p&gt;
&lt;h3 id="function-calling-convention:-callee"&gt;Function calling convention: callee&lt;/h3&gt;&lt;p&gt;We currently have a problem that we're using parameters registers to
store local variables that messes up with how we are storing
parameters for function calls within the function itself.&lt;/p&gt;
&lt;p&gt;Ideally we could store function local variables (including the
parameters when we get them) separately from how we store function
call parameters within the function.&lt;/p&gt;
&lt;p&gt;Thankfully according to the calling convention we've followed, we're
given a set of registers that are callee-preserved. Of them we'll use
&lt;code&gt;RBX&lt;/code&gt;, &lt;code&gt;RBP&lt;/code&gt;, and &lt;code&gt;R12&lt;/code&gt; in that order. This allows us to mess with so
long as we store them and restore them within the function.&lt;/p&gt;
&lt;p&gt;Applying the same storing/restoring strategy to local variables as we
did for parameters, we get:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const LOCAL_REGISTERS = [
  &amp;#39;RBX&amp;#39;,
  &amp;#39;RBP&amp;#39;,
  &amp;#39;R12&amp;#39;,
];

function compile_define([name, params, ...body], destination, scope) {
  // Add this function to outer scope
  scope[name] = name.replace(&amp;#39;-&amp;#39;, &amp;#39;_&amp;#39;);

  // Copy outer scope so parameter mappings aren&amp;#39;t exposed in outer scope.
  const childScope = { ...scope };

  emit(0, `${scope[name]}:`);

  params.forEach(function (param, i) {
    const register = PARAM_REGISTERS[i];
    const local = LOCAL_REGISTERS[i];
    emit(1, `PUSH ${local}`);
    emit(1, `MOV ${local}, ${register}`);
    // Store parameter mapped to associated local
    childScope[param] = local;
  });

  // Pass childScope in for reference when body is compiled.
  compile_expression(body[0], &amp;#39;RAX&amp;#39;, childScope);

  params.forEach(function (param, i) {
    // Backwards first
    const local = LOCAL_REGISTERS[params.length - i - 1];
    emit(1, `POP ${local}`);
  });

  emit(1, &amp;#39;RET\n&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're set.&lt;/p&gt;
&lt;h3 id="cleanup"&gt;Cleanup&lt;/h3&gt;&lt;p&gt;We've still got a few messes going on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;emit_prefix wraps out entire body in &lt;code&gt;_main&lt;/code&gt;, we're requiring our own &lt;code&gt;main&lt;/code&gt; now&lt;/li&gt;
&lt;li&gt;emitting to stdout instead of to a file&lt;/li&gt;
&lt;li&gt;multiple function definitions is treated as nonsense&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Starting first, we rewrite &lt;code&gt;emit_prefix&lt;/code&gt; and &lt;code&gt;emit_postfix&lt;/code&gt; so that
our &lt;code&gt;_main&lt;/code&gt; just calls &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function emit_prefix() {
  emit(1, &amp;#39;.global _main\n&amp;#39;);

  emit(1, &amp;#39;.text\n&amp;#39;);

  emit(0, &amp;#39;plus:&amp;#39;);
  emit(1, &amp;#39;ADD RDI, RSI&amp;#39;);
  emit(1, &amp;#39;MOV RAX, RDI&amp;#39;);
  emit(1, &amp;#39;RET\n&amp;#39;);
}

function emit_postfix() {
  emit(0, &amp;#39;_main:&amp;#39;);
  emit(1, &amp;#39;CALL main&amp;#39;);
  emit(1, &amp;#39;MOV RDI, RAX&amp;#39;); // Set exit arg
  emit(1, `MOV RAX, ${SYSCALL_MAP[&amp;#39;exit&amp;#39;]}`);
  emit(1, &amp;#39;SYSCALL&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next to deal with writing to a file instead of stdout, we need our
&lt;code&gt;emit&lt;/code&gt; function to write to a buffer. We'll let &lt;code&gt;ulisp.js&lt;/code&gt; write that
buffer to a file. Because we're incredibly lazy, we'll do this all
globally.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;let OUT = &amp;#39;&amp;#39;;

function emit(depth, args) {
  const indent = new Array(depth + 1).join(&amp;#39;  &amp;#39;);
  OUT += `${indent}${args}\n`;
}

...

module.exports.compile = function (ast) {
  OUT = &amp;#39;&amp;#39;;

  emit_prefix();
  compile_call(ast[0], ast.slice(1), &amp;#39;RAX&amp;#39;, {});
  emit_postfix();

  return OUT;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And modify &lt;code&gt;ulisp.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const cp = require(&amp;#39;child_process&amp;#39;);
const fs = require(&amp;#39;fs&amp;#39;);

const { parse } = require(&amp;#39;./parser&amp;#39;);
const { compile } = require(&amp;#39;./compiler&amp;#39;);

function main (args) {
  const input = fs.readFileSync(args[2]).toString();
  const [ast] = parse(input);
  const program = compile(ast);

  try {
    fs.mkdirSync(&amp;#39;build&amp;#39;);
  } catch (e) {}
  fs.writeFileSync(&amp;#39;build/prog.s&amp;#39;, program);
  cp.execSync(&amp;#39;gcc -mstackrealign -masm=intel -o build/a.out build/prog.s&amp;#39;);
}

main(process.argv);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're finally ready to run a simple program.&lt;/p&gt;
&lt;h3 id="a-program!"&gt;A program!&lt;/h3&gt;&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.lisp
(def main () (+ 1 2))
$ node ulisp.js test.lisp
$ ./build/a.out
$ echo $?
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hurray! Now let's try defining and calling a second function
to validate parameter behavior.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.lisp
(def plus-two (a)
     (+ a 2))

(def main ()
     (plus-two 3))
$ node ulisp.js test.lisp
$ ./build/a.out
./compiler.js:106
    throw new Error(&amp;#39;Attempt to call undefined function: &amp;#39; + fun);
    ^

Error: Attempt to call undefined function: p2

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We start getting some really weird errors. And the reason is because
our compiler doesn't know how to deal with sibling S-expressions.&lt;/p&gt;
&lt;p&gt;So we'll introduce a new primitive function called &lt;code&gt;begin&lt;/code&gt; that calls
all it's sibling functions and returns the value of the last
call. Then we'll wrap the program in an implicit &lt;code&gt;begin&lt;/code&gt; so we don't
need to.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_begin(body, destination, scope) {
  body.forEach((expression) =&amp;gt; compile_expression(expression, &amp;#39;RAX&amp;#39;, scope));
  if (destination &amp;amp;&amp;amp; destination !== &amp;#39;RAX&amp;#39;) {
    emit(1, `MOV ${destination}, RAX`);
  }
}

const primitive_functions = {
  def: compile_define,
  begin: compile_begin,
};

...

module.exports.compile = function (ast) {
  OUT = &amp;#39;&amp;#39;;

  emit_prefix();
  compile_call(&amp;#39;begin&amp;#39;, ast, &amp;#39;RAX&amp;#39;, {});
  emit_postfix();

  return OUT;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we try our test program again. :)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ cat test.lisp
(def plus-two (a)
     (+ a 2))

(def main ()
     (plus-two 3))
$ node ulisp.js test.lisp
$ ./build/a.out
$ echo $?
5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's all there is to it! Stay tuned for the next post on
conditionals and tail-call optimization.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Part two on compiler basics using JavaScript: user-defined functions and variables &lt;a href="https://t.co/XOam67HO8h"&gt;https://t.co/XOam67HO8h&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1087103061590446083?ref_src=twsrc%5Etfw"&gt;January 20, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-functions.html</guid><pubDate>Sun, 20 Jan 2019 00:00:00 +0000</pubDate></item><item><title>Make small changes and solve the problems you have</title><link>http://notes.eatonphil.com/make-small-changes-and-solve-the-problems-you-have.html</link><description>&lt;p&gt;Two frustrating things that can happen in an organization are 1) big
changes and 2) changes that aren’t clearly associated with a known
problem. It’s even worse in that order.&lt;/p&gt;
&lt;p&gt;These situations tend to happen when a problem remain unaddressed for
too long. These situations tend to happen when there is not a strong
enough emphasis on respect for all employees -- their experience,
ideas, and feelings.&lt;/p&gt;
&lt;p&gt;I try to avoid these issues in teams I run by starting early with a
problem statement. Specifically when there’s a problem I’d like to
solve, I’ll mention it in our fortnightly team retro. If there’s
general agreement a problem exists, we begin looking for the least
invasive/least effort way to fix the problem. More on that later.&lt;/p&gt;
&lt;p&gt;If the problem is not well understand or widely-enough shared, I’ll
table the discussion until I can talk with more people to better
articulate the problem. Or maybe there isn’t a problem after all.&lt;/p&gt;
&lt;p&gt;This process of clarifying and agreeing a problem exists is the only
appropriate first step when making a change. It is important to
provide sufficient context to affected employees.&lt;/p&gt;
&lt;p&gt;After the problem is understood I begin to suggest possible solutions
-- soliciting feedback and alternatives. But making sure a problem is
well understand is not the same thing as making sure that potential
solutions could reasonably solve the problem. Throughout the
discussion of solutions I try to repeatedly make sure that proposed
solutions could actually address the problem.&lt;/p&gt;
&lt;p&gt;From there I try to steer discussion of solutions to ones that are
easiest to make and least invasive. Small changes are easier to
make. There is little room for disagreement when there is little
changing.&lt;/p&gt;
&lt;p&gt;Making small changes among a small group of people is even easier. The
few disagreements that you find when making small changes among a
small group of people give you a chance to prove or improve the
solution before introducing it to a larger group.&lt;/p&gt;
&lt;p&gt;Communicating frequently and effectively should be a clear theme here.&lt;/p&gt;
&lt;p&gt;At this point if there is a single most reasonable solution, I’ll pick
it unless there is serious disagreement. Most of the time folks are
amenable to the need for a solution to be chosen to solve a problem
they agreed existed, even if they don’t love the solution.&lt;/p&gt;
&lt;p&gt;If there is no clear solution or there is serious disagreement, go
back a few paragraphs and start over to understand the problem and
solicit feedback and alternative for solutions. Or take the heat of
serious disagreement.&lt;/p&gt;
&lt;p&gt;This is a philosophy. It’s difficult to prove the effectiveness one
way or the other -- especially over the mid-to-long-term. But the
logic makes sense to me, it agrees with what I’ve read on management,
and has worked effectively in teams I’ve run so far.&lt;/p&gt;
&lt;p&gt;Further reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://amzn.to/2GHlro5"&gt;Peopleware: Productive Projects and Teams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/2BGEysM"&gt;Managing Transitions: Making the Most of Change&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/2LA34Ar"&gt;Thinking, Fast and Slow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://amzn.to/2LDfQOz"&gt;Site Reliability Engineering: How Google Runs Production Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Wrote a post expanding on a side of this: make small changes and solve the problems you have &lt;a href="https://t.co/FXepELSHMx"&gt;https://t.co/FXepELSHMx&lt;/a&gt; &lt;a href="https://t.co/mVsT1KFhKc"&gt;https://t.co/mVsT1KFhKc&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1078312937348059136?ref_src=twsrc%5Etfw"&gt;December 27, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/make-small-changes-and-solve-the-problems-you-have.html</guid><pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate></item><item><title>Writing a lisp compiler from scratch in JavaScript: 1. lisp to assembly</title><link>http://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html</link><description>&lt;p class="note"&gt;
  Next in compiler basics:
  &lt;! forgive me, for I have sinned &gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-functions.html"&gt;2. user-defined functions and variables&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm.html"&gt;3. LLVM&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-conditionals.html"&gt;4. LLVM conditionals and compiling fibonacci&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-llvm-system-calls.html"&gt;5. LLVM system calls&lt;/a&gt;
  &lt;br /&gt;
  &lt;a href="/compiler-basics-an-x86-upgrade.html"&gt;6. an x86 upgrade&lt;/a&gt;
&lt;/p&gt;&lt;p&gt;In this post we'll write a simple compiler in Javascript (on Node)
without any third-party libraries. Our goal is to take an input
program like &lt;code&gt;(+ 1 (+ 2 3))&lt;/code&gt; and produce an output assembly program
that does these operations to produce &lt;code&gt;6&lt;/code&gt; as the exit code. The
resulting compiler can be found
&lt;a href="https://github.com/eatonphil/ulisp"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We'll cover:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parsing&lt;/li&gt;
&lt;li&gt;Code generation&lt;/li&gt;
&lt;li&gt;Assembly basics&lt;/li&gt;
&lt;li&gt;Syscalls&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And for now we'll omit:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Programmable function definitions&lt;/li&gt;
&lt;li&gt;Non-symbol/-numeric data types&lt;/li&gt;
&lt;li&gt;More than 3 function arguments&lt;/li&gt;
&lt;li&gt;Lots of safety&lt;/li&gt;
&lt;li&gt;Lots of error messsages&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="parsing"&gt;Parsing&lt;/h3&gt;&lt;p&gt;We pick the &lt;a href="https://en.wikipedia.org/wiki/S-expression"&gt;S-expression&lt;/a&gt;
syntax mentioned earlier because it's very easy to parse. Furthermore,
our input language is so limited that we won't even break our parser
into separate lexing/parsing stages.&lt;/p&gt;
&lt;p class="note"&gt;
  Once you need to support string literals, comments, decimal
  literals, and other more complex literals it becomes easier to use
  separate stages.

  &lt;br /&gt;
  &lt;br /&gt;

  If you're curious about these separate stages of parsing, you may be
  interested in my post
  on &lt;a href="http://notes.eatonphil.com/writing-a-simple-json-parser.html"&gt;writing
  a JSON parser&lt;/a&gt;.

  &lt;br /&gt;
  &lt;br /&gt;

  Or, check out my BSDScheme project for a fully-featured
  &lt;a href="https://github.com/eatonphil/bsdscheme/blob/master/src/lex.d"&gt;lexer&lt;/a&gt;
  and
  &lt;a href="https://github.com/eatonphil/bsdscheme/blob/master/src/parse.d"&gt;parser&lt;/a&gt;
  for Scheme.
&lt;/p&gt;&lt;p&gt;The parser should produce an Abstract Syntax Tree (AST), a data
structure representing the input program. Specifically, we want &lt;code&gt;(+ 1 (+ 2 3))&lt;/code&gt;
to produce &lt;code&gt;['+', 1, ['+', 2, 3]]&lt;/code&gt; in Javascript.&lt;/p&gt;
&lt;p&gt;There are many different ways to go about parsing but the most
intuitive to me is to have a function that accepts a program (a
string) and returns a tuple containing the program parsed so far (an
AST) and the rest of the program (a string) that hasn't been
parsed.&lt;/p&gt;
&lt;p&gt;That leaves us with a function skeleton that looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.parse = function parse(program) {
  const tokens = [];

  ... logic to be added ...

  return [tokens, &amp;#39;&amp;#39;];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code that initially calls parse will thus have to deal with
unwrapping the outermost tuple to get to the AST. For a more helpful
compiler we could check that the entire program &lt;em&gt;was&lt;/em&gt; actually parsed
by failing if the second element of the return result is not the empty
string.&lt;/p&gt;
&lt;p&gt;Within the function we will iterate over each character and accumulate
until we hit space, left or right parenthesis:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.parse = function parse(program) {
  const tokens = [];
  let currentToken = &amp;#39;&amp;#39;;

  for (let i = 0; i &amp;lt; program.length; i++) {
    const char = program.charAt(i);

    switch (char) {
      case &amp;#39;(&amp;#39;: // TODO
        break;
      case &amp;#39;)&amp;#39;: // TODO
        break;
      case &amp;#39; &amp;#39;:
        tokens.push(+currentToken || currentToken);
        currentToken = &amp;#39;&amp;#39;;
        break;
      default:
        currentToken += char;
        break;
    }
  }

  return [tokens, &amp;#39;&amp;#39;];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The recursive parts are always the most challenging. The right paren
is easiest. We must push the current token and return all tokens with
the rest of the program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.parse = function parse(program) {
  const tokens = [];
  let currentToken = &amp;#39;&amp;#39;;

  for (let i = 0; i &amp;lt; program.length; i++) {
    const char = program.charAt(i);

    switch (char) {
      case &amp;#39;(&amp;#39;: // TODO
        break;
      case &amp;#39;)&amp;#39;:
        tokens.push(+currentToken || currentToken);
        return [tokens, program.substring(i + 1)];
      case &amp;#39; &amp;#39;:
        tokens.push(+currentToken || currentToken);
        currentToken = &amp;#39;&amp;#39;;
        break;
      default:
        currentToken += char;
        break;
    }
  }

  return [tokens, &amp;#39;&amp;#39;];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally the left paren should recurse, add the parsed tokens to the
list of sibling tokens, and force the loop to start at the new
unparsed point.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;module.exports.parse = function parse(program) {
  const tokens = [];
  let currentToken = &amp;#39;&amp;#39;;

  for (let i = 0; i &amp;lt; program.length; i++) {
    const char = program.charAt(i);

    switch (char) {
      case &amp;#39;(&amp;#39;: {
        const [parsed, rest] = parse(program.substring(i + 1));
        tokens.push(parsed);
        program = rest;
        i = 0;
        break;
      }
      case &amp;#39;)&amp;#39;:
        tokens.push(+currentToken || currentToken);
        return [tokens, program.substring(i + 1)];
      case &amp;#39; &amp;#39;:
        tokens.push(+currentToken || currentToken);
        currentToken = &amp;#39;&amp;#39;;
        break;
      default:
        currentToken += char;
        break;
    }
  }

  return [tokens, &amp;#39;&amp;#39;];
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming this is all in &lt;code&gt;parser.js&lt;/code&gt;, let's try it out in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node
&amp;gt; const { parse } = require(&amp;#39;./parser&amp;#39;);
undefined
&amp;gt; console.log(JSON.stringify(parse(&amp;#39;(+ 3 (+ 1 2)&amp;#39;)));
[[[&amp;quot;+&amp;quot;,3,[&amp;quot;+&amp;quot;,1,2]]],&amp;quot;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Solid. We move on.&lt;/p&gt;
&lt;h3 id="assembly-101"&gt;Assembly 101&lt;/h3&gt;&lt;p&gt;Assembly is essentially the lowest-level programming language we can
use. It is a human readable, 1:1 representation of the binary
instructions the CPU can interpret. Conversion from assembly to
binary is done with an assembler; the reverse step is done with a
disassembler. We'll use &lt;code&gt;gcc&lt;/code&gt; for assembling since it deals with some
&lt;a href="http://fabiensanglard.net/macosxassembly/index.php"&gt;oddities&lt;/a&gt; of
assembly programming on macOS.&lt;/p&gt;
&lt;p&gt;The primary data structures in assembly are registers (temporary
variables stored by the CPU) and the program stack. Every function in
a program has access to the same registers, but convention cordons
off sections of the stack for each function so it ends up being a
slightly more durable store than registers. &lt;code&gt;RAX&lt;/code&gt;, &lt;code&gt;RDI&lt;/code&gt;, &lt;code&gt;RDX&lt;/code&gt;, and
&lt;code&gt;RSI&lt;/code&gt; are a few registers available to us.&lt;/p&gt;
&lt;p&gt;Now we only need to know a few instructions to compile our program
(the rest of programming assembly is convention):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MOV&lt;/code&gt;: store one register's content into another, or store a literal number into a register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ADD&lt;/code&gt;: store the sum of two register's contents in the first register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUSH&lt;/code&gt;: store a register's content on the stack&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POP&lt;/code&gt;: remove the top-most value from the stack and store in a register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CALL&lt;/code&gt;: enter a new section of the stack and start running the function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RET&lt;/code&gt;: enter the calling functions stack and return to evaluating from the next instruction after the call&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SYSCALL&lt;/code&gt;: like &lt;code&gt;CALL&lt;/code&gt; but where the function is handled by the kernel&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="function-calling-convention"&gt;Function calling convention&lt;/h3&gt;&lt;p&gt;Assembly instructions are flexible enough that there is no
language-defined way to make function calls. Therefore it is important
to answer (at least) the following few questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Where are parameters stored by the caller so that the callee has access to them?&lt;/li&gt;
&lt;li&gt;Where is the return value stored by the callee so the caller has access to it?&lt;/li&gt;
&lt;li&gt;What registers are saved by whom?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Without getting too far into the specifics, we'll assume the following
answers for development on x86_64 macOS and Linux systems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Parameters are stored (in order) in the &lt;code&gt;RDI&lt;/code&gt;, &lt;code&gt;RSI&lt;/code&gt;, and &lt;code&gt;RDX&lt;/code&gt; registers&lt;ul&gt;
&lt;li&gt;We won't support passing more than three arguments&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The return value is stored in the &lt;code&gt;RAX&lt;/code&gt; register&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RDI&lt;/code&gt;, &lt;code&gt;RSI&lt;/code&gt;, and &lt;code&gt;RDX&lt;/code&gt; registers are stored by the caller&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="code-generation"&gt;Code generation&lt;/h3&gt;&lt;p&gt;With assembly basics and the function call convention in mind, we've
got enough to generate code from the parsed program's AST.&lt;/p&gt;
&lt;p&gt;The skeleton of our compile code will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function emit(depth, code) {
  const indent = new Array(depth + 1).map(() =&amp;gt; &amp;#39;&amp;#39;).join(&amp;#39;  &amp;#39;);
  console.log(indent + code);
}

function compile_argument(arg, destination) {
  // If arg AST is a list, call compile_call on it

  // Else must be a literal number, store in destination register
}

function compile_call(fun, args, destination) {
  // Save param registers to the stack

  // Compile arguments and store in param registers

  // Call function

  // Restore param registers from the stack

  // Move result into destination if provided
}

function emit_prefix() {
  // Assembly prefix
}

function emit_postfix() {
  // Assembly postfix
}

module.exports.compile = function parse(ast) {
  emit_prefix();
  compile_call(ast[0], ast.slice(1));
  emit_postfix();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From our pseudo-code in comments it is simple enough to fill in.
Let's fill in everything but the prefix and postfix code.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function compile_argument(arg, destination) {
  // If arg AST is a list, call compile_call on it
  if (Array.isArray(arg)) {
    compile_call(arg[0], arg.slice(1), destination);
    return;
  }

  // Else must be a literal number, store in destination register
  emit(1, `MOV ${destination}, ${arg}`);
}

const BUILTIN_FUNCTIONS = { &amp;#39;+&amp;#39;: &amp;#39;plus&amp;#39; };
const PARAM_REGISTERS = [&amp;#39;RDI&amp;#39;, &amp;#39;RSI&amp;#39;, &amp;#39;RDX&amp;#39;];

function compile_call(fun, args, destination) {
  // Save param registers to the stack
  args.forEach((_, i) =&amp;gt; emit(1, `PUSH ${PARAM_REGISTERS[i]}`));

  // Compile arguments and store in param registers
  args.forEach((arg, i) =&amp;gt; compile_argument(arg, PARAM_REGISTERS[i]));

  // Call function
  emit(1, `CALL ${BUILTIN_FUNCTIONS[fun] || fun}`);

  // Restore param registers from the stack
  args.forEach((_, i) =&amp;gt; emit(1, `POP ${PARAM_REGISTERS[args.length - i - 1]}`));

  // Move result into destination if provided
  if (destination) {
    emit(1, `MOV ${destination}, RAX`);
  }

  emit(0, &amp;#39;&amp;#39;); // For nice formatting
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a better compiler, we would not make &lt;code&gt;plus&lt;/code&gt; a built-in
function. We'd emit code for the assembly instruction &lt;code&gt;ADD&lt;/code&gt;. However,
making &lt;code&gt;plus&lt;/code&gt; a function makes code generation simpler and also allows
us to see what function calls look like.&lt;/p&gt;
&lt;p&gt;We'll define the &lt;code&gt;plus&lt;/code&gt; built-in function in the prefix code.&lt;/p&gt;
&lt;h3 id="the-prefix"&gt;The prefix&lt;/h3&gt;&lt;p&gt;Assembly programs consist of a few "sections" in memory. The most
important of which are the &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;data&lt;/code&gt; sections. &lt;code&gt;text&lt;/code&gt; is a
read-only section where the program instructions themselves are
stored. The CPU is instructed to start interpreting from some location
in this text section and it will increment through instructions,
evaluating each instruction until it reaches an instruction that tells
it to jump to a different location to evaluate instructions (e.g. with
CALL, RET, or JMP).&lt;/p&gt;
&lt;p&gt;To denote the text section we emit &lt;code&gt;.text&lt;/code&gt; in our prefix before we
emit our generated code.&lt;/p&gt;
&lt;p class="note"&gt;
  The data section is for statically initialized values (e.g. global
  variables). We don't have any need for that right now so we'll
  ignore it.
  &lt;br /&gt;
  &lt;br /&gt;
  &lt;a href="https://www.cs.bgu.ac.il/~caspl122/wiki.files/lab2/ch07lev1sec6/ch07lev1sec6.html"&gt;Here&lt;/a&gt;
  is a good read with more detail on these (and other) sections.
&lt;/p&gt;&lt;p&gt;Additionally, we need to emit an entrypoint (we'll use &lt;code&gt;_main&lt;/code&gt;) and
add a notice (&lt;code&gt;.global _main&lt;/code&gt;) so that the location of this entrypoint
is visible externally. This is important because we let &lt;code&gt;gcc&lt;/code&gt; handle
the hairier parts of generating an executable file and it needs access
to the entrypoint.&lt;/p&gt;
&lt;p&gt;So far, our prefix looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function emit_prefix() {
  emit(1, &amp;#39;.global _main\n&amp;#39;);

  emit(1, &amp;#39;.text\n&amp;#39;);

  // TODO: add built-in functions

  emit(0, &amp;#39;_main:&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last part of our prefix needs to include the &lt;code&gt;plus&lt;/code&gt; built-in
function. For this, we add the first two parameter registers we agreed
on (&lt;code&gt;RDI&lt;/code&gt; and &lt;code&gt;RSI&lt;/code&gt;) and store the result in &lt;code&gt;RAX&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function emit_prefix() {
  emit(1, &amp;#39;.global _main\n&amp;#39;);

  emit(1, &amp;#39;.text\n&amp;#39;);

  emit(0, &amp;#39;plus:&amp;#39;);
  emit(1, &amp;#39;ADD RDI, RSI&amp;#39;);
  emit(1, &amp;#39;MOV RAX, RDI&amp;#39;);
  emit(1, &amp;#39;RET\n&amp;#39;);

  emit(0, &amp;#39;_main:&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're golden.&lt;/p&gt;
&lt;h3 id="the-postfix"&gt;The postfix&lt;/h3&gt;&lt;p&gt;The job of the postfix will be simple, call &lt;code&gt;exit&lt;/code&gt; with the value of
&lt;code&gt;RAX&lt;/code&gt; since this will be the result of the last function called by the
program.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit&lt;/code&gt; is a syscall, so we'll use the &lt;code&gt;SYSCALL&lt;/code&gt; instruction to call
it. The x86_64 calling convention on macOS and Linux for &lt;code&gt;SYSCALL&lt;/code&gt;
defines parameters the same way &lt;code&gt;CALL&lt;/code&gt; does. But we also need to tell
&lt;code&gt;SYSCALL&lt;/code&gt; what syscall to call. The convention is to set &lt;code&gt;RAX&lt;/code&gt; to the
integer representing the syscall on the current system. On Linux it
will be &lt;code&gt;60&lt;/code&gt;; on macOS it is &lt;code&gt;0x2000001&lt;/code&gt;.&lt;/p&gt;
&lt;p class="note"&gt;
  When I say "convention", I don't mean that you really have a choice
  as a programmer. It was arbitrary when the operating system and
  standard libraries chose it. But if you want to write a working
  program that uses syscalls or calls out to (say) glibc, you'll need
  to follow these conventions.
&lt;/p&gt;&lt;p&gt;The postfix then looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const os = require(&amp;#39;os&amp;#39;);

const SYSCALL_MAP = os.platform() === &amp;#39;darwin&amp;#39; ? {
    &amp;#39;exit&amp;#39;: &amp;#39;0x2000001&amp;#39;,
} : {
    &amp;#39;exit&amp;#39;: 60,
};

function emit_postfix() {
  emit(1, &amp;#39;MOV RDI, RAX&amp;#39;); // Set exit arg
  emit(1, `MOV RAX, ${SYSCALL_MAP[&amp;#39;exit&amp;#39;]}`); // Set syscall number
  emit(1, &amp;#39;SYSCALL&amp;#39;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we're set here too.&lt;/p&gt;
&lt;h3 id="putting-it-all-together"&gt;Putting it all together&lt;/h3&gt;&lt;p&gt;We can finally write our Javascript entrypoint and run our compiler
against a sample program.&lt;/p&gt;
&lt;p&gt;The entrypoint might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;const { parse } = require(&amp;#39;./parser&amp;#39;);
const { compile } = require(&amp;#39;./compiler&amp;#39;);

function main(args) {
  const script = args[2];
  const [ast] = parse(script);
  compile(ast[0]);
}

main(process.argv);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can call it like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs x86asm"&gt;$ node ulisp.js &amp;#39;(+ 3 (+ 2 1))&amp;#39;
  .global _main

  .text

plus:
  ADD RDI, RSI
  MOV RAX, RDI
  RET

_main:
  PUSH RDI
  PUSH RSI
  MOV RDI, 3
  PUSH RDI
  PUSH RSI
  MOV RDI, 2
  MOV RSI, 1
  CALL plus
  POP RSI
  POP RDI
  MOV RSI, RAX

  CALL plus
  POP RSI
  POP RDI

  MOV RDI, RAX
  MOV RAX, 0x2000001
  SYSCALL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="generating-an-executable-file-from-the-output"&gt;Generating an executable file from the output&lt;/h3&gt;&lt;p&gt;If we redirect the previous output to an assembly file and call &lt;code&gt;gcc&lt;/code&gt;
on it, we can generate a program we can run. Then we can echo the &lt;code&gt;$?&lt;/code&gt;
variable to see the exit code of the previous process.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ node ulisp.js &amp;#39;(+ 3 (+ 2 1))&amp;#39; &amp;gt; program.S
$ gcc -mstackrealign -masm=intel -o program program.s
$ ./program
$ echo $?
6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we've got a working compiler! The full source of the compiler is
available &lt;a href="https://github.com/eatonphil/ulisp"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="further-reading"&gt;Further reading&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf"&gt;x86_64 calling convention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;macOS assembly programming&lt;ul&gt;
&lt;li&gt;&lt;a href="http://fabiensanglard.net/macosxassembly/index.php"&gt;Stack alignment on macOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://filippo.io/making-system-calls-from-assembly-in-mac-os-x/"&gt;Syscalls on macOS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Destination-driven code generation&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.cs.indiana.edu/~dyb/pubs/ddcg.pdf"&gt;Kent Dybvig's original paper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cs.au.dk/~mis/dOvs/slides/46b-codegeneration-in-V8.pdf"&gt;One-pass code generation in V8&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/x86asm.min.js"&gt;&lt;/script&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Finished that intro to compilers post :) lisp to assembly in Javascript &lt;a href="https://t.co/0HDIn4Mv7a"&gt;https://t.co/0HDIn4Mv7a&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1066863077000441856?ref_src=twsrc%5Etfw"&gt;November 26, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/compiler-basics-lisp-to-assembly.html</guid><pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate></item><item><title>On NYC, Tokyo and Seoul</title><link>http://notes.eatonphil.com/on-nyc-tokyo-and-seoul.html</link><description>&lt;p&gt;I’ve lived in NYC for the past year — moved here after years in Philly
and after growing up in a rural community a few hours west of
there. My wife is South Korean and last week concluded my second trip
to the suburbs of Seoul to visit her family. We finished up that trip
with a week in Tokyo.&lt;/p&gt;
&lt;p&gt;Long a mecha and Godzilla fan, I was struck by a city not
significantly more modern, or significantly more “Eastern”, than
NYC. In contrast, the lesser known Seoul is more modern than both
cities and shares as much “Eastern” vibe as Tokyo.&lt;/p&gt;
&lt;p&gt;I’d go so far as to say that Seoul is the most livable of the three
for anyone of a similar background. There are a few concrete areas
that led me to this including transportation, apartments, WiFi/cafes,
food, and language.&lt;/p&gt;
&lt;p&gt;I'll conclude with a few tourist recommendations and a list of books
to read on South Korea and Japan if you share my enthusiasm for
comparing life in different cities.&lt;/p&gt;
&lt;h3 id="transportation"&gt;Transportation&lt;/h3&gt;&lt;p&gt;NYC is one of the few cities in the world with a subway that runs
24/7. Tokyo and Seoul do not share this trait despite being many
decades newer. (Tokyo and Seoul were heavily damaged during World War
II and the Korean War, respectively.) And despite being built later,
Tokyo subway cars are even less wide than NYC subway cars (~8.2ft
vs. ~8.5ft).&lt;/p&gt;
&lt;p&gt;In contrast, Seoul subway cars are ~10.2ft wide. The difference may
seem slight but it is noticeable during rush hour when in Seoul there
is space for four people to stand in the aisle versus room for perhaps
two in a Tokyo or NYC subway car.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://photos.travelblog.org/Photos/10223/428861/f/4174039-Seoul-subway-car-0.jpg" alt="Seoul subway car" /&gt;
&lt;small&gt;Seoul subway car, source: Travel Blog&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;The Seoul subway system is also the most advanced in terms of
safety. All stations have a floor-to-ceiling barrier with doors that
only open when a train arrives. Most stations in Tokyo have a ~3ft
tall barrier that does the same, though some stations have no
barrier. In NYC there are no barriers anywhere.&lt;/p&gt;
&lt;p&gt;Concerning innovation, Seoul and Tokyo both have multiple driverless
subway lines whereas NYC has none. But in terms of complexity the NYC
subway is the simplest because you pay only once. Seoul and Tokyo
subways are slightly more complex in that you swipe your card when you
enter and exit (or transfer).&lt;/p&gt;
&lt;h4 id="taxis"&gt;Taxis&lt;/h4&gt;&lt;p&gt;It was jarring to be greeted by the very 90s, vaguely British Toyota
Crown taxi cabs that dominate the streets of Tokyo.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/WuIHqxY_d.jpg?maxwidth=640&amp;shape=thumb&amp;fidelity=medium" alt="Toyota Crown cab" /&gt;
&lt;small&gt;Source: Phil Eaton&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;These cabs have no integrated navigation unit but a modern unit was
typically mechanically attached. We saw a few of the recently approved
Toyota JPN Taxi, but they only account for around &lt;a href="https://www.japantimes.co.jp/news/2018/05/23/business/taxi-tokyo-prepares-olympic-tourism-boom-accessible-cabs-international-drivers/"&gt;10
percent&lt;/a&gt;
of cabs. (The integrated navigation is massive, perhaps 10-inch
screens.) In contrast, Seoul has a
&lt;a href="http://travel.cnn.com/seoul/life/seoul-taxi-guide-783378/"&gt;variety&lt;/a&gt;
of modern cabs all with integrated navigation — the most common of
which is the Hyundai Sonata.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.theseoulguide.com/wp-content/uploads/2013/09/regular_orange_taxi_in_seoul.jpg" alt="Hyundai Sonata cab" /&gt;
&lt;small&gt;Source: The Seoul Guide&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Although Japanese car companies
&lt;a href="https://www.motortrend.com/news/12q2-1993-eunos-mazda-cosmo-drive/"&gt;pioneered&lt;/a&gt;
integrated navigation in the 90s, it appears to have been the standard
for South Korean car companies for the past 10-20 years.&lt;/p&gt;
&lt;p&gt;And then there’s NYC with its primary mix of Crown Victorias and
Priuses with multiple 4-inch smartphones mechanically attached for
navigation.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://thenypost.files.wordpress.com/2013/10/cab2.jpg?quality=90&amp;strip=all" /&gt;
&lt;small&gt;Source: New York Post&lt;/small&gt;&lt;/p&gt;
&lt;h3 id="living"&gt;Living&lt;/h3&gt;&lt;p&gt;South Korea has no concept of the suburb oriented around single-family
houses. Drive an hour or two out from Seoul or Busan and see the same
massive, modern apartment complexes that are found in the city
center. After that it's the stark farms of Kansas. Japan appears more
like the US in that the city graduates steadily to suburb and farm.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.japantimes.2xx.jp/wp-content/uploads/2013/09/wn20130918n2a-870x580.jpg" alt="Apartments in Seoul" /&gt;
&lt;small&gt;Apartments in Seoul, source: Japan Times&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;In general, buildings in South Korea are fairly homogeneous. Even the
downtown areas of Seoul have little architectural creativity. Tokyo
and NYC are both diverse in building styles and sizes. However, NYC
takes the cake for ubiquity of massive towers. In fact, the first time
my South Korean father-in-law visited Manhattan he was blown away by
this mass.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8e/Manhattan_Skyline_night.jpg/800px-Manhattan_Skyline_night.jpg" alt="Manhattan skyline"&gt;
&lt;small&gt;New York City, source: Wikipedia&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;The most popular neighborhoods in Tokyo seem more developed than their
Seoul counterparts, the mass of stores and crowds extends further. And
while the average age of buildings in Tokyo seems younger than the
average age of buildings throughout Seoul (including less desirable
areas), the developed areas (including buildings and streets) of Seoul
are significantly cleaner and more modern. In contrast, and on average,
Tokyo buildings seem as old as NYC buildings.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.fodors.com/wp-content/uploads/2018/02/Tokyo-Neighborhoods-Along-Arakawa-Streetcar-1.jpg" /&gt;
&lt;small&gt;Tokyo, source: Fodors&lt;/small&gt;&lt;/p&gt;
&lt;h4 id="air-quality"&gt;Air quality&lt;/h4&gt;&lt;p&gt;Air quality in &lt;a href="https://www.numbeo.com/pollution/in/New-York"&gt;NYC&lt;/a&gt; and
&lt;a href="https://www.numbeo.com/pollution/in/Tokyo"&gt;Tokyo&lt;/a&gt; is high, pollution
is low. But in &lt;a href="https://www.upi.com/Fine-dust-levels-soar-in-South-Korea/5581523776231/"&gt;recent
times&lt;/a&gt;,
air quality in Seoul has deteriorated with dangerous levels of fine
dust from factories in South Korea and China. It is not clear when or
how the South Korean government will address this.&lt;/p&gt;
&lt;h3 id="wifi/cafes"&gt;WiFi/Cafes&lt;/h3&gt;&lt;p&gt;My idea of a good cafe is a decent ratio of seats to traffic,
available electrical outlets, and decent WiFi. NYC and Tokyo have some
similarities: chain coffee shops are larger and non-chains are often
pretty small. Tokyo differs from NYC in that there are few electrical
outlets and in the existence of interior smoking sections. (Tokyo bans
smoking while walking but designates areas like parks or inner
rooms in restaurants or cafes.)&lt;/p&gt;
&lt;p&gt;But the WiFi in Tokyo is abysmal. Many cafes do not have it (though
the trend is to provide) and even the chains that do provide it have
terrible speeds reaching peaks of 5Mbps down. In NYC WiFi is available
near ~20Mbps down at most chains and ~5Mpbs at smaller non-chains.&lt;/p&gt;
&lt;p&gt;In contrast, South Korea is the jewel of cafe culture. Unlike how in
the US coffee shop size decreases as population increases, coffee shop
sizes in South Korea are oddly enormous everywhere. South Korea is
rich with local shops, domestic chains (including the exported Paris
Baguette and Tous Les Jours), and foreign chains (South Korea has the
highest number of Starbucks Reserve stores per capita of any country).&lt;/p&gt;
&lt;p&gt;&lt;img src="https://file.mk.co.kr/meet/neds/2018/06/image_readtop_2018_402044_15299876083365412.jpg" alt="" /&gt;
&lt;small&gt;Starbucks Reserve in Seoul, source: Pulse News&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;From Jeju Island to Seoul we never worried about a seat or an outlet
at a cafe. Furthermore, the WiFi in South Korea is incredible. My
tech-hopeless in-law’s basic internet plan got 80Mbps down and the
small cafes near their apartment got at least 40Mbps down.&lt;/p&gt;
&lt;p&gt;NYC falls closer to Seoul in terms of ubiquity and speed of WiFi and
has the added benefit of fast city-provided, outdoor WiFi surprisingly
fast and available throughout the city. NYC is much worse in terms of
daylight. Most cafes close between 8-10pm whereas cafes in Seoul and
Tokyo easily stay open past 11pm.&lt;/p&gt;
&lt;h4 id="caveat"&gt;Caveat&lt;/h4&gt;&lt;p&gt;It’s not exactly fair to exclude internet cafes, prevalent in both
Seoul and Tokyo (oddly even NYC has a
&lt;a href="https://www.google.com/maps?q=nyc+internet+cafe&amp;amp;um=1&amp;amp;ie=UTF-8&amp;amp;sa=X&amp;amp;ved=0ahUKEwjE0-PxuZTeAhWTdXAKHYDFB1cQ_AUIDigB"&gt;few&lt;/a&gt;). At
an internet cafe in Tokyo you can expect abundant outlets and
excellent WiFi (I saw peaks of 40Mbps down). I did not visit an
internet cafe in Seoul but I expect it to be similar. In both Seoul
and Tokyo you can easily find 24/7 service (with showers!?).&lt;/p&gt;
&lt;p&gt;I did not include internet cafes above because I find them slightly
less convenient for tourists. Though credit is due: unlike American
Chinatown internet cafes, the ones we visited in Tokyo were very
clean, spacious and warm.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://rakutama.com/en/images/shop/koriyama.jpg" alt="Internet cafe in Shinjuku" /&gt;
&lt;small&gt;Internet cafe in Shinjuku, source: Rakutama&lt;/small&gt;&lt;/p&gt;
&lt;h3 id="food"&gt;Food&lt;/h3&gt;&lt;p&gt;Dining out in NYC is similar in cost to other major US cities. The
quality is usually pretty good. Tokyo was about as expensive as food
in NYC and generally as high quality. For instance, most dinners in
NYC and Tokyo cost about $40-60 for two people. In contrast, most
entrees in Seoul are sold for two and the dinner in total was often
about $20-40. Restaurants on average seemed to be lower quality in
Seoul compared to Tokyo and New York, but there are still more than
enough high quality options.&lt;/p&gt;
&lt;h3 id="language"&gt;Language&lt;/h3&gt;&lt;p&gt;I am biased having a better knowledge of Korean than Japanese and a
South Korean partner to fall back on. But I believe South Korea is the
more friendly place for an English speaker in that it is more
dedicated to providing English translations and that the written
language is simpler. In both cities the penetration of
English-speaking natives (and quality of speech and comprehension) is
indistinguishable and decent.&lt;/p&gt;
&lt;p&gt;To the first point, even the oddest locations and obscure signage had
English translations in South Korea (not just Seoul) — not so even
within Tokyo.&lt;/p&gt;
&lt;p&gt;To the second point, Japanese has three writing systems (kanji,
hiragana, and katakana). Kanji (characters originating from Chinese)
cannot be replaced in writing by phonetic counterparts in hiragana or
katakana. So you have little choice but to memorize all important
characters, disregarding the fact that many characters can be broken
down. Then you must also memorize the alphabetic systems of hiragana
and katakana.&lt;/p&gt;
&lt;p&gt;In contrast, Korean has two writing systems (hangul and hanja) where
hanja (characters originating from Chinese) is primarily used in
formal settings (government forms, academic books, etc.) and can be
replaced with the phonetic equivalent in hangul.&lt;/p&gt;
&lt;p&gt;This makes it much simpler to memorize and read Korean compared to
Japanese.&lt;/p&gt;
&lt;h3 id="assorted-recommendations"&gt;Assorted recommendations&lt;/h3&gt;&lt;p&gt;For New Yorkers, don’t stay in the recommended areas of
Shinjuku/Shibuya/Roppongi unless you’re the type who’d enjoy staying
around Times Square. These three areas of Tokyo are just as obnoxious
albeit much safer. I also don’t recommend the Harajuku area; it is
extra. There’s no real equivalent level of crazy in Seoul although
Hongdae comes close.&lt;/p&gt;
&lt;p&gt;In a future Tokyo trip I’d stick to the Meguro Station area including
Ebisu and Daikanyama. They are beautiful, quiet neighborhoods with
lots of restaurants and cafes beside the Meguro river. Areas along the
Sumida River are also beautiful and quiet. Ginza/Tokyo Station is
also a fun-but-not-obnoxious area to visit.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://odis.homeaway.com/odis/listing/f3fd8dfd-c29e-4ab3-a0cd-19a99bdc3c7f.c10.jpg" alt="Ebisu"&gt;
&lt;small&gt;Ebisu, source: Homeaway&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;I cannot recommend the Edo-Tokyo Museum enough, it is the best city
museum I've visited. Tsukiji is also a must see, reminding me how much
I miss going to Reading Terminal Market each weekend in Philly.&lt;/p&gt;
&lt;p&gt;In Seoul I’d recommend Yeonnam-Dong, Itaewon (which is much nicer than
it’s made out to be), and Gwanghwamun. Mapo-Gu in general is a great
region of Gangbuk as is the area below it (near Yeouido) in
Gangnam.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://i.imgur.com/ttdg5Y7.jpg?maxwidth=640" alt="Yeonnam-dong" /&gt;
&lt;small&gt;Yeonnam-Dong, source: Phil Eaton&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;I recommend visiting the National Museum of Korea in Seoul as well as
Hangang Park and Gyeongui Line Forest Park. The areas around the
Tancheon stream flowing South to Bundang are also beautiful.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://misadventuresofanawkwardamerican.files.wordpress.com/2014/05/dscn05912.jpg" alt="Tancheon near Bundang" /&gt;
&lt;small&gt;Tancheon near Bundang, source: Misadventures of an Awkward American&lt;/small&gt;&lt;/p&gt;
&lt;h3 id="conclusion"&gt;Conclusion&lt;/h3&gt;&lt;p&gt;I came to Tokyo with the expectation of a highly modern city fused
with Eastern culture. But it is difficult to see many ways it is ahead
of NYC technically and it is very similar to NYC culturally. In some
ways Tokyo even seems a little stuck in the past or just... off. Why
are all vending machines [e.g. for tickets, ordering food, etc.]
mechanical and not touch screens? The National Museum of Science is
awfully old and ugly, the National Diet Building the same.&lt;/p&gt;
&lt;p&gt;So on the one hand I’d like to let the next person down lightly on the
excitement of Japan. It is a world-class city with great restaurants,
live music and refined culture but all-in-all very similar to NYC. On
the other hand I recommend Seoul for a cheaper, cleaner, more
English-speaker friendly, and genuinely novel city with splashes of
"Eastern" romantic elements like Tokyo.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://www.englishspectrum.com/wp-content/uploads/2015/03/yeoido.JPG-1.jpg" alt="Cherry blossoms in Seoul" /&gt;
&lt;small&gt;Cherry blossoms in Seoul, source: English Spectrum&lt;/small&gt;&lt;/p&gt;
&lt;h3 id="further-reading"&gt;Further reading&lt;/h3&gt;&lt;p&gt;&lt;a href="https://amzn.to/2PNOsih"&gt;MITI and the Japanese Miracle: The Growth of Industrial Policy,
1925-1975&lt;/a&gt; is an excellent, albeit somewhat
disputed introduction to the modern Japanese economy.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://amzn.to/2EIw6hc"&gt;Asia’s Next Giant: South Korea and Late
Industrialization&lt;/a&gt; is a similar high-quality
introduction to the South Korean economy.&lt;/p&gt;
&lt;p&gt;If you’re only familiar with
US/Canadian companies or other “pure” market economies these two books
are a great read on different, challenging styles of government
policy, corporate structure, and life.&lt;/p&gt;
&lt;p class="note"&gt;
  P.s. I’m looking for book recommendations on the last 20 years of
  economic/political history in Japan and South Korean and on the last
  100 years of economic/political history in the US and NYC.
&lt;/p&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Wrote a few points of comparison between &lt;a href="https://twitter.com/hashtag/nyc?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#nyc&lt;/a&gt;, &lt;a href="https://twitter.com/hashtag/seoul?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#seoul&lt;/a&gt;, and &lt;a href="https://twitter.com/hashtag/tokyo?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#tokyo&lt;/a&gt; after finishing a recent trip. &lt;a href="https://t.co/oKo4YlTZV3"&gt;https://t.co/oKo4YlTZV3&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/1053645222402416641?ref_src=twsrc%5Etfw"&gt;October 20, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/on-nyc-tokyo-and-seoul.html</guid><pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate></item><item><title>Why (and how) to read books</title><link>http://notes.eatonphil.com/why-and-how-to-read-books.html</link><description>&lt;p&gt;The last time I read for fun was in elementary school. Since college I
knew I must read more, but I never forced myself to build the
habit. Then three years ago I spent time around my brother and a
coworker who were avid readers. This "peer pressure" helped me get
started.&lt;/p&gt;
&lt;p&gt;Since I started, I've seen concrete improvements in vocabulary. I find
myself using words I didn't know I knew. I question my choice of words
more. And I understand coworkers a little better. Perhaps it is only
personal style, but I've also become more aware of hyperbole in my
speech and have begun to tone that down.&lt;/p&gt;
&lt;p&gt;Specifically, books provide more density of information than I can
pull together myself. I've also benefited heavily from reading books
on tools I use daily. Contrary to being boring, a book on a topic with
which I'm familiar has been a (often needed) break from books on
topics with which I am unfamiliar. The former category might include
books on CSS, Bash, Emacs, Python, Scheme, data modeling,
Linux/FreeBSD system administration, mystery novels, and so on. The
latter category might include books on Common Lisp, system
architecture, the implementation of Linux/FreeBSD, behavioral
psychology, management, stock/bond markets, the history of
Argentina/Chile/South Korea/Japan, sci-fi novels, and so on.&lt;/p&gt;
&lt;p&gt;Reading diversely exposes how little I know. And that can be
depressing. But I'm fairly confident reading books is the fastest way
to grow.&lt;/p&gt;
&lt;p&gt;Tactically speaking, I started slowly with few books and the ones
easiest for me to read. The first year I read two books, both
technical. The second year I read nine books and was able to start
branching out beyond technical books. Last year I read a much more
diverse set of forty books. And this year I followed suit with
forty-one so far (on track for fifty-five or so).&lt;/p&gt;
&lt;p&gt;I keep track of books I'm reading and books I want to read in
&lt;a href="https://www.goodreads.com/eatonphil"&gt;Goodreads&lt;/a&gt;. I particularly enjoy
their reading challenge system that lets you know if you are on track
to meet your reading goal for the year.&lt;/p&gt;
&lt;p&gt;Send &lt;a href="https://twitter.com/phil_eaton"&gt;me&lt;/a&gt; book recommendations!&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/why-and-how-to-read-books.html</guid><pubDate>Wed, 26 Sep 2018 00:00:00 +0000</pubDate></item><item><title>Compiling dynamic programming languages</title><link>http://notes.eatonphil.com/compiling-dynamic-programming-languages.html</link><description>&lt;p&gt;It can be difficult to disassociate the idea that dynamically typed
programming languages are tied to byte-code interpreters (e.g. YARV
Ruby, CPython, V8, Zend Engine, etc.). But for many languages, a
compiled implementation also exists. Cython, Chicken Scheme and SBCL
are good examples.&lt;/p&gt;
&lt;p&gt;In this post I will briefly describe how I built a compiler for my
&lt;a href="https://github.com/eatonphil/bsdscheme"&gt;Scheme implementation&lt;/a&gt; using
artifacts from the interpreter. In doing this, I learned a simple (not
novel) technique for compiling dynamic languages. I'll introduce the
&lt;a href="https://github.com/eatonphil/jsc"&gt;Javascript to C++/V8 compiler&lt;/a&gt; I
am developing using this technique.&lt;/p&gt;
&lt;h3 id="bsdscheme"&gt;BSDScheme&lt;/h3&gt;&lt;p&gt;For the past year I've developed a Scheme implementation,
&lt;a href="https://github.com/eatonphil/bsdscheme"&gt;BSDScheme&lt;/a&gt;. I started with an
AST-interpreter (as opposed to a byte-code compiler and VM). A more
detailed blog post on the first few steps writing BSDScheme can be
found
&lt;a href="http://notes.eatonphil.com/first-few-hurdles-writing-a-scheme-interpreter.html"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As I built up support for the various objects and operations in the
language, I had a sizeable base of D code for the BSDScheme
runtime. This included an object representation for primitive types
(and support for converting to and from types in D) as well as basic
Scheme operations
(&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;car&lt;/code&gt;, &lt;code&gt;cdr&lt;/code&gt;,
etc.).&lt;/p&gt;
&lt;p&gt;When the time came to implement a compiler backend, I only needed to
do codegen since the parser already existed. Furthermore, the
fundamental bits had already been written: object representation and
much of the standard library. So I wrote the simplest compiler I could
think of by targeting D and the objects/functions I had already
written to support the interpreter.&lt;/p&gt;
&lt;p&gt;Take, for example, the &lt;code&gt;equals&lt;/code&gt;
&lt;a href="https://github.com/eatonphil/bsdscheme/blob/master/src/common.d#L140"&gt;function&lt;/a&gt;
in the standard library:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;Value equals(Value arguments, void** rest) {
  auto tuple = valueToList(arguments);
  auto left = tuple[0];
  auto right = car(tuple[1]);

  bool b;

  switch (tagOfValue(left)) {
  case ValueTag.Integer:
    b = valueIsInteger(right) &amp;amp;&amp;amp; valueToInteger(left) == valueToInteger(right);
    break;
  case ValueTag.Char:
    b = valueIsChar(right) &amp;amp;&amp;amp; valueToChar(left) == valueToChar(right);
    break;
  case ValueTag.String:
    b = valueIsString(right) &amp;amp;&amp;amp; valueToString(left) == valueToString(right);
    break;
  case ValueTag.Symbol:
    b = valueIsSymbol(right) &amp;amp;&amp;amp; valueToSymbol(left) == valueToSymbol(right);
    break;
  case ValueTag.Function:
    b = valueIsFunction(right) &amp;amp;&amp;amp; valueToFunction(left)[1] == valueToFunction(right)[1];
    break;
  case ValueTag.Bool:
    b = valueIsBool(right) &amp;amp;&amp;amp; valueToBool(left) == valueToBool(right);
    break;
  default:
    b = false;
  }

  return makeBoolValue(b);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So long as my compiler generated code that used the &lt;code&gt;Value&lt;/code&gt;
object to represent Scheme data, I already had an &lt;code&gt;equals&lt;/code&gt;
function and large swaths of a Scheme standard library that I could
share between the compiler and interpreter.&lt;/p&gt;
&lt;p&gt;Ultimately I only needed to implement a few control structures to
support compiling a large subset of what I supported in the
interpreter. The key aspects here include: function definitions (in
D), function calls (D function calls), if/else (if/else in D) and so
on.&lt;/p&gt;
&lt;p&gt;To give a concrete example of a whole program compiled, this Scheme program:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;(define (exp base pow)
  (if (= pow 0)
      1
      (* base (exp base (- pow 1)))))

(define (main)
  (display (exp 2 16))
(newline))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when run through the BSDScheme compiler would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs c++"&gt;import std.stdio;
import lex;
import common;
import parse;
import utility;
import value;
import buffer;

Value exp(Value arguments, void** ctx) {
    Value[] tmp = listToVector(arguments);
    Value base = tmp[0];
    Value pow = tmp[1];

    Value equals_result = equals(vectorToList([pow, makeIntegerValue(0)]), null);
    Value if_result;
    if (truthy(equals_result)) {
    makeIntegerValue(1);
    if_result = makeIntegerValue(1);
    } else {

    Value minus_result = minus(vectorToList([pow, makeIntegerValue(1)]), null);

    Value exp_result = exp(vectorToList([base, minus_result]), null);

    Value times_result = times(vectorToList([base, exp_result]), null);
    if_result = times_result;
    };
    return if_result;
}

Value BSDScheme_main(Value arguments, void** ctx) {

    Value exp_result = exp(vectorToList([makeIntegerValue(2), makeIntegerValue(16)]), null);

    Value display_result = display(vectorToList([exp_result]), null);

    Value newline_result = newline(vectorToList([]), null);
    return newline_result;
}

void main() { BSDScheme_main(nilValue, cast(void**)0); }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where &lt;em&gt;every imported function had already been written for the
interpreter&lt;/em&gt;. I had only to translate a few lines to D and import/call
these existing libraries. Now I had a small &lt;em&gt;binary&lt;/em&gt; of compiled
Scheme.&lt;/p&gt;
&lt;p&gt;It was at this point I realized I was using the same technique used by
Cython to compile Python code.&lt;/p&gt;
&lt;p class="note"&gt;
  ...the Cython project has approached this problem by means of a
  source code compiler that translates Python code to equivalent C
  code. This code is executed within the CPython runtime environment,
  but at the speed of compiled C and with the ability to call directly
  into C libraries.

  &lt;a href="http://docs.cython.org/en/latest/src/quickstart/overview.html"&gt;
    http://docs.cython.org/en/latest/src/quickstart/overview.html
  &lt;/a&gt;
&lt;/p&gt;&lt;h3 id="jsc"&gt;jsc&lt;/h3&gt;&lt;p&gt;I played with many PL-research-y languages over the years and wanted
to do build something a little more practical. So I took what I
learned writing the BSDScheme compiler and decided to write a
Javascript compiler. Specifically, it would target the easiest backend
I could imagine: C++ using the V8 C++ library and generating a Node
addon.&lt;/p&gt;
&lt;p&gt;There already existed well-trodden guides/means of writing Node addons
in C++ so I spent some time trying to hand-compile simple Javascript
programs to C++ and V8. A string in Javascript would become a
&lt;code&gt;v8::String&lt;/code&gt; type in C++. A number in Javascript would become
&lt;code&gt;v8::Number&lt;/code&gt; in C++ and so forth.&lt;/p&gt;
&lt;p&gt;I decided to write this compiler in Rust given its roots in (and my
familiarity with) ML and Python. I found a &lt;a href="https://github.com/dherman/esprit"&gt;Javascript parser by Dave
Herman&lt;/a&gt; and after a few lazy weeks
finally got a "Hello world!" program compiling. Getting my first
program to compile has by far been the hardest part of building jsc.&lt;/p&gt;
&lt;p&gt;Let's look at a concrete example of a recursive fibonacci program
(example/recursion.js in the
&lt;a href="https://github.com/eatonphil/jsc"&gt;repo&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function fib(i) {
  if (i &amp;lt;= 1) {
    return i;
  }
  return fib(i - 1) + fib(i - 2);
}

function main() {
  console.log(fib(20));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's add a call to &lt;code&gt;main()&lt;/code&gt; at the end and time this with
Node to get a baseline:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ time node example/recursion.js
6765
node example/recursion.js  0.06s user 0.02s system 97% cpu 0.083 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let's install jsc to compare. We'll need Rust, Cargo, Node and
Node-GYP.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ git clone https:/github.com/eatonphil/jsc
$ cd jsc
$ make &amp;amp;&amp;amp; make install
$ jsc example/recursion.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsc produces a Javascript entrypoint that imports our addon
(build/recursion.js):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;require(&amp;quot;./build/Release/recursion&amp;quot;).jsc_main();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it produces a C++ file that represents the entire program
(build/recursion.cc):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs cpp"&gt;#include &amp;lt;string&amp;gt;

#include &amp;lt;node.h&amp;gt;

using v8::Boolean;
using v8::Context;
using v8::Exception;
using v8::Function;
using v8::FunctionTemplate;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Null;
using v8::Number;
using v8::Object;
using v8::String;
using v8::False;
using v8::True;
using v8::Value;

void fib(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = args.GetIsolate();
  Local&amp;lt;Value&amp;gt; i = args[0];
tail_recurse_1:
  Local&amp;lt;Context&amp;gt; ctx_2 = isolate-&amp;gt;GetCurrentContext();
  Local&amp;lt;Object&amp;gt; global_3 = ctx_2-&amp;gt;Global();
  Local&amp;lt;Function&amp;gt; Boolean_4 = Local&amp;lt;Function&amp;gt;::Cast(global_3-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;Boolean&amp;quot;)));
  String::Utf8Value utf8value_tmp_5(i);
  std::string string_tmp_6(*utf8value_tmp_5);
  String::Utf8Value utf8value_tmp_7(Number::New(isolate, 1));
  std::string string_tmp_8(*utf8value_tmp_7);
  Local&amp;lt;Value&amp;gt; argv_9[] = { (i-&amp;gt;IsNumber() || Number::New(isolate, 1)-&amp;gt;IsNumber()) ? Boolean::New(isolate, i-&amp;gt;ToNumber(isolate)-&amp;gt;Value() &amp;lt;= Number::New(isolate, 1)-&amp;gt;ToNumber(isolate)-&amp;gt;Value()) : ((i-&amp;gt;IsString() || Number::New(isolate, 1)-&amp;gt;IsString()) ? Boolean::New(isolate, string_tmp_6 &amp;lt;= string_tmp_8) : (False(isolate))) };
  Local&amp;lt;Value&amp;gt; result_10 = Boolean_4-&amp;gt;Call(Null(isolate), 1, argv_9);
  if (result_10-&amp;gt;ToBoolean()-&amp;gt;Value()) {
    args.GetReturnValue().Set(i);
    return;
    return;
  }
  Local&amp;lt;Value&amp;gt; arg_11 = (i-&amp;gt;IsNumber() || Number::New(isolate, 1)-&amp;gt;IsNumber()) ? (Number::New(isolate, i-&amp;gt;ToNumber(isolate)-&amp;gt;Value() - Number::New(isolate, 1)-&amp;gt;ToNumber(isolate)-&amp;gt;Value())) : Local&amp;lt;Number&amp;gt;::Cast(Null(isolate));
  Local&amp;lt;FunctionTemplate&amp;gt; ftpl_13 = FunctionTemplate::New(isolate, fib);
  Local&amp;lt;Function&amp;gt; fn_12 = ftpl_13-&amp;gt;GetFunction();
  fn_12-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;fib&amp;quot;));
  Local&amp;lt;Value&amp;gt; argv_14[] = { arg_11 };
  Local&amp;lt;Value&amp;gt; result_15 = fn_12-&amp;gt;Call(Null(isolate), 1, argv_14);
  Local&amp;lt;Value&amp;gt; arg_16 = (i-&amp;gt;IsNumber() || Number::New(isolate, 2)-&amp;gt;IsNumber()) ? (Number::New(isolate, i-&amp;gt;ToNumber(isolate)-&amp;gt;Value() - Number::New(isolate, 2)-&amp;gt;ToNumber(isolate)-&amp;gt;Value())) : Local&amp;lt;Number&amp;gt;::Cast(Null(isolate));
  Local&amp;lt;FunctionTemplate&amp;gt; ftpl_18 = FunctionTemplate::New(isolate, fib);
  Local&amp;lt;Function&amp;gt; fn_17 = ftpl_18-&amp;gt;GetFunction();
  fn_17-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;fib&amp;quot;));
  Local&amp;lt;Value&amp;gt; argv_19[] = { arg_16 };
  Local&amp;lt;Value&amp;gt; result_20 = fn_17-&amp;gt;Call(Null(isolate), 1, argv_19);
  args.GetReturnValue().Set((result_15-&amp;gt;IsString() || result_20-&amp;gt;IsString()) ? Local&amp;lt;Value&amp;gt;::Cast(String::Concat(result_15-&amp;gt;ToString(), result_20-&amp;gt;ToString())) : Local&amp;lt;Value&amp;gt;::Cast((result_15-&amp;gt;IsNumber() || result_20-&amp;gt;IsNumber()) ? (Number::New(isolate, result_15-&amp;gt;ToNumber(isolate)-&amp;gt;Value() + result_20-&amp;gt;ToNumber(isolate)-&amp;gt;Value())) : Local&amp;lt;Number&amp;gt;::Cast(Null(isolate))));
  return;
}

void jsc_main(const FunctionCallbackInfo&amp;lt;Value&amp;gt;&amp;amp; args) {
  Isolate* isolate = args.GetIsolate();
tail_recurse_21:
  Local&amp;lt;Value&amp;gt; arg_22 = Number::New(isolate, 20);
  Local&amp;lt;FunctionTemplate&amp;gt; ftpl_24 = FunctionTemplate::New(isolate, fib);
  Local&amp;lt;Function&amp;gt; fn_23 = ftpl_24-&amp;gt;GetFunction();
  fn_23-&amp;gt;SetName(String::NewFromUtf8(isolate, &amp;quot;fib&amp;quot;));
  Local&amp;lt;Value&amp;gt; argv_25[] = { arg_22 };
  Local&amp;lt;Value&amp;gt; result_26 = fn_23-&amp;gt;Call(Null(isolate), 1, argv_25);
  Local&amp;lt;Value&amp;gt; arg_27 = result_26;
  Local&amp;lt;Function&amp;gt; fn_28 = Local&amp;lt;Function&amp;gt;::Cast(Local&amp;lt;Object&amp;gt;::Cast(isolate-&amp;gt;GetCurrentContext()-&amp;gt;Global()-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;console&amp;quot;)))-&amp;gt;Get(String::NewFromUtf8(isolate, &amp;quot;log&amp;quot;)));
  Local&amp;lt;Value&amp;gt; argv_29[] = { arg_27 };
  Local&amp;lt;Value&amp;gt; result_30 = fn_28-&amp;gt;Call(Null(isolate), 1, argv_29);
  result_30;
}

void Init(Local&amp;lt;Object&amp;gt; exports) {
  NODE_SET_METHOD(exports, &amp;quot;jsc_main&amp;quot;, jsc_main);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Init)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's time this version:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ time node build/recursion.js
6765
node build/recursion.js  0.16s user 0.03s system 107% cpu 0.175 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jsc, over twice as slow, is already falling behind Node. :)&lt;/p&gt;
&lt;p&gt;As I incremented the number passed to my fibonacci function the
compiled program time to completion get exponentially worse. Node
stayed the same. I decided to try tail-call optimization to decrease
the performance distance between Node and jsc.&lt;/p&gt;
&lt;p&gt;I implemented tail-call optimization for the interpreter in BSDScheme
by putting all functions in a loop that would break if tail-call
elimination was not to happen. It took me a week to implement this and
I never put it in place for the compiler. This time around I was able
to add basic tail call elimination to jsc in two hours. It is done
by &lt;code&gt;label&lt;/code&gt;s and &lt;code&gt;goto&lt;/code&gt;s instead of a tail call
when applicable.&lt;/p&gt;
&lt;p&gt;Here is a tail-call optimized version of the same program
(example/tco.js):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs javascript"&gt;function fib(n, a, b) {
    if (n == 0) {
        return a;
    }

    if (n == 1) {
        return b;
    }

    return fib(n - 1, b, a + b);
}

function main() {
  console.log(fib(50, 0, 1));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We add a call to &lt;code&gt;main()&lt;/code&gt; again for Node and time it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs bash"&gt;$ time node example/tco.js
12586269025
node example/tco.js  0.06s user 0.02s system 96% cpu 0.080 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And compile it with jsc and time it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ jsc example/tco.js
$ time node build/tco.js
12586269025
node build/tco.js  0.07s user 0.02s system 95% cpu 0.087 total
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Well that's not bad at all. :)&lt;/p&gt;
&lt;h3 id="next-steps-with-jsc"&gt;Next steps with jsc&lt;/h3&gt;&lt;p&gt;jsc has very limited support for... everything. Today I added almost
all primitive numeric operations + equality/inequality operations +
unit tests. jsc does not yet support nested functions, callbacks, or
closures. It supports &lt;code&gt;while&lt;/code&gt; loops but not
yet &lt;code&gt;for&lt;/code&gt; loops. And I'm not sure if it supports &lt;code&gt;else
if&lt;/code&gt;. It does not support arrays or objects let alone
constructors and prototypes. Adding support for these is low-hanging
fruit.&lt;/p&gt;
&lt;p&gt;After the low-hanging fruit, more interesting projects for jsc include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;generating C++ with embedded V8 rather than only targeting Node addons&lt;/li&gt;
&lt;li&gt;type inference or type hinting for generating unboxed functions a la Cython and SBCL&lt;/li&gt;
&lt;/ul&gt;
&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scheme.min.js"&gt;&lt;/script&gt;</description><guid isPermaLink="false">http://notes.eatonphil.com/compiling-dynamic-programming-languages.html</guid><pubDate>Sun, 02 Sep 2018 00:00:00 +0000</pubDate></item><item><title>btest: a language agnostic test runner</title><link>http://notes.eatonphil.com/btest-a-language-agnostic-test-runner.html</link><description>&lt;p&gt;&lt;a href="https://github.com/briansteffens/btest"&gt;btest&lt;/a&gt; is a minimal,
language-agnostic test runner originally written for testing
compilers. Brian, an ex- co-worker from Linode, wrote the first
implementation in &lt;a href="https://crystal-lang.org/"&gt;Crystal&lt;/a&gt; (a compiled
language clone of Ruby) for testing
&lt;a href="https://github.com/briansteffens/bshift"&gt;bshift&lt;/a&gt;, a compiler
project. The tool accomplished exactly what I needed for my own
language project, &lt;a href="https://github.com/eatonphil/bsdscheme"&gt;BSDScheme&lt;/a&gt;,
and had very few dependencies. After some issues with Crystal support
in containerized CI environments, and despite some incredible
&lt;a href="https://github.com/briansteffens/btest/pull/5"&gt;assistance from&lt;/a&gt; &lt;a href="https://github.com/briansteffens/btest/pull/4"&gt;the
Crystal community&lt;/a&gt;, we
rewrote btest in D to simplify downstream use.&lt;/p&gt;
&lt;h3 id="how-it-works"&gt;How it works&lt;/h3&gt;&lt;p&gt;btest registers a command (or commands) to run and verifies the
command output and status for different inputs. btest iterates over
files in a directory to discover test groups and individual tests
within. It supports a limited template language for easily adjusting a
more-or-less similar set of tests. And it supports running test groups
and individual tests themselves in parallel. All of this is managed
via a simple YAML config.&lt;/p&gt;
&lt;h3 id="btest.yaml"&gt;btest.yaml&lt;/h3&gt;&lt;p&gt;btest requires a project-level configuration file to declare the test
directory, the command(s) to run per test, etc. Let's say we want to
run tests against a python program. We create
a &lt;code&gt;btest.yaml&lt;/code&gt; file with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;test_path: tests

runners:
  - name: Run tests with cpython
    run: python test.py
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test_path&lt;/code&gt; is the directory in which tests are located.
&lt;code&gt;runners&lt;/code&gt; is an array of commands to run per test. We
hard-code a file to run &lt;code&gt;test.py&lt;/code&gt; as a project-level
standard file that will get written to disk in an appropriate path for
each test-case.&lt;/p&gt;
&lt;h4 id="on-multiple-runners"&gt;On multiple runners&lt;/h4&gt;&lt;p&gt;Using multiple runners is helpful when we want to run all tests with
different test commands or test command settings. For instance, we
could run tests against cpython and pypy by adding another runner to
the runners section.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;test_path: tests

runners:
  - name: Run tests with cpython
    run: python test.py
  - name: Run tests with pypy
    run: pypy test.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="an-example-test-config"&gt;An example test config&lt;/h3&gt;&lt;p&gt;Let's create a &lt;code&gt;divide-by-zero.yaml&lt;/code&gt; file in
the &lt;code&gt;tests&lt;/code&gt; directory and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs yaml"&gt;cases:
  - name: Should exit on divide by zero
    status: 1
    stdout: |
      Traceback (most recent call last):
        File &amp;quot;test.py&amp;quot;, line 1, in &amp;lt;module&amp;gt;
          4 / 0
      ZeroDivisionError: division by zero
    denominator: 0
templates:
  - test.py: |
      4 / {{ denominator }}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;name&lt;/code&gt; will be printed out when the test
is run. &lt;code&gt;status&lt;/code&gt; is the expected integer returned by
running the program. &lt;code&gt;stdout&lt;/code&gt; is the entire expected output
written by the program during execution. None of these three fields
are required. If &lt;code&gt;status&lt;/code&gt; or &lt;case&gt;stdout&lt;/case&gt; are not
provided, btest will skip checking them.&lt;/p&gt;
&lt;p&gt;Any additional key-value pairs are treated as template variable values
and will be substituted if/where it is referenced in the templates
section when the case is run. &lt;code&gt;denominator&lt;/code&gt; is the only
such variable we use in this example. When this first (and only) case
is run, &lt;code&gt;test.py&lt;/code&gt; will be written to disk
containing &lt;code&gt;4 / 0&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="templates-section"&gt;templates section&lt;/h4&gt;&lt;p&gt;The &lt;code&gt;templates&lt;/code&gt; section is a dictionary allowing us to
specify files to be created with variable substitution. All files are
created in the same directory per test case, so if we want to import
code we can do so with relative paths.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/eatonphil/bsdscheme/blob/master/tests/include.yaml"&gt;Here&lt;/a&gt;
is a simple example of a BSDScheme test that uses this feature.&lt;/p&gt;
&lt;h3 id="running-btest"&gt;Running btest&lt;/h3&gt;&lt;p&gt;Run btest from the root directory (the directory
above &lt;code&gt;tests&lt;/code&gt;) and we'll see all the grouped test cases
that btest registers and the result of each test:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ btest
tests/divide-by-zero.yaml
[PASS] Should exit on divide by zero

1 of 1 tests passed for runner: Run tests with cpython
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="use-in-ci-environments"&gt;Use in CI environments&lt;/h3&gt;&lt;p&gt;In the future we may provide pre-built release binaries. But in the
meantime, the CI step involves downloading git and ldc and
building/installing btest before calling it.&lt;/p&gt;
&lt;h4 id="circle-ci"&gt;Circle CI&lt;/h4&gt;&lt;p&gt;This is the
&lt;a href="https://github.com/eatonphil/bsdscheme/blob/master/.circleci/config.yml"&gt;config&lt;/a&gt;
file I use for testing BSDScheme:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: 2
jobs:
  build:
    docker:
      - image: dlanguage/ldc
    steps:
      - checkout
      - run:
          name: Install debian-packaged dependencies
          command: |
            apt update
            apt install -y git build-essential
            ln -s $(which ldc2) /usr/local/bin/ldc
      - run:
          name: Install btest
          command: |
            git clone https://github.com/briansteffens/btest
            cd btest
            make
            make install
      - run:
          name: Install bsdscheme
          command: |
            make
            make install
      - run:
          name: Run bsdscheme tests
          command: btest
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="travis-ci"&gt;Travis CI&lt;/h4&gt;&lt;p&gt;This is the
&lt;a href="https://github.com/briansteffens/bshift/blob/master/.travis.yml"&gt;config&lt;/a&gt;
Brian uses for testing BShift:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo: required

language: d

d:
    - ldc

script:
    # ldc gets installed as other names sometimes
    - sudo ln -s `which $DC` /usr/local/bin/ldc

    # bshift
    - make
    - sudo ln -s $PWD/bin/bshift /usr/local/bin/bshift
    - sudo ln -s $PWD/lib /usr/local/lib/bshift

    # nasm
    - sudo apt-get install -y nasm

    # basm
    - git clone https://github.com/briansteffens/basm
    - cd basm &amp;amp;&amp;amp; cabal build &amp;amp;&amp;amp; cd ..
    - sudo ln -s $PWD/basm/dist/build/basm/basm /usr/local/bin/basm

    # btest
    - git clone https://github.com/briansteffens/btest
    - cd btest &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install &amp;amp;&amp;amp; cd ..

    # run the tests
    - btest
&lt;/code&gt;&lt;/pre&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/btest-a-language-agnostic-test-runner.html</guid><pubDate>Sat, 04 Aug 2018 00:00:00 +0000</pubDate></item><item><title>Writing to be read</title><link>http://notes.eatonphil.com/writing-to-be-read.html</link><description>&lt;p&gt;There is a common struggle in the writing and maintenance of
documentation, checklists, emails, guides, etc. Each provides immense
value; a document may be the key to an important process. The goal is
to remove barriers -- to encourage understanding and correct
application of what has been noted -- without requiring a change in
the character of the reader. That is, expect reading to be difficult
and people to be lazy. &lt;strong&gt;Don't make things harder for your reader than
need be.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ignoring imperfections in the &lt;em&gt;ideas&lt;/em&gt; transcribed into writing, there
are a few particular aesthetic approaches I take to (hopefully) make
my notes more effective. These ideas have been influenced by readings
on writing, psychology, and user experience. In particular, I
recommend
&lt;a href="https://amzn.to/2rT0dsE"&gt;On Writing Well&lt;/a&gt;,
&lt;a href="https://amzn.to/2IttNAl"&gt;Thinking Fast and Slow&lt;/a&gt;,
and &lt;a href="https://www.nngroup.com/"&gt;Nielsen Norman&lt;/a&gt; research.&lt;/p&gt;
&lt;h3 id="language-correctness"&gt;Language correctness&lt;/h3&gt;&lt;p&gt;Spelling and grammatical correctness are low hanging fruit. They are
easy to achieve. Use full sentences, use punctuation, and capitalize
appropriately. But don't be a grammar stickler unreasonably; language
is flexible and always changing. Don't allow anyone the opportunity to
take your work less seriously by screwing up the basics.&lt;/p&gt;
&lt;h3 id="structuring-sentences-and-paragraphs"&gt;Structuring sentences and paragraphs&lt;/h3&gt;&lt;p&gt;Keep your sentences short. And avoid run on sentences; they are always
difficult to parse. If you use more than two commas in a sentences
(aside from in lists), the sentence is terrible. Split it up. Commas
are often used superfluously. Don't do that.&lt;/p&gt;
&lt;p&gt;Remember that if a comma separates two sentences, you can separate
them into two sentences with a period instead. And if you ever have a
list containing another list, separate the outer list with semi colons
instead of commas to provide better differentiation.&lt;/p&gt;
&lt;p&gt;Keep your paragraphs short too. In primary school you may have learned
to use 5-8 sentences per paragraph. Don't do so needlessly. 3-5
sentences can be perfectly appropriate. As both sentences and
paragraphs get longer, they appear more intimidating and can
discourage readers from continuing.&lt;/p&gt;
&lt;div class="note"&gt;
  &lt;header class="note-header"&gt;Visually speaking&lt;/header&gt;
  &lt;p&gt;
    Make your line height
    &lt;a href="https://practicaltypography.com/line-spacing.html"&gt;120-145%&lt;/a&gt;
    the height of the font. Increase the spacing between lines in a
    paragraph to make the paragraph less dense and more friendly.
  &lt;/p&gt;
  &lt;p&gt;
    Keep contrast high. Don't put very gray (or colored) text on a
    white background.
  &lt;/p&gt;
  &lt;p&gt;
    Additionally, a number of studies suggest that limiting the width
    of text increases readability. For best results, limit the width
    such
    that &lt;a href="https://baymard.com/blog/line-length-readability"&gt;50-75
    characters&lt;/a&gt; appear per line of text.
  &lt;/p&gt;
&lt;/div&gt;&lt;h4 id="don't-put-checklists-in-paragraphs"&gt;Don't put checklists in paragraphs&lt;/h4&gt;&lt;p&gt;If a document describes concrete steps that should be followed exactly
and can be reasonably summarized, don't hide the steps within
paragraphs of text. Instead use an ordered or unordered list to
clearly enumerate the expectations. &lt;strong&gt;You can't expect a checklist to
be followed when it is hidden within the sentences of a paragraph.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id="structuring-sections"&gt;Structuring sections&lt;/h3&gt;&lt;p&gt;Any document (regardless the type) longer than 3-5 paragraphs should
be broken into sub-sections with summarizing headers to aid
scanning. Use the HTML &lt;code&gt;id&lt;/code&gt; attribute to allow a direct link to a
particular section in a long page. If the page has more than two
sections or vertically flows beyond a single screen, consider adding a
table of contents at the top of the page to allow the reader to find
the exact section she needs.&lt;/p&gt;
&lt;div class="note"&gt;
  &lt;header class="note-header"&gt;Visually speaking&lt;/header&gt;
  &lt;p&gt;
    Don't put large headers immediately next to each other. It is
    disruptive to have multiple lines of large text.
  &lt;/p&gt;
  &lt;p&gt;
    I almost completely avoid Github Markdown's h1/# tag because it is
    just too large and jarring relative to the rest of the text. It is
    often best for the flow of a Github Markdown document to stick to
    only h3-h4/###-#### tags for headers, using the h2/## tag for the
    document title.
  &lt;/p&gt;
&lt;/div&gt;&lt;h3 id="in-summary"&gt;In summary&lt;/h3&gt;&lt;p&gt;The aesthetic flow of a document can help or hurt the experience of a
reader consuming it. Good aesthetic "sense" in this regard can be
boiled down to a few methods that primarily revolve around simplifying
structure and facilitating the rewarding feeling of progress as a
reader reads.&lt;/p&gt;
&lt;p&gt;Writing is difficult and takes time to evolve helpfully. The dividends
are paid when process is better followed and questions are readily
clarified in writing without further human intervention. It is
incumbent on those writing and maintaining to organize effectively and
see confusion of the reader as fault of the document, not fault of the
reader. It is easier to change something yourself than to expect
others to change to accommodate you.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-to-be-read.html</guid><pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate></item><item><title>Writing a simple JSON parser</title><link>http://notes.eatonphil.com/writing-a-simple-json-parser.html</link><description>&lt;p&gt;Writing a JSON parser is one of the easiest ways to get familiar with
parsing techniques. The format is extremely simple. It's defined
recursively so you get a slight challenge compared to, say, parsing
&lt;a href="https://en.wikipedia.org/wiki/Brainfuck"&gt;Brainfuck&lt;/a&gt;; and you probably
already use JSON. Aside from that last point, parsing
&lt;a href="https://en.wikipedia.org/wiki/S-expression"&gt;S-expressions&lt;/a&gt; for Scheme
might be an even simpler task.&lt;/p&gt;
&lt;p&gt;If you'd just like to see the code for the library, &lt;code&gt;pj&lt;/code&gt;, &lt;a href="https://github.com/eatonphil/pj"&gt;check it out
on Github&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="what-parsing-is-and-(typically)-is-not"&gt;What parsing is and (typically) is not&lt;/h3&gt;&lt;p&gt;Parsing is often broken up into two stages: lexical analysis and
syntactic analysis. Lexical analysis breaks source input into the
simplest decomposable elements of a language called "tokens".
Syntactic analysis (often itself called "parsing") receives the list
of tokens and tries to find patterns in them to meet the language
being parsed.&lt;/p&gt;
&lt;p&gt;Parsing does not determine semantic viability of an input
source. Semantic viability of an input source might include whether or
not a variable is defined before being used, whether a function is
called with the correct arguments, or whether a variable can be
declared a second time in some scope.&lt;/p&gt;
&lt;p class="note"&gt;
  There are, of course, always variations in how people choose to
  parse and apply semantic rules, but I am assuming a "traditional"
  approach to explain the core concepts.
&lt;/p&gt;&lt;h4 id="the-json-library's-interface"&gt;The JSON library's interface&lt;/h4&gt;&lt;p&gt;Ultimately, there should be a &lt;code&gt;from_string&lt;/code&gt; method that accepts a
JSON-encoded string and returns the equivalent Python dictionary.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;assert_equal(from_string('{"foo": 1}'),
             {"foo": 1})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="lexical-analysis"&gt;Lexical analysis&lt;/h3&gt;&lt;p&gt;Lexical analysis breaks down an input string into tokens. Comments and
whitespace are often discarded during lexical analysis so you are left
with a simpler input you can search for grammatical matches during the
syntactic analysis.&lt;/p&gt;
&lt;p&gt;Assuming a simple lexical analyzer, you might iterate over all the
characters in an input string (or stream) and break them apart into
fundemental, &lt;strong&gt;non-recursively&lt;/strong&gt; defined language constructs such as
integers, strings, and boolean literals. In particular, strings
&lt;strong&gt;must&lt;/strong&gt; be part of the lexical analysis because you cannot throw away
whitespace without knowing that it is not part of a string.&lt;/p&gt;
&lt;p class="note"&gt;
  In a helpful lexer you keep track of the whitespace and comments
  you've skipped, the current line number and file you are in so that
  you can refer back to it at any stage in errors produced by analysis
  of the source. &lt;a
  href="https://v8project.blogspot.com/2018/03/v8-release-66.html"&gt;The
  V8 Javascript engine recently became able to do reproduce the exact
  source code of a function.&lt;/a&gt; This, at the very least, would need
  the help of a lexer to make possible.
&lt;/p&gt;&lt;h4 id="implementing-a-json-lexer"&gt;Implementing a JSON lexer&lt;/h4&gt;&lt;p&gt;The gist of the JSON lexer will be to iterate over the input source
and try to find patterns of strings, numbers, booleans, nulls, or JSON
syntax like left brackets and left braces, ultimately returning
each of these elements as a list.&lt;/p&gt;
&lt;p&gt;Here is what the lexer should return for an example input:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;assert_equal(lex(&amp;#39;{&amp;quot;foo&amp;quot;: [1, 2, {&amp;quot;bar&amp;quot;: 2}]}&amp;#39;),
             [&amp;#39;{&amp;#39;, &amp;#39;foo&amp;#39;, &amp;#39;:&amp;#39;, &amp;#39;[&amp;#39;, 1, &amp;#39;,&amp;#39;, 2, &amp;#39;,&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;bar&amp;#39;, &amp;#39;:&amp;#39;, 2, &amp;#39;}&amp;#39;, &amp;#39;]&amp;#39;, &amp;#39;}&amp;#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is what this logic might begin to look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex(string):
    tokens = []

    while len(string):
        json_string, string = lex_string(string)
        if json_string is not None:
            tokens.append(json_string)
            continue

        # TODO: lex booleans, nulls, numbers

        if string[0] in JSON_WHITESPACE:
            string = string[1:]
        elif string[0] in JSON_SYNTAX:
            tokens.append(string[0])
            string = string[1:]
        else:
            raise Exception(&amp;#39;Unexpected character: {}&amp;#39;.format(string[0]))

    return tokens
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The goal here is to try to match strings, numbers, booleans, and nulls
and add them to the list of tokens. If none of these match, check if
the character is whitespace and throw it away if so. Otherwise store
it as a token if it is part of JSON syntax (like left
brackets). Finally throw an exception if the character/string didn't
match any of these patterns.&lt;/p&gt;
&lt;p&gt;Let's extend the core logic here a little bit to support all the types
and add the function stubs.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex_string(string):
    return None, string


def lex_number(string):
    return None, string


def lex_bool(string):
    return None, string


def lex_null(string):
    return None, string


def lex(string):
    tokens = []

    while len(string):
        json_string, string = lex_string(string)
        if json_string is not None:
            tokens.append(json_string)
            continue

        json_number, string = lex_number(string)
        if json_number is not None:
            tokens.append(json_number)
            continue

        json_bool, string = lex_bool(string)
        if json_bool is not None:
            tokens.append(json_bool)
            continue

        json_null, string = lex_null(string)
        if json_null is not None:
            tokens.append(None)
            continue

        if string[0] in JSON_WHITESPACE:
            string = string[1:]
        elif string[0] in JSON_SYNTAX:
            tokens.append(string[0])
            string = string[1:]
        else:
            raise Exception(&amp;#39;Unexpected character: {}&amp;#39;.format(string[0]))

    return tokens
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="lexing-strings"&gt;Lexing strings&lt;/h4&gt;&lt;p&gt;For the &lt;code&gt;lex_string&lt;/code&gt; function, the gist will be to check if the first
character is a quote. If it is, iterate over the input string until
you find an ending quote. If you don't find an initial quote, return
None and the original list. If you find an initial quote and an ending
quote, return the string within the quotes and the rest of the
unchecked input string.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex_string(string):
    json_string = &amp;#39;&amp;#39;

    if string[0] == JSON_QUOTE:
        string = string[1:]
    else:
        return None, string

    for c in string:
        if c == JSON_QUOTE:
            return json_string, string[len(json_string)+1:]
        else:
            json_string += c

    raise Exception(&amp;#39;Expected end-of-string quote&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="lexing-numbers"&gt;Lexing numbers&lt;/h4&gt;&lt;p&gt;For the &lt;code&gt;lex_number&lt;/code&gt; function, the gist will be to iterate over the
input until you find a character that cannot be part of a number.
(This is, of course, a gross simplification, but being more accurate
will be left as an exercise to the reader.) After finding a character
that cannot be part of a number, either return a float or int if the
characters you've accumulated number more than 0. Otherwise return
None and the original string input.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex_number(string):
    json_number = &amp;#39;&amp;#39;

    number_characters = [str(d) for d in range(0, 10)] + [&amp;#39;-&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;.&amp;#39;]

    for c in string:
        if c in number_characters:
            json_number += c
        else:
            break

    rest = string[len(json_number):]

    if not len(json_number):
        return None, string

    if &amp;#39;.&amp;#39; in json_number:
        return float(json_number), rest

    return int(json_number), rest
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="lexing-booleans-and-nulls"&gt;Lexing booleans and nulls&lt;/h4&gt;&lt;p&gt;Finding boolean and null values is a very simple string match.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def lex_bool(string):
    string_len = len(string)

    if string_len &amp;gt;= TRUE_LEN and \
       string[:TRUE_LEN] == &amp;#39;true&amp;#39;:
        return True, string[TRUE_LEN:]
    elif string_len &amp;gt;= FALSE_LEN and \
         string[:FALSE_LEN] == &amp;#39;false&amp;#39;:
        return False, string[FALSE_LEN:]

    return None, string


def lex_null(string):
    string_len = len(string)

    if string_len &amp;gt;= NULL_LEN and \
       string[:NULL_LEN] == &amp;#39;null&amp;#39;:
        return True, string[NULL_LEN]

    return None, string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now the lexer code is done! See the
&lt;a href="https://github.com/eatonphil/pj/blob/master/pj/lexer.py"&gt;pj/lexer.py&lt;/a&gt;
for the code as a whole.&lt;/p&gt;
&lt;h3 id="syntactic-analysis"&gt;Syntactic analysis&lt;/h3&gt;&lt;p&gt;The syntax analyzer's (basic) job is to iterate over a one-dimensional
list of tokens and match groups of tokens up to pieces of the language
according to the definition of the language. If, at any point during
syntactic analysis, the parser cannot match the current set of tokens up
to a valid grammar of the language, the parser will fail and possibly
give you useful information as to what you gave, where, and what it
expected from you.&lt;/p&gt;
&lt;h4 id="implementing-a-json-parser"&gt;Implementing a JSON parser&lt;/h4&gt;&lt;p&gt;The gist of the JSON parser will be to iterate over the tokens
received after a call to &lt;code&gt;lex&lt;/code&gt; and try to match the tokens to objects,
lists, or plain values.&lt;/p&gt;
&lt;p&gt;Here is what the parser should return for an example input:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;tokens = lex(&amp;#39;{&amp;quot;foo&amp;quot;: [1, 2, {&amp;quot;bar&amp;quot;: 2}]}&amp;#39;)
assert_equal(tokens,
             [&amp;#39;{&amp;#39;, &amp;#39;foo&amp;#39;, &amp;#39;:&amp;#39;, &amp;#39;[&amp;#39;, 1, &amp;#39;,&amp;#39;, 2, &amp;#39;{&amp;#39;, &amp;#39;bar&amp;#39;, &amp;#39;:&amp;#39;, 2, &amp;#39;}&amp;#39;, &amp;#39;]&amp;#39;, &amp;#39;}&amp;#39;])
assert_equal(parse(tokens),
             {&amp;#39;foo&amp;#39;: [1, 2, {&amp;#39;bar&amp;#39;: 2}]})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is what this logic might begin to look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse_array(tokens):
    return [], tokens

def parse_object(tokens):
    return {}, tokens

def parse(tokens):
    t = tokens[0]

    if t == JSON_LEFTBRACKET:
        return parse_array(tokens[1:])
    elif t == JSON_LEFTBRACE:
        return parse_object(tokens[1:])
    else:
        return t, tokens[1:]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A key structural difference between this lexer and parser is that the
lexer returns a one-dimensional array of tokens. Parsers are often
defined recursively and returns a recursive, tree-like object. Since
JSON is a data serialization format instead of a language, the parser
should produce objects in Python rather than a syntax tree on which
you could perform more analysis (or code generation in the case of a
compiler).&lt;/p&gt;
&lt;p&gt;And, again, the benefit of having the lexical analysis happen
independent from the parser is that both pieces of code are simpler
and concerned with only specific elements.&lt;/p&gt;
&lt;h4 id="parsing-arrays"&gt;Parsing arrays&lt;/h4&gt;&lt;p&gt;Parsing arrays is a matter of parsing array members and expecting a
comma token between them or a right bracket indicating the end
of the array.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse_array(tokens):
    json_array = []

    t = tokens[0]
    if t == JSON_RIGHTBRACKET:
        return json_array, tokens[1:]

    while True:
        json, tokens = parse(tokens)
        json_array.append(json)

        t = tokens[0]
        if t == JSON_RIGHTBRACKET:
            return json_array, tokens[1:]
        elif t != JSON_COMMA:
            raise Exception(&amp;#39;Expected comma after object in array&amp;#39;)
        else:
            tokens = tokens[1:]

    raise Exception(&amp;#39;Expected end-of-array bracket&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="parsing-objects"&gt;Parsing objects&lt;/h4&gt;&lt;p&gt;Parsing objects is a matter of parsing a key-value pair internally
separated by a colon and externally separated by a comma until you
reach the end of the object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def parse_object(tokens):
    json_object = {}

    t = tokens[0]
    if t == JSON_RIGHTBRACE:
        return json_object, tokens[1:]

    while True:
        json_key = tokens[0]
        if type(json_key) is str:
            tokens = tokens[1:]
        else:
            raise Exception(&amp;#39;Expected string key, got: {}&amp;#39;.format(json_key))

        if tokens[0] != JSON_COLON:
            raise Exception(&amp;#39;Expected colon after key in object, got: {}&amp;#39;.format(t))

        json_value, tokens = parse(tokens[1:])

        json_object[json_key] = json_value

        t = tokens[0]
        if t == JSON_RIGHTBRACE:
            return json_object, tokens[1:]
        elif t != JSON_COMMA:
            raise Exception(&amp;#39;Expected comma after pair in object, got: {}&amp;#39;.format(t))

        tokens = tokens[1:]

    raise Exception(&amp;#39;Expected end-of-object brace&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now the parser code is done! See the
&lt;a href="https://github.com/eatonphil/pj/blob/master/pj/parser.py"&gt;pj/parser.py&lt;/a&gt;
for the code as a whole.&lt;/p&gt;
&lt;h3 id="unifying-the-library"&gt;Unifying the library&lt;/h3&gt;&lt;p&gt;To provide the ideal interface, create the &lt;code&gt;from_string&lt;/code&gt; function
wrapping the &lt;code&gt;lex&lt;/code&gt; and &lt;code&gt;parse&lt;/code&gt; functions.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs python"&gt;def from_string(string):
    tokens = lex(string)
    return parse(tokens)[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the library is complete! (ish). Check out the &lt;a href="https://github.com/eatonphil/pj"&gt;project on
Github&lt;/a&gt; for the full implementation
including basic testing setup.&lt;/p&gt;
&lt;h3 id="appendix-a:-single-step-parsing"&gt;Appendix A: Single-step parsing&lt;/h3&gt;&lt;p&gt;Some parsers choose to implement lexical and syntactic analysis in one
stage. For some languages this can simplify the parsing stage
entirely. Or, in more powerful languages like Common Lisp, it can
allow you to dynamically extend the lexer and parser in one step with
&lt;a href="https://gist.github.com/chaitanyagupta/9324402"&gt;reader macros&lt;/a&gt;.&lt;/p&gt;
&lt;p class="note"&gt;
  I wrote this library in Python to make it more accessible to
  a larger audience. However, many of the techniques used are more
  amenable to languages with pattern matching and support for monadic
  operations -- like Standard ML. If you are curious what this same
  code would look like in Standard ML, check out the &lt;a
  href="https://github.com/eatonphil/ponyo/blob/master/src/Encoding/Json.sml"&gt;JSON
  code in Ponyo&lt;/a&gt;.
&lt;/p&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I wrote a short post (and a corresponding Python library) explaining lexing and parsing with JSON &lt;a href="https://t.co/3yEZlcU6i5"&gt;https://t.co/3yEZlcU6i5&lt;/a&gt; &lt;a href="https://t.co/FbksvUO9aT"&gt;https://t.co/FbksvUO9aT&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/json?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#json&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/python?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#python&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/993251098931712005?ref_src=twsrc%5Etfw"&gt;May 6, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/writing-a-simple-json-parser.html</guid><pubDate>Sun, 06 May 2018 00:00:00 +0000</pubDate></item><item><title>Finishing up a FreeBSD experiment</title><link>http://notes.eatonphil.com/finishing-up-a-freebsd-experiment.html</link><description>&lt;p&gt;I've been using FreeBSD as my daily driver at work since
December. I've successfully done my job and I've learned a hell of a
lot forcing myself on CURRENT... But there's been a number of issues
with it that have made it difficult to keep using, so I replaced it
with Arch Linux yesterday and I no longer have those issues. This is
not the first time I've forced myself to run FreeBSD and it won't be
the last.&lt;/p&gt;
&lt;h3 id="the-freebsd-setup"&gt;The FreeBSD setup&lt;/h3&gt;&lt;p&gt;I have a Dell Developer Edition. It employs full-disk encryption with
ZFS. Not being a "disk-jockey" I cannot comment on how exhilarating an
experience running ZFS is. It didn't cause me any trouble.&lt;/p&gt;
&lt;p&gt;It has an Intel graphics card and the display server is X. I use the
&lt;a href="https://stumpwm.github.io"&gt;StumpWM&lt;/a&gt; window manager and
the &lt;a href="https://github.com/iwamatsu/slim"&gt;SLiM&lt;/a&gt; login
manager. &lt;a href="https://www.jwz.org/xscreensaver/"&gt;xscreensaver&lt;/a&gt; handles
locking the screen, &lt;a href="https://feh.finalrewind.org/"&gt;feh&lt;/a&gt; gives me
background images, &lt;a href="https://github.com/dreamer/scrot"&gt;scrot&lt;/a&gt; gives me
screenshots, and
&lt;a href="http://recordmydesktop.sourceforge.net/about.php"&gt;recordMyDesktop&lt;/a&gt;
gives me video screen capture. This list should feel familiar to users
of Arch Linux or other X-supported, bring-your-own-software operating
systems/Linux distributions.&lt;/p&gt;
&lt;h4 id="software-development"&gt;Software development&lt;/h4&gt;&lt;p&gt;I primarily work on a web application with Node/PostgreSQL and React/SASS.
I do all of this development locally on FreeBSD. I run other components of
our system in a Vagrant-managed VirtualBox virtual machine.&lt;/p&gt;
&lt;h4 id="upgrading-the-system"&gt;Upgrading the system&lt;/h4&gt;&lt;p&gt;Since I'm running CURRENT, I fetch the latest commit on Subversion and
rebuild the FreeBSD system (kernel + user-land) each weekend to get
the new hotness. This takes somewhere between 1-4 hours. I start the
process Sunday morning and come back to it after lunch. After the
system is compiled and installed, I update all the packages through
the package manager and deal with fallout from incompatible kernel
modules that send me in a crash/reboot loop on boot.&lt;/p&gt;
&lt;p&gt;This is actually the part about running FreeBSD (CURRENT) I love the
most. I've gotten more familiar with the development and distribution
of kernel modules like the WiFi, Graphics, and VirtualBox
drivers. I've learned a lot about the organization of the FreeBSD
source code. And I've gotten some improvements
&lt;a href="https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=226015"&gt;merged&lt;/a&gt;
into the FreeBSD Handbook on how to debug a core dump.&lt;/p&gt;
&lt;h3 id="issues-with-freebsd-on-my-hardware"&gt;Issues with FreeBSD on my hardware&lt;/h3&gt;&lt;p&gt;I installed CURRENT in December to get support for new Intel graphics
drivers (which have since been backported to STABLE). The built-in
Intel WiFi card is also new enough that it hadn't been backported to
STABLE. My WiFi ultimately never got more than 2-4Mbps down on the
same networks my Macbook Pro would get 120-250Mbps down. I even bought
an older Realtek USB WiFi adapter and it fared no differently. My
understanding is that this is because CURRENT turns on enough debug
flags that the entire system is not really meant to be used except for
by FreeBSD developers.&lt;/p&gt;
&lt;p&gt;It would often end up taking 10-30 seconds for a &lt;code&gt;git push&lt;/code&gt; to
happen. It would take minutes to pull new Docker images, etc. This
(like everything else) does not mean you cannot do work on FreeBSD
CURRENT, it makes it really annoying.&lt;/p&gt;
&lt;h4 id="appendix-a---headphones"&gt;Appendix A - Headphones&lt;/h4&gt;&lt;p&gt;I couldn't figure out the headphone jack at all. Configuring outputs
via &lt;code&gt;sysctl&lt;/code&gt; and &lt;code&gt;device.hints&lt;/code&gt; is either really complicated or
presented in documentation really complicatedly. I posted a few times
in #freebsd on Freenode and got eager assistance but ultimately
couldn't get the headphone jack to produce anything without incredible
distortion.&lt;/p&gt;
&lt;p&gt;Of course Spotify has no FreeBSD client and I didn't want to try the
Linux compatiblity layer (which may have worked). I tried spoofing
user agents for the Spotify web app in Chrome but couldn't find one
that worked. (I still cannot get a working one on Linux either.) So
I'd end up listening to Spotify on my phone, which would have been
acceptable except for that the studio headphones I decided I needed
were immensely under-powered by my phone.&lt;/p&gt;
&lt;h4 id="appendix-b---yubikey"&gt;Appendix B - Yubikey&lt;/h4&gt;&lt;p&gt;I couldn't figure out how to give myself non-root access to my Yubikey
which I &lt;em&gt;believe&lt;/em&gt; is the reason I ultimately wasn't able to make any
use of it. Though admittedly I don't understand a whit of GPG/PGP or
Yubikey itself.&lt;/p&gt;
&lt;h4 id="appendix-c---bhyve"&gt;Appendix C - bhyve&lt;/h4&gt;&lt;p&gt;I really wanted to use
&lt;a href="https://www.freebsd.org/doc/handbook/virtualization-host-bhyve.html"&gt;bhyve&lt;/a&gt;
as the hypervisor for my CentOS virtual machines instead of
VirtualBox. So I spent 2-3 weekends trying to get it working as a
backend for Vagrant. Unfortunately the best "supported" way of doing
this is to manually mutate VirtualBox-based Vagrant boxes and that
just repeatedly didn't work for me.&lt;/p&gt;
&lt;p&gt;When I tried using bhyve directly I couldn't get networking
right. Presumably this is because NAT doesn't work well with wireless
interfaces... And I hadn't put in enough weekends to understand
setting up proxy rules correctly.&lt;/p&gt;
&lt;h4 id="appendix-d---synaptics"&gt;Appendix D - Synaptics&lt;/h4&gt;&lt;p&gt;It is my understanding that FreeBSD has its own custom Synaptics
drivers and configuration interfaces. Whether that is the case or not,
the documentation is a nightmare and while I would have loved to punt
to a graphical interface to prevent from fat-palming the touchpad
every 30 seconds, none of the graphical configuration tools seemed to
work.&lt;/p&gt;
&lt;p&gt;A few weeks ago I think I finally got the synaptics support &lt;em&gt;on&lt;/em&gt; but I
couldn't scroll or select text anymore. I also had to disable
synaptics, restart X, enable synaptics, and restart X on each boot for
it to successfully register the mouse. I meant to post in #freebsd on
Freenode where I probably would have found a solution but :shrugs:.&lt;/p&gt;
&lt;h4 id="appendix-e---sleep"&gt;Appendix E - Sleep&lt;/h4&gt;&lt;p&gt;Well sleep doesn't really work on any modern operating system.&lt;/p&gt;
&lt;h3 id="freebsd-is-awesome"&gt;FreeBSD is awesome&lt;/h3&gt;&lt;p&gt;I enjoy picking on my setup, but it should be impressive that you can
do real-world work on FreeBSD. If I had a 3-4 year old laptop instead
of a 1-2 year old laptop, most of my issues would be solved.&lt;/p&gt;
&lt;p&gt;Here are some reasons to like FreeBSD.&lt;/p&gt;
&lt;h4 id="less-competition"&gt;Less competition&lt;/h4&gt;&lt;p&gt;This is kind of stupid. But it's easier to find work to do (e.g. docs
to fix, bugs to report, ports to add/update, drivers to test) on
FreeBSD. I'm really disappointed to be back on Linux because I like
being closer to the community and knowing there are ways I can
contribute and learn. It's difficult to find the right combination of
fending/learning for yourself and achieving a certain level of
productivity.&lt;/p&gt;
&lt;h4 id="package-management-(culture)"&gt;Package management (culture)&lt;/h4&gt;&lt;p&gt;Rolling packages are really important to me as a developer. When I've
run Ubuntu and Debian desktops in the past, I typically built 5-15
major (to my workflow) components from source myself. This is
annoying. Rolling package systems are both easier to use and easier to
contribute to... The latter point may be a coincidence.&lt;/p&gt;
&lt;p&gt;In FreeBSD, packages are rolling and the base system (kernel +
userland) is released every year or two if you run the
recommended/supported "flavors" of FreeBSD (i.e. not CURRENT). If
you're running CURRENT then everything is rolling.&lt;/p&gt;
&lt;p&gt;Packages are binary, but you can build them from source if needed.&lt;/p&gt;
&lt;h4 id="source"&gt;Source&lt;/h4&gt;&lt;p&gt;FreeBSD has an older code base than Linux does but still manages to be
much better organized. OpenBSD and Minix are even better organized but
I don't consider them in the grouping as mainstream general-purpose
operating systems like FreeBSD and Linux. Linux is an awful mess
and is very intimidating, though I hope to get over that.&lt;/p&gt;
&lt;h4 id="old-school-interfaces"&gt;Old-school interfaces&lt;/h4&gt;&lt;p&gt;There's no systemd so starting X is as simple as &lt;code&gt;startx&lt;/code&gt; (but you can
enable the login manager service to have it launch on boot). You
configure your network interfaces via &lt;code&gt;ifconfig&lt;/code&gt;, &lt;code&gt;wpa_supplicant&lt;/code&gt;,
and &lt;code&gt;dhclient&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="alternatives"&gt;Alternatives&lt;/h4&gt;&lt;p&gt;&lt;a href="https://www.trueos.org/"&gt;PCBSD or TrueOS&lt;/a&gt; may be a good option for
desktop users but something about the project turns me off (maybe it's
the scroll-jacking website).&lt;/p&gt;
&lt;h3 id="picking-arch-linux"&gt;Picking Arch Linux&lt;/h3&gt;&lt;p&gt;In any case, I decided it was time to stop waiting for &lt;code&gt;git push&lt;/code&gt; to
finish. I had run Gentoo at work for 3-4 months before I installed
FreeBSD. But I still had nightmares of resolving dependencies during
upgrades. I needed a binary package manager (not hard to find) and a
rolling release system.&lt;/p&gt;
&lt;h4 id="installing-arch-stinks"&gt;Installing Arch stinks&lt;/h4&gt;&lt;p&gt;Many of my old coworkers at Linode run Arch Linux at home so I've
looked into it a few times. It absolutely meets my rolling release and
binary packaging needs. But I've been through the installation once
before (and I've been through Gentoo's) and loathed the minutes-long
effort required to set up full-disk encryption. Also, systemd? :(&lt;/p&gt;
&lt;h4 id="how-about-void-linux?"&gt;How about Void Linux?&lt;/h4&gt;&lt;p&gt;Void Linux looked promising and avoids systemd (which legitimately
adds complexity and new tools to learn for desktop users with graphics
and WiFi/DHCP networking). It has a rolling release system and binary
packages, but overall didn't seem popular enough. I worried I'd be in
the same boat as in Debian/Ubuntu building lots of packages myself.&lt;/p&gt;
&lt;h4 id="what-about-arch-based-distros?"&gt;What about Arch-based distros?&lt;/h4&gt;&lt;p&gt;Eventually I realized &lt;a href="http://antergos.com/"&gt;Antergos&lt;/a&gt; and
&lt;a href="https://manjaro.org/"&gt;Manjaro&lt;/a&gt; are two (Distrowatch-rated) popular
distributions that are based on Arch and would provide me with the
installer I really wanted. I read more about Manjaro and found it was
pretty divergent from Arch. That didn't sound appealing. Divergent
distributions like Manjaro and Mint exist to cause trouble. Antergos,
on the other hand, seemed to be a thin layer around Arch including a
graphical installer and its own few package repositories. It seemed
easy enough to remove after the installation was finished.&lt;/p&gt;
&lt;h3 id="antergos-linux"&gt;Antergos Linux&lt;/h3&gt;&lt;p&gt;I ran the Antergos installer and the first time around, my touchpad
didn't work at all. I tried a USB mouse (that to be honest, may have
been broken anyway) but it didn't seem to be recognized. I rebooted
and my touchpad worked.&lt;/p&gt;
&lt;p&gt;I tried to configure WiFi using the graphical NetworkManager provided
but it was super buggy. Menus kept expanding and contracting as I
moused over items. And it ultimately never prompted me for a password
to the locked networks around me. (It showed lock icons beside the
locked networks.)&lt;/p&gt;
&lt;p&gt;I spent half an hour trying to configure the WiFi manually. After I
got it working (and "learned" all the fun new modern tools like &lt;code&gt;ip&lt;/code&gt;,
&lt;code&gt;iw&lt;/code&gt;, &lt;code&gt;dhcpcd&lt;/code&gt;, &lt;code&gt;iwconfig&lt;/code&gt;, and systemd networking), the Antergos
installer would crash at the last step for some error related to not
being able to update itself.&lt;/p&gt;
&lt;p&gt;At this point I gave up. The Antergos installer was half-baked, buggy,
and was getting me nowhere.&lt;/p&gt;
&lt;h3 id="anarchy-linux"&gt;Anarchy Linux&lt;/h3&gt;&lt;p&gt;Still loathe to spend a few minutes configuring disk encryption
manually, I interneted until I found &lt;a href="https://anarchy-linux.org/"&gt;Anarchy
Linux&lt;/a&gt; (which used to be Arch Anywhere).&lt;/p&gt;
&lt;p&gt;This installer seemed even more promising. It is a TUI installer so no
need for a mouse and there are more desktop environments to pick from
(including i3 and Sway) or avoid.&lt;/p&gt;
&lt;p&gt;It was a little concerning that Anarchy Linux also intends to be its
own divergent Arch-based distribution, but in the meantime it still
offers support for installing vanilla Arch.&lt;/p&gt;
&lt;p&gt;It worked.&lt;/p&gt;
&lt;h3 id="life-on-arch"&gt;Life on Arch&lt;/h3&gt;&lt;p&gt;I copied over all my configs from my FreeBSD setup and they all
worked. That's pretty nice (also speaks to the general compatibility
of software between Linux and FreeBSD). StumpWM, SLiM, scrot,
xscreensaver, feh, Emacs, Tmux, ssh, kubectl, font settings,
keyboarding bindings, etc.&lt;/p&gt;
&lt;p&gt;Getting Powerline working was a little weird. The &lt;code&gt;powerline&lt;/code&gt; and
&lt;code&gt;powerline-fonts&lt;/code&gt; packages don't seem to install patched fonts
(e.g. &lt;code&gt;Noto Sans for Powerline&lt;/code&gt;). I prefer to use these than the
alternative of specifying multiple fonts for fallbacks because I have
font settings in multiple places (e.g. .Xresources, .emacs, etc) and
the syntax varies in each config. So ultimately I cloned the
&lt;code&gt;github.com/powerline/fonts&lt;/code&gt; repo and ran the &lt;code&gt;install.sh&lt;/code&gt; script
there to get the patched fonts.&lt;/p&gt;
&lt;p&gt;But hey, there's a Spotify client! It works! And the headphone jack
just works after installing &lt;code&gt;alsa-utils&lt;/code&gt; and running &lt;code&gt;alsamixer&lt;/code&gt;. And
my WiFi speed is 120Mbps-250Mbps down on all the right networks!&lt;/p&gt;
&lt;p&gt;I can live with this.&lt;/p&gt;
&lt;h3 id="random-background"&gt;Random background&lt;/h3&gt;&lt;p&gt;Each time I join a new company, I try to use the change as an excuse
to force myself to try different workflows and learn something new
tangential to the work I actually do. I'd been a Vim and Ubuntu
desktop user since highschool. In 2015, I took a break from work on
the East Coast to live in a school bus in Silver City, New Mexico. I
swapped out my Ubuntu and Vim dev setup for FreeBSD and Emacs. I kept
GNOME 3 because I liked the asthetic. I spent 6 months with this setup
forcing myself to use it as my daily-driver doing full-stack, contract
web development gigs.&lt;/p&gt;
&lt;p&gt;In 2016, I joined Linode and took up the company Macbook Pro. I wasn't
as comfortable at the time running Linux on my Macbook, but a
determined coworker put Arch on his. I was still the only one
running Emacs (everyone else used Vim or VS Code) for Python and React
development.&lt;/p&gt;
&lt;p&gt;I joined Capsule8 in late 2017 and put Gentoo on my Dell Developer
Edition. Most people ran Ubuntu on the Dell or macOS. I'd never used
Gentoo on a desktop before but liked the systemd-optional design and
similarities to FreeBSD. I ran Gentoo for 3-4 months but was
constantly breaking it during upgrades, and the monthly, full-system
upgrades themselves took 1-2 days. I didn't have the chops or patience
to deal with it.&lt;/p&gt;
&lt;p&gt;So I used FreeBSD for 5 months and now I'm back on Linux.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/finishing-up-a-freebsd-experiment.html</guid><pubDate>Sat, 28 Apr 2018 00:00:00 +0000</pubDate></item><item><title>Book Review: ANSI Common Lisp</title><link>http://notes.eatonphil.com/book-review-ansi-common-lisp.html</link><description>&lt;h4 id="score:-4.5-/-5"&gt;Score: 4.5 / 5&lt;/h4&gt;&lt;p&gt;Paul Graham and his editor(s) are excellent. His prose is light and
easy to follow. The only awkward component of the book's organization
is that he tends to use a concept one section before explicitly
introducing and defining that concept. I'm not sure yet if this is a
good or bad thing.&lt;/p&gt;
&lt;h3 id="as-a-learning-resource"&gt;As a learning resource&lt;/h3&gt;&lt;p&gt;Among books recommended to potential Lispers, &lt;em&gt;ANSI Common Lisp&lt;/em&gt; is
typically written off. Graham's style of Lisp is called
"non-idiomatic". That's fair, both &lt;em&gt;ANSI Common Lisp&lt;/em&gt; and &lt;em&gt;On Lisp&lt;/em&gt;
feature aspects of Common Lisp that lend themselves to functional
programming. And as those of you who've read &lt;em&gt;Practical Common Lisp&lt;/em&gt;
know, Common Lisp (unlike Scheme) was not designed to be a functional
programming language. Ultimately &lt;em&gt;ANSI Common Lisp&lt;/em&gt; covers the same
topics &lt;em&gt;Practical Common Lisp&lt;/em&gt; does, if not more. But &lt;em&gt;ANSI Common
Lisp&lt;/em&gt; is better written, in less space, and with shorter examples.&lt;/p&gt;
&lt;p&gt;I'm impressed at Graham's ability to summarize. There is a graphic
illustrating symbols as a structure composed of a name, a value, a
function, a package, and a property list. Although other resources
(books and otherwise) mention symbols as having one or more of these
components, his graphic was the first representation that clicked for
me. He also provides clarity about packages being namespaces for
&lt;em&gt;names&lt;/em&gt; (symbols) not objects or functions.&lt;/p&gt;
&lt;p&gt;And toward the end of the book, there is a discussion on the
"instance" abstraction (relative to the class definitions themselves)
being more powerful than plain "objects" that carry around methods
themselves. This has been the single most useful discussion on the
implementation of object-oriented constructs I've read yet.&lt;/p&gt;
&lt;h3 id="digression-on-practical-common-lisp"&gt;Digression on Practical Common Lisp&lt;/h3&gt;&lt;p&gt;&lt;em&gt;Practical Common Lisp&lt;/em&gt; is often called the best introduction to
Common Lisp. After reading both, I'd give &lt;em&gt;Practical Common Lisp&lt;/em&gt;
second place or call it a tie. The issue with &lt;em&gt;Practical Common Lisp&lt;/em&gt;
is that it takes too long to get anywhere and the practical chapters
themselves are just as much a slog. And for as big as it is,
&lt;em&gt;Practical Common Lisp&lt;/em&gt; still doesn't include some major (potentially
confusing) aspects of "modern" Common Lisp like ASDF, Quicklisp,
production deployment strategies, etc.&lt;/p&gt;
&lt;p&gt;Even after having read &lt;em&gt;Practical Common Lisp&lt;/em&gt; I wasn't really clear
how to pull together all the libraries I needed to get anything real
done (e.g. scripting against an HTTP API or interacting with a SQL
database). This is not to say that &lt;em&gt;Practical Common Lisp&lt;/em&gt; is a bad
book, it is a good book. But I definitely don't recommend reading it
without also reading &lt;em&gt;ANSI Common Lisp&lt;/em&gt;. And regardless, there are
still a few of those modern concepts neither book covers.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/book-review-ansi-common-lisp.html</guid><pubDate>Sun, 25 Mar 2018 00:00:00 +0000</pubDate></item><item><title>Starting a minimal Common Lisp project</title><link>http://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html</link><description>&lt;p&gt;If you've only vaguely heard of Lisp before or studied Scheme in
school, Common Lisp is nothing like what you'd expect. While
functional programming is all the rage in Scheme, Common Lisp was
"expressly designed to be a real-world engineering language rather
than a theoretically 'pure' language" (&lt;a href="http://www.gigamonkeys.com/book/introduction-why-lisp.html"&gt;Practical Common
Lisp&lt;/a&gt;).
Furthermore, &lt;a href="http://sbcl.org/"&gt;SBCL&lt;/a&gt; -- a popular implementation --
is a highly optimized compiler that is competitive with
&lt;a href="https://benchmarksgame.alioth.debian.org/u64q/lisp.html"&gt;Java&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="building-blocks"&gt;Building blocks&lt;/h3&gt;&lt;p&gt;Common Lisp symbols, imagine "first-class" variables/labels, are
encapsulated in namespaces called packages. However packages don't
account for organization across directories, among other things. So
while packages are a part of the core Common Lisp language, the
"cross-directory" organizational structure is managed by the
(all-but-standard) &lt;a href="https://github.com/fare/asdf"&gt;ASDF&lt;/a&gt; "systems". You
can think of packages as roughly similar to modules in Python whereas
systems in ASDF are more like packages in Python.&lt;/p&gt;
&lt;p&gt;ASDF does not manage non-local dependencies. For that we use
&lt;a href="https://www.quicklisp.org/beta/"&gt;Quicklisp&lt;/a&gt;, the defacto package
manager. ASDF should come bundled with your Common Lisp installation,
which I'll assume is SBCL (not that it matters). Quicklisp does not
come bundled.&lt;/p&gt;
&lt;h3 id="getting-quicklisp"&gt;Getting Quicklisp&lt;/h3&gt;&lt;p&gt;You can follow the notes on the Quicklisp
&lt;a href="https://www.quicklisp.org/beta/"&gt;site&lt;/a&gt; for installation, but the
basic gist is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs shell"&gt;$ curl -O https://beta.quicklisp.org/quicklisp.lisp
$ sbcl --load quicklisp.lisp
...
* (quicklisp-quickstart:install)
...
* ^D
$ sbcl --load &amp;quot;~/quicklisp/setup.lisp&amp;quot;
...
* (ql:add-to-init-file)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="a-minimal-package"&gt;A minimal package&lt;/h3&gt;&lt;p&gt;Now we're ready to get started. Create a directory using the name of
the library you'd like to package. For instance, I'll create a
"cl-docker" directory for my Docker wrapper library. Then create a
file using the same name in the directory with the ".asd" suffix:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs shell"&gt;$ cd ~/projects
$ mkdir cl-docker
$ touch cl-docker/cl-docker.asd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is important for the ".asd" file to share the same name as the
directory because ASDF will look for it in that location (by default).&lt;/p&gt;
&lt;p&gt;Before we get too far into packaging, let's write a function we'd like
to export from this library. Edit "cl-docker/docker.lisp" (this name does
not matter) and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defun ps ()
  (let ((output (uiop:run-program &amp;#39;(&amp;quot;docker&amp;quot; &amp;quot;ps&amp;quot;) :output :string)))
    (loop for line in (rest (cl-ppcre:split &amp;quot;(\\n+)&amp;quot; output))
      collect (cl-ppcre:split &amp;quot;(\\s\\s+)&amp;quot; line))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This uses a portable library, "uiop", that ASDF exposes by default (we
won't need to explicitly import this anywhere because the package is
managed by ASDF). It will run the command "docker ps" in a subprocess
and return the output as a string. Then we use the regex split
function from the "cl-ppcre" library to split the output first into
lines, take all but the first line, and split the lines up based one
two or more whitespace characters.&lt;/p&gt;
&lt;p&gt;Next let's define the package (think module in Python) by editing
"cl-docker/package.lisp" (this name also does not matter):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defpackage cl-docker
  (:use cl)
  (:import-from :cl-ppcre :split)
  (:export :ps))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we state the package's name, say that we want to import all
Common Lisp base symbols into the package, say we want to import the
"split" symbol from the "cl-ppcre" package, and say we only want to
export our "ps" function.&lt;/p&gt;
&lt;p&gt;At this point we must also declare within the "cl-docker/docker.lisp"
file that it is a part of this package:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(in-package :cl-docker)

(defun ps ()
  (let ((output (uiop:run-program &amp;#39;(&amp;quot;docker&amp;quot; &amp;quot;ps&amp;quot;) :output :string)))
    (loop for line in (rest (cl-ppcre:split &amp;quot;(\\n+)&amp;quot; output))
      collect (cl-ppcre:split &amp;quot;(\\s\\s+)&amp;quot; line))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next let's define the system (ASDF-level, similar to a package in Python)
in "cl-docker/cl-docker.asd":&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(defsystem :cl-docker
    :depends-on (:cl-ppcre)
    :serial t
    :components ((:file &amp;quot;package&amp;quot;)
                 (:file &amp;quot;docker&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This defines all the pieces of the system for ASDF: the system name,
the package definition and the component of the package
("cl-docker/docker.lisp"), and tells ASDF to make the "cl-ppcre"
system on disk available to us. We also tell ASDF to process the
components in the order we specified (otherwise it will pick an order
that may not be what we want).&lt;/p&gt;
&lt;p&gt;In preparation for times when we don't have the "cl-ppcre" system (or
any other dependencies) on disk, we always load the system indirectly
through Quicklisp (rather than directly via ASDF) so Quicklisp can
fetch any missing dependencies from its repository of systems.&lt;/p&gt;
&lt;p&gt;But before then -- unless you put this directory in "~/common-lisp" --
you'll need to register the directory containing the directory of your
system definitions so ASDF (and Quicklisp) know where to look if you
ask to load this system.&lt;/p&gt;
&lt;p&gt;To do this, add a ".conf" file to
"~/.config/common-lisp/source-registry.conf.d/" and add the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(:tree &amp;quot;~/path/to/dir/containing/system/dir&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So if you had a repo called "cl-docker" in your "~/projects" directory
that contained the "cl-docker" directory we previously created (that,
in turn, contains the "cl-docker.asd", "package.lisp", and
"docker.lisp" files) then you might create
"~/.config/common-lisp/source-registry.conf.d/1-cl-docker.conf" and
add:&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs lisp"&gt;(:tree &amp;quot;~/projects/cl-docker&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="using-the-system"&gt;Using the system&lt;/h4&gt;&lt;p&gt;Now you can use the library from anywhere on your computer. Enter a
Common Lisp REPL and tell Quicklisp to load the system (and download
any non-local dependencies):&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs shell"&gt;$ sbcl
...
* (ql:quickload &amp;quot;cl-docker&amp;quot;)
To load &amp;quot;cl-docker&amp;quot;:
  Load 1 ASDF system:
    cl-docker
; Loading &amp;quot;cl-docker&amp;quot;
..................................................
[package cl-docker]
(&amp;quot;cl-docker&amp;quot;)
* (cl-docker:ps)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it!&lt;/p&gt;
&lt;p&gt;For the complete source of this example package, check out this
&lt;a href="https://gist.github.com/eatonphil/59cdfeb4826c7a12a07d7055f6817a56"&gt;Gist&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id="in-conclusion"&gt;In conclusion&lt;/h3&gt;&lt;p&gt;Common Lisp is easy to work with, the packages are many and mature.
Configuring an ASDF package is even simpler than configuring a Python
"setup.py". I didn't demonstrate pinning versions of dependencies in
ASDF, but &lt;a href="https://stackoverflow.com/a/21663603/1507139"&gt;of course&lt;/a&gt;
you can do that too. If any of this -- as simple as it is -- seems
tedious, you can also use Zach Beane's (creator of Quicklisp)
&lt;a href="http://xach.livejournal.com/278047.html"&gt;quickproject&lt;/a&gt; tool to build
out the structure for you.&lt;/p&gt;
&lt;h3 id="resources-for-common-lisp"&gt;Resources for Common Lisp&lt;/h3&gt;&lt;p&gt;You must read &lt;a href="http://www.gigamonkeys.com/book/"&gt;Practical Common
Lisp&lt;/a&gt;. It is freely available
online. It is one of the best resources I keep referring to in
dealing with simple issues (as a new Lisper, I stumble on a lot of
simple issues).&lt;/p&gt;
&lt;p&gt;Paul Graham's &lt;a href="http://www.paulgraham.com/onlisp.html"&gt;On Lisp&lt;/a&gt; is also
a must-read when you want to get a better understanding of macros in
Lisp. It will help you out with macros in Scheme too. This book is
freely available online, but out of print physically. I sent
&lt;a href="https://www.lulu.com/"&gt;Lulu&lt;/a&gt; the PDF and I received my physical copy
for under $20 (including shipping).&lt;/p&gt;
&lt;p&gt;I'm currently making my way through &lt;a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html"&gt;Common Lisp the Language, 2nd
Edition&lt;/a&gt; which I
believe is also freely available online. However I don't really
recommend this unless you are interested in implementing Common Lisp
or are dying to learn the standard library (not a bad idea).&lt;/p&gt;
&lt;p&gt;Finally, Peter Norvig's &lt;a href="https://github.com/norvig/paip-lisp"&gt;Paradigms of Artificial Intelligence
Programming&lt;/a&gt; just recently became
freely available online. I haven't yet read it but I'm queuing it
up. Don't let the title scare you, apparantly it is primarily
considered a practical guide to Common Lisp around
old-school/classical AI that isn't supposed to encumber.&lt;/p&gt;
&lt;p class="note"&gt;
  It
  was &lt;a href="https://twitter.com/HexstreamSoft/status/971419419862847494"&gt;pointed
  out&lt;/a&gt; on Twitter that Paul
  Graham's &lt;a href="http://www.paulgraham.com/acl.html"&gt;ANSI Common
  Lisp&lt;/a&gt; and the
  &lt;a href="http://www.lispworks.com/documentation/lw70/CLHS/Front/Contents.htm"&gt;CLHS&lt;/a&gt;
  are probably better resources for the Common Lisp that exists today
  than Common Lisp the Language 2. CLtL2 is pre-standard.
&lt;/p&gt;&lt;p&gt;Additionally, the &lt;a href="http://lispcookbook.github.io/cl-cookbook/"&gt;Common Lisp
Cookbook&lt;/a&gt; is a great
resource for Common Lisp recipes. It's been around since 2004 (on
Sourceforge) but has been pretty active recently and has been revived
on Github pages.&lt;/p&gt;
&lt;h3 id="on-scheme"&gt;On Scheme&lt;/h3&gt;&lt;p&gt;I've done one or two unremarkable web prototypes in &lt;a href="https://www.call-cc.org/"&gt;Chicken
Scheme&lt;/a&gt;, an R5RS/R7RS Scheme implementation.
I don't think Chicken Scheme is the best bet for the web (I'm mostly
biased to this topic) because it has no native-thread support and
there are lighter interpreters out there that are easier to embed
(e.g. in nginx). Chicken Scheme's "niche" is being a generally
high-quality implementation with a great &lt;a href="http://wiki.call-cc.org/chicken-projects/egg-index-4.html"&gt;collection of 3rd-party
libraries&lt;/a&gt;,
but it is also not the
&lt;a href="https://ecraven.github.io/r7rs-benchmarks/"&gt;fastest&lt;/a&gt; Scheme you could
choose.&lt;/p&gt;
&lt;p&gt;I've worked on a larger web prototype -- a Github issue reporting app
-- in &lt;a href="https://racket-lang.org/"&gt;Racket&lt;/a&gt;, a derivative of Scheme
R6RS. And I've blogged
&lt;a href="http://notes.eatonphil.com/walking-through-a-basic-racket-web-service.html"&gt;favorably&lt;/a&gt;
about Racket. It is a
&lt;a href="https://ecraven.github.io/r7rs-benchmarks/"&gt;high-performance&lt;/a&gt;
interpreter with a JIT compiler, has thread support, and is also well
known for its collection of &lt;a href="https://pkgs.racket-lang.org/"&gt;3rd-party
libaries&lt;/a&gt;. However the Racket ecosystem
&lt;a href="https://fare.livejournal.com/188429.html"&gt;suffers&lt;/a&gt; from the same
issues Haskell's does: libraries and bindings are primarily
proof-of-concept only; missing documentation, tests and use. Trying to
render "templatized" HTML (like Jinja allows for in Flask) without
using S-exp-based syntax was a nightmare.  (Read: there's space for
someone to write a good string templating library.)&lt;/p&gt;
&lt;h4 id="sorry,-racket"&gt;Sorry, Racket&lt;/h4&gt;&lt;p&gt;Last point on Racket (because it really is worth looking into),
debugging in that Github issue project was not fun. The backtraces
were mostly useless. Naively I assume this may have to do with the way
Racket optimizes and rewrites functions. I was often left with zero
context to find and correct my errors. But it could very well be I
was making poor use of Racket.&lt;/p&gt;
&lt;h4 id="on-the-other-hand"&gt;On the other hand&lt;/h4&gt;&lt;p&gt;Common Lisp (its implementations and ecosystem) seems more robust and
developed. SBCL, with it's great performance and native-thread
support, is a promising candidate for backend web development.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I wrote a post on putting together a Common Lisp project. It&amp;#39;s easy! I also included some of my favorite CL books and a digression on Scheme. &lt;a href="https://t.co/2LEDoFnAjk"&gt;https://t.co/2LEDoFnAjk&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/commonlisp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#commonlisp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/lisp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#lisp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/scheme?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#scheme&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/971398435856371712?ref_src=twsrc%5Etfw"&gt;March 7, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/starting-a-minimal-common-lisp-project.html</guid><pubDate>Mon, 05 Mar 2018 00:00:00 +0000</pubDate></item><item><title>Interview with the D Language Blog: BSDScheme</title><link>http://notes.eatonphil.com/project-highlight-bsdscheme.html</link><description>&lt;head&gt;
    &lt;meta http-equiv="refresh" content="4;URL='https://dlang.org/blog/2018/01/20/project-highlight-bsdscheme/'" /&gt;
&lt;/head&gt;&lt;p&gt;This is an external post of mine. Click
&lt;a href="https://dlang.org/blog/2018/01/20/project-highlight-bsdscheme/"&gt;here&lt;/a&gt;
if you are not redirected.&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/project-highlight-bsdscheme.html</guid><pubDate>Sat, 20 Jan 2018 00:00:00 +0000</pubDate></item><item><title>First few hurdles writing a Scheme interpreter</title><link>http://notes.eatonphil.com/first-few-hurdles-writing-a-scheme-interpreter.html</link><description>&lt;p&gt;I started working on &lt;a href="https://github.com/eatonphil/bsdscheme"&gt;BSDScheme&lt;/a&gt; last October, inspired to get back
into language implementation after my coworker built &lt;a href="https://github.com/briansteffens/bshift"&gt;bshift&lt;/a&gt;, a
compiler for a C-like language. BSDScheme is an interpreter for a
(currently small subset of) Scheme written in D. It implements a few
substantial primitive &lt;a href="https://github.com/eatonphil/bsdscheme/blob/c49bb14182f04682a5cda4dd224b853b4fc92e92/src/runtime.d#L422"&gt;functions&lt;/a&gt; (in under 1000 LoC!). It uses the
same test framework bshift uses, &lt;a href="https://github.com/briansteffens/btest"&gt;btest&lt;/a&gt;. I'm going to expand here
on some notes I wrote in a &lt;a href="https://www.reddit.com/r/scheme/comments/7nvd1y/my_small_scheme_implementation_in_d/"&gt;post&lt;/a&gt; on Reddit on some issues I faced
during these first few months developing BSDSCheme.&lt;/p&gt;
&lt;p&gt;Before I get too far, here is a simple exponent function running in
BSDScheme. It demonstates a few of the basic builtin primitives and
also integers being upgraded to D's &lt;a href="https://dlang.org/phobos/std_bigint.html"&gt;std.bigint&lt;/a&gt; when an integer
operation produces an integer unable to fit in 64 bits. (See the
&lt;a href="https://github.com/eatonphil/bsdscheme/blob/b202e8b5a24fe4281a06e39241f2be3cd51720fc/src/runtime.d#L99"&gt;times&lt;/a&gt; and &lt;a href="https://github.com/eatonphil/bsdscheme/blob/b202e8b5a24fe4281a06e39241f2be3cd51720fc/src/runtime.d#L63"&gt;plus&lt;/a&gt; guards for details; see the &lt;a href="https://github.com/eatonphil/bsdscheme/tree/master/examples"&gt;examples&lt;/a&gt;
directory for other examples.)&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs shell"&gt;$ cat examples/recursion.scm
(define (exp base pow)
  (if (= pow 0)
      1
      (* base (exp base (- pow 1)))))

(display (exp 2 64))
(newline)
$ ./bin/bsdscheme examples/exp.scm
18446744073709551616
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first big correction I made was to the way values are represented
in memory. I originally implemented BSDScheme's value representation
as a &lt;a href="https://github.com/eatonphil/bsdscheme/pull/3/files#diff-653d5ccdaa287f13a3b2d964da52ab4aL284"&gt;struct&lt;/a&gt; with a pointer to each possible value type. This
design was simple to begin with but space-inefficient. I modelled a
&lt;a href="https://github.com/eatonphil/bsdscheme/pull/3"&gt;redesign&lt;/a&gt; after the &lt;a href="https://wiki.call-cc.org/man/4/Data%20representation"&gt;Chicken Scheme&lt;/a&gt; data representation. It
uses a struct with &lt;a href="https://github.com/eatonphil/bsdscheme/pull/3/files#diff-c586618fe7ea7c64340046e89fd82621R14"&gt;two fields&lt;/a&gt;, header and data. Both fields are
word-size integers (currently hard-coded as 64 bits). The header
stores type and length information and the data stores data.&lt;/p&gt;
&lt;p&gt;In this representation, simple types (integers &amp;lt; 2^63, booleans,
characters, etc.) take up only 128 bits. The integers, booleans, etc.
are placed directly into the 64 bit data field. Other types (larger
integers, strings, functions, etc) use the data field to store a
pointer to memory allocated in the heap. Getting the conversion of
these complex types right was the trickiest part of this data
representation effort... lots of void-pointer conversions.&lt;/p&gt;
&lt;p&gt;The next big fix I made was to simplify the way generic functions
dealt with their arguments. Originally I passed each function its
arguments un-evaluated and left it up to each function to evaluate its
arguments before operating on them. While there was nothing
intrinsically wrong with this method, it was overly complicated and
bug-prone. I refactored the builtin functions into two groups:
&lt;a href="https://github.com/eatonphil/bsdscheme/blob/c49bb14182f04682a5cda4dd224b853b4fc92e92/src/runtime.d#L422"&gt;normal&lt;/a&gt; functions and &lt;a href="https://github.com/eatonphil/bsdscheme/blob/c3286df73a32da657e780db8f33e845c9f806a9d/src/runtime.d#L435"&gt;special&lt;/a&gt; functions. Normal function
arguments are &lt;a href="https://github.com/eatonphil/bsdscheme/blob/c3286df73a32da657e780db8f33e845c9f806a9d/src/runtime.d#L399"&gt;evaluated&lt;/a&gt; before sending the arguments S-expression
to the function. Special functions receive the arguments S-expression
verbatim so they can decide what / when to evaluate.&lt;/p&gt;
&lt;p&gt;The last issue I'll talk about in this post was dealing with the AST
representation. When I started out, the easiest way to get things
working was to have an AST representation completely separate from the
representation of BSDScheme values. This won't get you far in
Scheme. In order to (eventually) support macros (and in the meantime
support eval), the AST representation would have to make use of the
value representation. This was the most complicated and confusing
issue so far in BSDScheme. With the switch to recursive data
structures, it was hard to know if an error occurred because I parsed
incorrectly, or recursed over what I parsed incorrectly, or even if I
was printing out what I parsed incorrectly. After some embarrassing
pain, I got all the &lt;a href="https://github.com/eatonphil/bsdscheme/pull/5"&gt;pieces in place&lt;/a&gt; after a month and it set me
up to easily support converting my original interpret function into a
generic eval function that I could expose to the language like any
other special function.&lt;/p&gt;
&lt;p&gt;One frustrating side-effect of this AST conversion is that since the
parsing stage builds out trees using the internal value
representation, the parsing stage is tied to the interpreter. From
what I can tell, this basically means I have to revert back to some
intermediate AST representation or throw away the parser to support a
compiler backend.&lt;/p&gt;
&lt;p&gt;Next steps in BSDScheme include converting all the examples into
tests, combining the needlessly split out lexing and parsing stage
into a single read function that can be exposed into the language,
fleshing out R7RS library support, and looking more into LLVM as a
backend.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Wrote a full post on the first few hurdles faced writing a Scheme interpreter in D &lt;a href="https://t.co/Cyjy7pk3OB"&gt;https://t.co/Cyjy7pk3OB&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/scheme?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#scheme&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/schemelang?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#schemelang&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/lisp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#lisp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/dlang?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dlang&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/951091952740651008?ref_src=twsrc%5Etfw"&gt;January 10, 2018&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/first-few-hurdles-writing-a-scheme-interpreter.html</guid><pubDate>Wed, 10 Jan 2018 00:00:00 +0000</pubDate></item><item><title>Deploying FreeBSD on Linode unattended in minutes</title><link>http://notes.eatonphil.com/deploying-freebsd-on-linode-unattended-in-minutes.html</link><description>&lt;p&gt;I became a FreeBSD user over 2 years ago when I wanted to see what all
the fuss was about. I swapped my y410p dual-booting Windows / Ubuntu
with FreeBSD running Gnome 3. I learned a lot during the transition
and came to appreciate FreeBSD as a user. I soon began running FreeBSD
as my OS of choice on cloud servers I managed. So naturally, when I
started working at Linode a year ago I wanted to run FreeBSD servers
on Linode too.&lt;/p&gt;
&lt;p&gt;Linode is a great platform for running random unofficial images
because you have much control over the configuration. I followed
&lt;a href="https://www.linode.com/docs/tools-reference/custom-kernels-distros/install-freebsd-on-linode/"&gt;existing&lt;/a&gt; &lt;a href="https://forum.linode.com/viewtopic.php?f=20&amp;amp;t=12080"&gt;guides&lt;/a&gt; closely and was soon able to get a number of
operating systems running on Linodes by installing them manually:
FreeBSD, OpenBSD, NetBSD, Minix3, and SmartOS to date.&lt;/p&gt;
&lt;p&gt;Unofficial images come at a cost though. In particular, I became
frustrated having to reinstall using the installer every time I
managed to trash the disk. So over the past year, I spent time trying
to understand the automated installation processes across different
operating systems and Linux distributions.&lt;/p&gt;
&lt;p&gt;Unattended installations are tough. The methods for doing them differ
wildly. On RedHat, Fedora, and CentOS there is &lt;a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/installation_guide/ch-kickstart2"&gt;Kickstart&lt;/a&gt;. On
Debian and Ubuntu there is &lt;a href="https://wiki.debian.org/DebianInstaller/Preseed"&gt;preseeding&lt;/a&gt;. Gentoo, Arch, and FreeBSD
don't particularly have a framework for unattended installs, but the
entire installation process is well-documented and inherently
scriptable (if you put in the effort). OpenBSD has
&lt;a href="http://man.openbsd.org/OpenBSD-6.0/man8/autoinstall.8"&gt;autoinstall&lt;/a&gt;. Trying to understand each and every one of these
potential installation methods was pretty defeating for getting
started on a side-project.&lt;/p&gt;
&lt;p&gt;A few weeks ago, I finally had the silly revelation that I didn't need
to script the installation process -- at least initially. I only had
to have working images available somewhere that could be copied to new
Linodes. Some OSs / distributions may provide these images, but there
is no guarantee that they exist or work. If I tested and hosted them
for Linodes, anyone could easily run their own copy.&lt;/p&gt;
&lt;p&gt;I began by running the installation process as normal for
FreeBSD. After the disk had FreeBSD installed on it, I rebooted into
&lt;a href="https://www.linode.com/docs/troubleshooting/rescue-and-rebuild/"&gt;Finnix&lt;/a&gt;, &lt;a href="https://wiki.archlinux.org/index.php/disk_cloning#Create_disk_image"&gt;made a compressed disk image&lt;/a&gt;, and transferred it to
an "image host" (another Linode in Fremont running an FTP
server). Then I tested the reversal process manually to make sure a
new Linode could grab the image, dd it to a disk, reboot and have a
working filesystem and networking. (This transfer occurs over private
networking to reduce bandwidth costs and thus limits Linode creation
to the datacenter of the image host, Fremont.)&lt;/p&gt;
&lt;p&gt;Then it was time to script the process. I looked into the existing
Linode API client wrappers and noticed none of them were
documented. So I took a day to write and document a good part of a
&lt;a href="https://github.com/eatonphil/python3-linode_api3"&gt;new Linode Python client&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I got to work and out came the &lt;a href="https://github.com/eatonphil/linode_deploy_experimental"&gt;linode-deploy-experimental&lt;/a&gt;
script. To run this script, you'll need an &lt;a href="https://www.linode.com/docs/platform/api/api-key/"&gt;API token&lt;/a&gt;. This
script will allow you to deploy from the hosted images (which now
include FreeBSD 11.0 and OpenBSD 6.0). Follow the example line in the
git repo and you'll have a Linode running OpenBSD or FreeBSD in
minutes.&lt;/p&gt;
&lt;p&gt;Clearly there's a lot of work to do on both this script and on the
images:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fremont datacenter has the only image host.&lt;/li&gt;
&lt;li&gt;The script does not change the default password: "password123".
You'll want to change this immediately.&lt;/li&gt;
&lt;li&gt;The script does not automatically grow the file system after
install.&lt;/li&gt;
&lt;li&gt;The TTY config for these images currently requires you to use
Glish instead of Weblish.&lt;/li&gt;
&lt;li&gt;And &lt;a href="https://github.com/eatonphil/linode_deploy_experimental/issues"&gt;more&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Even if many of these issues do get sorted out (I assume they will),
keep in mind that these are unofficial, unsupported images. Some
things will probably never work: backups, password reset, etc. If you
need help, you are probably limited to community support. You can also
find me with any questions (peaton on OFTC). But for me this is at
least a slight improvement on having to run through the install
process every time I need a new FreeBSD Linode.&lt;/p&gt;
&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Deploy FreeBSD and OpenBSD unattended on Linode &lt;a href="https://t.co/j5A46ROqNM"&gt;https://t.co/j5A46ROqNM&lt;/a&gt; &lt;a href="https://t.co/HSqrIvBMFj"&gt;https://t.co/HSqrIvBMFj&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/840736360864591872?ref_src=twsrc%5Etfw"&gt;March 12, 2017&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/deploying-freebsd-on-linode-unattended-in-minutes.html</guid><pubDate>Sat, 11 Mar 2017 00:00:00 +0000</pubDate></item><item><title>Walking through a basic Racket web service</title><link>http://notes.eatonphil.com/walking-through-a-basic-racket-web-service.html</link><description>&lt;p&gt;Racket is an impressive language and ecosystem. Compared to Python,
Racket (an evolution of Scheme &lt;a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)"&gt;R5RS&lt;/a&gt; is three years younger. It is
as concise and expressive as Python but with much more reasonable
syntax and semantics. Racket is also faster in many cases due in part
to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.racket-lang.org/guide/performance.html#%28part._.J.I.T%29"&gt;JIT compilation&lt;/a&gt; on x86 platforms&lt;/li&gt;
&lt;li&gt;support for both
&lt;a href="https://docs.racket-lang.org/reference/threads.html"&gt;concurrency&lt;/a&gt; and &lt;a href="https://docs.racket-lang.org/reference/places.html"&gt;parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;support for &lt;a href="https://docs.racket-lang.org/ts-guide/optimization.html"&gt;optimizing&lt;/a&gt; statically-typed code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furthermore, the built-in web server libraries &lt;strong&gt;and&lt;/strong&gt; database
drivers for MySQL and PostgreSQL are fully asynchronous. This last bit
drove me here from &lt;a href="https://www.playframework.com/documentation/2.6.x/ThreadPools#Knowing-when-you-are-blocking"&gt;Play / Akka&lt;/a&gt;.  (But strong reservations about
the complexity of Scala and the ugliness of Play in Java helped too.)&lt;/p&gt;
&lt;p&gt;With this motivation in mind, I'm going to break down the simple web
service &lt;a href="https://docs.racket-lang.org/web-server/stateless.html#%28part._stateless-example%29"&gt;example&lt;/a&gt; provided in the Racket manuals. If you don't see
the following code in the linked page immediately, scroll down a bit.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang web-server

(require web-server/http)

(provide interface-version stuffer start)

(define interface-version &amp;#39;stateless)

(define stuffer
  (stuffer-chain
   serialize-stuffer
   (md5-stuffer (build-path (find-system-path &amp;#39;home-dir) &amp;quot;.urls&amp;quot;))))

(define (start req)
  (response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!&amp;quot;)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First we notice the #lang declaration. Racket libraries love to make
new "languages". These languages can include some entirely new syntax
(like the &lt;a href="http://docs.racket-lang.org/algol60/"&gt;Algol language implementation&lt;/a&gt;) or can simply include a
summary collection of libraries and alternative program entrypoints
(such as this web-server language provides). So the first thing we'll
do to really understand this code is to throw out the custom
language. And while we're at it, we'll throw out all typical imports
provided by the &lt;a href="http://docs.racket-lang.org/reference/"&gt;default racket language&lt;/a&gt; and use the racket/base
language instead. This will help us get a better understanding of the
Racket libraries and the functions we're using from these libraries.&lt;/p&gt;
&lt;p&gt;While we're throwing the language away, we notice the paragraphs just
below that &lt;a href="https://docs.racket-lang.org/web-server/stateless.html#%28part._stateless-example%29"&gt;original example&lt;/a&gt; in the manual. It mentions that the
web-server language also imports a bunch of modules. We can discover
which of these modules we actually need by searching in the Racket
manual for functions we've used.  For instance, &lt;a href="https://docs.racket-lang.org/search/index.html?q=response%2Fxexpr"&gt;searching&lt;/a&gt; for
"response/xexpr" tells us it's in the &lt;a href="https://docs.racket-lang.org/web-server/http.html#%28part._xexpr%29"&gt;web-server/http/xexpr&lt;/a&gt;
module. We'll import the modules we need using the "prefix-in" form to
make function-module connections explicit.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang racket/base

(require (prefix-in xexpr: web-server/http/xexpr)
         (prefix-in hash: web-server/stuffers/hash)
         (prefix-in stuffer: web-server/stuffers/stuffer)
         (prefix-in serialize: web-server/stuffers/serialize))

(provide interface-version stuffer start)

(define interface-version &amp;#39;stateless)

(define stuffer
  (stuffer:stuffer-chain
   serialize:serialize-stuffer
   (hash:md5-stuffer (build-path (find-system-path &amp;#39;home-dir) &amp;quot;.urls&amp;quot;))))

(define (start req)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!&amp;quot;)))))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we've got something that is a little less magical. We can run this
file by calling it: "racket server.rkt". But nothing happens. This is
because the web-server language would start the service itself using
the exported variables we provided. So we're going to have to figure
out what underlying function calls "start" and call it
ourselves. Unfortunately searching for "start" in the manual search
field yields nothing relevant. So we Google "racket web server
start". Down the page on the second &lt;a href="https://docs.racket-lang.org/web-server/run.html"&gt;search result&lt;/a&gt; we notice an
&lt;a href="https://docs.racket-lang.org/web-server/run.html#%28part._.Examples%29"&gt;example&lt;/a&gt; using the serve/servlet function to register the start
function.  This is our in.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang racket/base

(require (prefix-in xexpr: web-server/http/xexpr)
         (prefix-in hash: web-server/stuffers/hash)
         (prefix-in stuffer: web-server/stuffers/stuffer)
         (prefix-in serialize: web-server/stuffers/serialize)
         (prefix-in servlet-env: web-server/servlet-env))

(provide interface-version stuffer start)

(define interface-version &amp;#39;stateless)

(define stuffer
  (stuffer:stuffer-chain
   serialize:serialize-stuffer
   (hash:md5-stuffer (build-path (find-system-path &amp;#39;home-dir) &amp;quot;.urls&amp;quot;))))

(define (start req)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!&amp;quot;)))))

(servlet-env:serve/servlet start)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run this version and it works! We are directed to a browser with our
HTML.  But we should clean this code up a bit. We no longer need to
export anything so we'll drop the provide line. We aren't even using
the interface-version and stuffer code. Things seem to be fine without
them, so we'll drop those too.  Also, looking at the serve/servlet
&lt;a href="https://docs.racket-lang.org/web-server/run.html#%28def._%28%28lib._web-server%2Fservlet-env..rkt%29._serve%2Fservlet%29%29"&gt;documentation&lt;/a&gt; we notice some other nice arguments we can tack
on.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang racket/base

(require (prefix-in xexpr: web-server/http/xexpr)
         (prefix-in servlet-env: web-server/servlet-env))

(define (start req)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!&amp;quot;)))))

(servlet-env:serve/servlet
 start
 #:servlet-path &amp;quot;/&amp;quot;
 #:servlet-regexp rx&amp;quot;&amp;quot;
 #:stateless? #t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ah, that's much cleaner. When you run this code, you will no longer be
directed to the /servlets/standalone.rkt path but to the site root --
set by the #:servlet-path optional variable. Also, every other path
you try to reach such as /foobar will successfully map to the start
function -- set by the #:servlet-regexp optional variable. Finally, we
also found the configuration to set the servlet stateless -- set by
the optional variable #:stateless?.&lt;/p&gt;
&lt;p&gt;But this is missing two things we could really use out of a simple web
service. The first is routing. We do that by looking up the
documentation for the &lt;a href="https://docs.racket-lang.org/web-server/dispatch.html"&gt;web-server/dispatch&lt;/a&gt; module. We'll use this
module to define some routes -- adding a 404 route to demonstrate the
usage.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang racket/base

(require (prefix-in dispatch: web-server/dispatch)
         (prefix-in xexpr: web-server/http/xexpr)
         (prefix-in servlet: web-server/servlet-env))

(define (not-found-route request)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Uh-oh! Page not found.&amp;quot;)))))

(define (home-route request)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!!!!!!!!!&amp;quot;)))))

(define-values (route-dispatch route-url)
  (dispatch:dispatch-rules
   [(&amp;quot;&amp;quot;) home-route]
   [else not-found-route]))

(servlet:serve/servlet
 route-dispatch
 #:servlet-path &amp;quot;/&amp;quot;
 #:servlet-regexp #rx&amp;quot;&amp;quot;
 #:stateless? #t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run this version and check out the server root. Then try any other
path. Looks good.  The final missing piece to this simple web service
is logging. Thankfully, the &lt;a href="https://docs.racket-lang.org/web-server-internal/dispatch-log.html"&gt;web-server/dispatch-log&lt;/a&gt; module has
us covered with some request formatting functions. So we'll wrap the
route-dispatch function and we'll print out the formatted request.&lt;/p&gt;
&lt;pre&gt;&lt;code class="hljs scheme"&gt;#lang racket/base

(require (prefix-in dispatch: web-server/dispatch)
         (prefix-in dispatch-log: web-server/dispatchers/dispatch-log)
         (prefix-in xexpr: web-server/http/xexpr)
         (prefix-in servlet: web-server/servlet-env))

(define (not-found-route request)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Uh-oh! Page not found.&amp;quot;)))))

(define (home-route request)
  (xexpr:response/xexpr
   `(html (body (h2 &amp;quot;Look ma, no state!!!!!!!!!&amp;quot;)))))

(define-values (route-dispatch route-url)
  (dispatch:dispatch-rules
   [(&amp;quot;&amp;quot;) home-route]
   [else not-found-route]))

(define (route-dispatch/log-middleware req)
  (display (dispatch-log:apache-default-format req))
  (flush-output)
  (route-dispatch req))

(servlet:serve/servlet
 route-dispatch/log-middleware
 #:servlet-path &amp;quot;/&amp;quot;
 #:servlet-regexp #rx&amp;quot;&amp;quot;
 #:stateless? #t)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run this version and notice the logs displayed for each request. Now
you've got a simple web service with routing and logging!  I hope this
gives you a taste for how easy it is to build simple web services in
Racket without downloading any third-party libraries. Database drivers
and HTML template libraries are also included and similarly
well-documented. In the future I hope to add an example of a slightly
more advanced web service.&lt;/p&gt;
&lt;p class="note"&gt;
  I have had huge difficulty discovering the source of Racket
  libraries.  These library sources are nearly impossible to Google
  and search on Github is insane.  Best scenario, the official
  racket.org docs would link directly to the source of a function when
  the function is documented. Of course I could just download the
  Racket source and start grepping... but I'm only so interested.
&lt;/p&gt;&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scheme.min.js"&gt;&lt;/script&gt;&lt;p&gt;&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Walking through a basic Racket web service &lt;a href="https://t.co/J3us48kzga"&gt;https://t.co/J3us48kzga&lt;/a&gt; &lt;a href="https://twitter.com/racketlang?ref_src=twsrc%5Etfw"&gt;@racketlang&lt;/a&gt;&lt;/p&gt;&amp;mdash; Phil Eaton (@phil_eaton) &lt;a href="https://twitter.com/phil_eaton/status/814674473681121280?ref_src=twsrc%5Etfw"&gt;December 30, 2016&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/p&gt;
</description><guid isPermaLink="false">http://notes.eatonphil.com/walking-through-a-basic-racket-web-service.html</guid><pubDate>Thu, 29 Dec 2016 00:00:00 +0000</pubDate></item></channel></rss>