<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    
    <title>hacking-networks channel. | notes.eatonphil.com</title>
    <meta name="description" content="hacking-networks channel." />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css" />
    
    <link rel="stylesheet" type="text/css" href="/style.css" />

    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  </head>
  <body>
    <header>
      <div class="container">
        <div>
          <div class="row">
	    <a href="/" class="sm-link">
              Home
            </a>
	    <a href="/rss.xml" class="sm-link">
              RSS
            </a>

	    <div class="subscribe">
              <a href="https://docs.google.com/forms/d/e/1FAIpQLSchaYjB6mq0SHmFL_J1wbB7E4SwUk23Dja2K7mfjtYH5o48fw/viewform?usp=sf_link">
		Subscribe
              </a>
	    </div>
	  </div>

          <h2>February 20, 2022</h2>
          <h1>hacking-networks channel.</h1>
          <div class="row" style="padding-bottom: 5px">
            <div class="tags"><a href="/tags/golang.html" class="tag">golang</a><a href="/tags/smtp.html" class="tag">smtp</a><a href="/tags/networking.html" class="tag">networking</a></div>
          </div>
	</div>
      </div>
    </header>

    <div class="container">
      <div class="col-6">
        <p>I've never run my own mail server before. Before today I had no clue
how email worked under the hood other than the very few times I've set
up mail clients.</p>
<p>I've heard no few times how hard it is to <em>send</em> mail from a
self-hosted server (because of spam filters). But how hard can it be
to hook up DNS to my personal server and receive email to my domain
sent from Gmail or another real-world client?</p>
<p>I knew it would be simpler to just send local mail to a local mail
server with a local mail client but that didn't seem as surely
real. But if I could send email from my Gmail account and receive it
in my server that would feel more rewarding.</p>
<p>I spent the afternoon digging into this. All code is <a href="https://github.com/eatonphil/gomail">available on
Github</a>. The "live stream" is in
the <a href="https://discord.multiprocess.io">Multiprocess Discord</a>'s</p>
<h3 id="dns">DNS</h3><p>First I bought a domain. (I needed to be able to mess around with
records without blowing up anything important.)</p>
<p>I knew that MX records controlled where mail for a domain is sent. But
I had to <a href="https://en.wikipedia.org/wiki/MX_record">look up the
specifics</a>. You need to
create an MX record that points to an A or AAAA record. So you need
both an MX record and an A or AAAA record.</p>
<p><img src="/dnsrecords.png" alt="MX and A record settings"></p>
<p>Done.</p>
<h3 id="firewall">Firewall</h3><p>The firewall on Fedora is aggressive. Gotta open up port 25.</p>
<pre><code class="hljs bash">$ sudo firewall-cmd --zone=dmz --add-port=25/tcp --permanent
$ sudo firewall-cmd --zone=public --add-port=25/tcp --permanent
$ sudo firewall-cmd --reload
</code></pre>
<p>I don't understand what zones are here.</p>
<h3 id="what-protocols?">What protocols?</h3><p>I knew that you send email with SMTP and you read it with POP3 or
IMAP. But it hadn't clicked before that the mail server has to speak
SMTP and if you only ever read on the server (which is of course
impractical in the real world) you don't need POP3 or IMAP.</p>
<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/07/smtp-protocol.png" alt="SMTP vs POP3"></p>
<p>So to meaningfully receive email from Gmail all I needed to do was implement SMTP.</p>
<h3 id="smtp">SMTP</h3><p>First I found the <a href="https://datatracker.ietf.org/doc/html/rfc5321">RFC for
SMTP</a> (or one of them
anyway) and <a href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol">the wikipedia page for
it</a>.</p>
<p>First off I'd need to run a TCP server on port 25.</p>
<pre><code class="hljs go">package main

import (
        &quot;errors&quot;
        &quot;log&quot;
        &quot;net&quot;
        &quot;strconv&quot;
        &quot;strings&quot;
)

func logError(err error) {
        log.Printf(&quot;[ERROR] %s\n&quot;, err)
}

func logInfo(msg string) {
        log.Printf(&quot;[INFO] %s\n&quot;, msg)
}

type message struct {
        clientDomain string
        smtpHeaders  map[string]string
        atmHeaders   map[string]string
        body         string
        from         string
        date         string
        subject      string
        to           string
}

type connection struct {
        conn net.Conn
        id   int
        buf  []byte
}

// TODO

func (c *connection) handle() {
        // TODO
}

func main() {
        l, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:25&quot;)
        if err != nil {
                panic(err)
        }
        defer l.Close()

        logInfo(&quot;Listening&quot;)

        id := 0
        for {
                conn, err := l.Accept()
                if err != nil {
                        logError(err)
                        continue
                }

                id += 1
                c := connection{conn, id, nil}
                go c.handle()
        }
}
</code></pre>
<p>Just a basic TCP server that passes off connections inside a
goroutine.</p>
<h3 id="greeting">Greeting</h3><p>After starting a connection, the server must send a greeting. The
successful greeting response code is <code>220</code>. It can optionally be
followed by additional text. Like most commands in SMTP it must be
ended with CRLF (<code>\r\n</code>).</p>
<p>So we'll add a helper function for writing lines that end in CRLF:</p>
<pre><code class="hljs go">func (c *connection) writeLine(msg string) error {
        msg += &quot;\r\n&quot;
        for len(msg) &gt; 0 {
                n, err := c.conn.Write([]byte(msg))
                if err != nil {
                        return err
                }

                msg = msg[n:]
        }

        return nil
}
</code></pre>
<p>And then we'll send that <code>220</code> in the <code>handle</code> function.</p>
<pre><code class="hljs go">func (c *connection) handle() {
        defer c.conn.Close()
        c.logInfo(&quot;Connection accepted&quot;)

        err := c.writeLine(&quot;220&quot;)
        if err != nil {
                c.logError(err)
                return
        }

        // TODO
</code></pre>
<h3 id="ehlo">EHLO</h3><p>Next we need to be able to read requests from the client. We'll write
a helper that reads until the next CRLF. We'll keep a buffer of unread
bytes in case we accidentally get bytes past the next CRLF. We'll
store that buffer in the connection object.</p>
<pre><code class="hljs go">func (c *connection) readLine() (string, error) {
        for {
                b := make([]byte, 1024)
                n, err := c.conn.Read(b)
                if err != nil {
                        return &quot;&quot;, err
                }

                c.buf = append(c.buf, b[:n]...)
                for i, b := range c.buf {
                        // If end of line
                        if b == &#39;\n&#39; &amp;&amp; i &gt; 0 &amp;&amp; c.buf[i-1] == &#39;\r&#39; {
                                // i-1 because drop the CRLF, no one cares after this
                                line := string(c.buf[:i-1])
                                c.buf = c.buf[i+1:]
                                return line, nil
                        }
                }
        }
}
</code></pre>
<p>Now back in the <code>handle</code>-er we can read a line from the client. From
the RFC we can see it should be <code>HELO</code> or <code>EHLO</code>. Both sendmail locally
and Gmail only send <code>EHLO</code> though so we'll just check for that.</p>
<p><img src="/ehloresponse.png" alt="EHLO response format"></p>
<p>So we'll validate the message sent is an <code>EHLO</code> and then we'll send
back a <code>250</code> with a space after it. We can ignore the rest of that
response grammar since we don't have additional keywords we want to
send to the client.</p>
<pre><code>func (c *connection) handle() {
        defer c.conn.Close()
        c.logInfo("Connection accepted")

        err := c.writeLine("220")
        if err != nil {
                c.logError(err)
                return
        }

        line, err := c.readLine()
        if err != nil {
                c.logError(err)
                return
        }

        msg := message{
                smtpHeaders: map[string]string{},
                atmHeaders:  map[string]string{},
        }
        if strings.HasPrefix(line, "EHLO") {
                c.logError(errors.New("Expected EHLO got: " + line))
                return
        }

        msg.clientDomain = line[len("EHLO "):]

        c.logInfo("Received EHLO")

        err = c.writeLine("250 ")
        if err != nil {
                c.logError(err)
                return
        }

        c.logInfo("Done EHLO")

        // TODO
</code></pre>
<style>.feedback{display:initial;}</style>
	<div class="feedback">
	  <h4>Feedback</h4>
	  As always,
	  please <a href="mailto:phil@eatonphil.com">email</a>
	  or <a href="https://twitter.com/phil_eaton">tweet me</a>
	  with questions, corrections, or ideas!
	</div>
      </div>
    </div>

    <footer>
      <div class="container">
	<div>
	  <div class="row">
	    <a href="/" class="sm-link">
              Home
            </a>
	    <a href="/rss.xml" class="sm-link">
              RSS
            </a>

	    <div class="subscribe">
              <a href="https://docs.google.com/forms/d/e/1FAIpQLSchaYjB6mq0SHmFL_J1wbB7E4SwUk23Dja2K7mfjtYH5o48fw/viewform?usp=sf_link">
		Subscribe
              </a>
	    </div>
	  </div>
	  <div class="feedback">
	    <p>Frequent Topics</p>
	    <div class="tags"><a href="/tags/javascript.html" class="tag">javascript (21)</a><a href="/tags/parsing.html" class="tag">parsing (13)</a><a href="/tags/compilers.html" class="tag">compilers (13)</a><a href="/tags/golang.html" class="tag">golang (11)</a><a href="/tags/postgres.html" class="tag">postgres (9)</a><a href="/tags/management.html" class="tag">management (8)</a><a href="/tags/lisp.html" class="tag">lisp (8)</a><a href="/tags/interpreters.html" class="tag">interpreters (8)</a><a href="/tags/sql.html" class="tag">sql (7)</a><a href="/tags/databases.html" class="tag">databases (7)</a><a href="/tags/python.html" class="tag">python (6)</a><a href="/tags/books.html" class="tag">books (6)</a><a href="/tags/x86-amd64.html" class="tag">x86/amd64 (5)</a><a href="/tags/typescript.html" class="tag">typescript (5)</a><a href="/tags/linux.html" class="tag">linux (5)</a><a href="/tags/json.html" class="tag">json (5)</a><a href="/tags/communication.html" class="tag">communication (5)</a><a href="/tags/scheme.html" class="tag">scheme (4)</a><a href="/tags/learning.html" class="tag">learning (4)</a><a href="/tags/leadership.html" class="tag">leadership (4)</a></div>
	  </div>
	</div>
      </div>
    </footer>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-58109156-2');
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
