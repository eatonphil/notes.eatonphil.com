<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    
    <title>Emulating AMD64: interpreting an ELF binary | notes.eatonphil.com</title>
    <meta name="description" content="Emulating AMD64: interpreting an ELF binary" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css" />
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css" />
 
    <link rel="stylesheet" type="text/css" href="/style.css" />

    <link rel="alternate" type="application/rss+xml" href="/rss.xml" />
  </head>
  <body>
    <header>
      <div class="container">
        <div>
          <a href="/" class="notes">Notes</a>
          <h2>December 1, 2020</h2>
          <h1>Emulating AMD64: interpreting an ELF binary</h1>
          <div class="row" style="padding-bottom: 5px">
            <div class="tags"><a href="/tags/emulator.html" class="tag">emulator</a><a href="/tags/assembly.html" class="tag">assembly</a><a href="/tags/AMD64.html" class="tag">AMD64</a><a href="/tags/linux.html" class="tag">linux</a><a href="/tags/x86.html" class="tag">x86</a><a href="/tags/x86_64.html" class="tag">x86_64</a><a href="/tags/golang.html" class="tag">golang</a></div>
          </div>
          
          <div>
            <a href="https://github.com/eatonphil" class="sm-link">
              <i class="fab fa-github"></i>
            </a>
            <a href="https://twitter.com/phil_eaton" class="sm-link">
              <i class="fab fa-twitter"></i>
            </a>
            <a href="/rss.xml" class="sm-link">
              <i class="fas fa-rss"></i>
            </a>
	  </div>
          <a class="subscribe" href="https://docs.google.com/forms/d/e/1FAIpQLSchaYjB6mq0SHmFL_J1wbB7E4SwUk23Dja2K7mfjtYH5o48fw/viewform?usp=sf_link">
            Subscribe to blog updates.
          </a>
        </div>
      </div>
    </header>
    <div class="container">
      <div class="col-6">
        <p>In this post we'll stumble toward a working emulator for a barebones C
program compiled for linux/AMD64. The approach will be slightly more
so based on observation than by following a spec. This is a great way
to quickly become familiar with a topic, and a bad way to guarantee
correctness.</p>
<p>The goal:</p>
<pre><code class="hljs bash">$ cat tests/simple.c
int main() {
  return 4;
}
$ gcc tests/simple.c
$ go build -o main
$ ./main a.out &amp;&amp; echo $?
4
</code></pre>
<p>This may look ridiculously simple but when you don't know how to deal
with a binary or how instructions are encoded, writing an emulator
that can generally handle this program will take a few hours!</p>
<p>Code for this project is <a href="https://github.com/eatonphil/go-amd64-emulator">available on Github</a>.</p>
<h3 id="background">Background</h3><p>AMD64, x86_64 or x64 are different names for AMD's widely adopted
64-bit extension to Intel's x86 instruction set (i.e. the encoding and
semantics of x86 binaries). AMD64 is a superset of x86 (introducing
64-bit registers and operations) and thus backwards compatible with
x86 programs.</p>
<p class="note">
  A year and a half ago I first got into emulation with
  an <a href="https://notes.eatonphil.com/emulator-basics-a-stack-and-register-machine.html">AMD64
  emulator in JavaScript</a>. The JavaScript emulator interpreted the
  textual representation of AMD64 programs (e.g. <code>MOV RBP,
  RSP</code>, Intel's assembly syntax). A C program had to be compiled
  with <code>-S</code> to produce an assembly file that the JavaScript
  emulator could read (i.e. <code>gcc -S tests/simple.c</code>) This
  was a great way to get started with emulation by ignoring the
  complexity of encoded instructions and executable formats.
</p><p>If we dig into the binary file produced by gcc on Linux we learn that
it is an <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">ELF
file</a>.</p>
<pre><code class="hljs bash">$ gcc test/simple.c
$ file a.out
a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d0b5c742b9fbcbcca4dfa9438a8437a8478a51bb, for GNU/Linux 3.2.0, not stripped
</code></pre>
<p>ELF is responsible for surrounding the actual binary-encoded program
instructions with metadata on exported and imported C identifiers. But
for simple programs like this initial emulator, we can ignore
export/imports. We'll only use the ELF metadata to find out where the
instructions for our <code>main</code> function starts.</p>
<h3 id="where-is-main?">Where is main?</h3><p>If we use an ELF reader+disassembler on the binary generated by gcc
and search for <code>main</code> we can find its address.</p>
<pre><code class="hljs bash">$ objdump -d a.out | grep -A10 &#39;&lt;main&gt;&#39;
0000000000401106 &lt;main&gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
  40110f:       5d                      pop    %rbp
  401110:       c3                      retq
  401111:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  401118:       00 00 00
  40111b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000401120 &lt;__libc_csu_init&gt;:
</code></pre>
<p>This means that the function, <code>main</code>, starts at
address <code>0x401106</code> in memory. Furthermore, this implies is
that the binary must be loaded into CPU memory such that the CPU can
jump here to execute our program.</p>
<p>In truth, <code>main</code> is not this program's entrypoint. If we
run <code>objdump -x a.out</code> we can see that the ELF entrypoint
is <code>0x401020</code>.</p>
<pre><code class="hljs bash">$ objdump -x a.out
a.out:     file format elf64-x86-64
a.out
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401020

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
             filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
</code></pre>
<p>This is because the true entrypoint gcc sets up is a function called
<code>_start</code>. This function generated by gcc is responsible for
initializing the libc runtime, calling our <code>main</code> function
and executing the exit syscall with the return value
of <code>main</code>.</p>
<pre><code class="hljs bash">objdump -d a.out | grep -A10 &#39;&lt;_start&gt;&#39;
0000000000401020 &lt;_start&gt;:
  401020:       f3 0f 1e fa             endbr64
  401024:       31 ed                   xor    %ebp,%ebp
  401026:       49 89 d1                mov    %rdx,%r9
  401029:       5e                      pop    %rsi
  40102a:       48 89 e2                mov    %rsp,%rdx
  40102d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
  401031:       50                      push   %rax
  401032:       54                      push   %rsp
  401033:       49 c7 c0 90 11 40 00    mov    $0x401190,%r8
  40103a:       48 c7 c1 20 11 40 00    mov    $0x401120,%rcx
</code></pre>
<p>But because all this libc initialization is relatively complicated
we're just going to skip the true ELF entrypoint for now. Our emulator
should be able to locate <code>main</code>, load the binary into
memory, jump to the start of <code>main</code>, and set the exit code
of the emulator to the result of main.</p>
<p class="note">
  As you can see, this ELF binary has its own hard-coded view of where
  it will be in memory. What if our CPU were to run multiple process
  at once? We might give each process its own virtual memory space
  and map back to a real memory space so each process (and by
  extension, compilers) don't have to think about how they fit into
  memory relative to other processes.
</p><p>The last question to figure out is where to load the ELF binary into
emulator memory so that addresses in memory are where the program
expects.</p>
<p>As it turns out, there is a piece of metadata called section
headers that contain an address and a offset from the start of the ELF
file. By subtracting this we can get the location the file expects to
be in memory.</p>
<pre><code>$ objdump -x a.out
a.out:     file format elf64-x86-64
a.out
architecture: i386:x86-64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000000401020

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000400040 paddr 0x0000000000400040 align 2**3
             filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
</code></pre>
<p>That is: <code>0x400040 (vaddr) - 0x40 (off) = 0x400000</code>.
Judging from a Google search this seems to be a pretty common address
where ELF binaries are loaded into memory.</p>
<h3 id="elf-and-go">ELF and Go</h3><p>Binary file formats tend to be a pain to work with because, to enable
greater compression, everything ends up being a pointer to something
else. So you end up jumping all around the file just to stitch
information back together.</p>
<p>So the one third-party-ish library we'll use is Go's builtin
<code>debug/elf</code> package. With this library we can load an ELF
binary and iterate over symbols and sections to discover the location
of <code>main</code> and the start address for the binary in memory.</p>
<p>Editing in <code>main.go</code>:</p>
<pre><code class="hljs go">package main

import (
    &quot;bytes&quot;
    &quot;debug/elf&quot;
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;log&quot;
    &quot;os&quot;
)

type process struct {
    startAddress uint64
    entryPoint   uint64
    bin          []byte
}

func readELF(filename, entrySymbol string) (*process, error) {
    bin, err := ioutil.ReadFile(filename)
    if err != nil {
        return nil, err
    }

    elffile, err := elf.NewFile(bytes.NewReader(bin))
    if err != nil {
        return nil, err
    }

    symbols, err := elffile.Symbols()
    if err != nil {
        return nil, err
    }

    var entryPoint uint64
    for _, sym := range symbols {
        if sym.Name == entrySymbol &amp;&amp; elf.STT_FUNC == elf.ST_TYPE(sym.Info) &amp;&amp; elf.STB_GLOBAL == elf.ST_BIND(sym.Info) {
            entryPoint = sym.Value
        }
    }

    if entryPoint == 0 {
        return nil, fmt.Errorf(&quot;Could not find entrypoint symbol: %s&quot;, entrySymbol)
    }

    var startAddress uint64
    for _, sec := range elffile.Sections {
        if sec.Type != elf.SHT_NULL {
            startAddress = sec.Addr - sec.Offset
            break
        }
    }

    if startAddress == 0 {
        return nil, fmt.Errorf(&quot;Could not determine start address&quot;)
    }

    return &amp;process{
        startAddress: startAddress,
        entryPoint:   entryPoint,
        bin:          bin,
    }, nil
}

func main() {
    if len(os.Args) == 0 {
        log.Fatal(&quot;Binary not provided&quot;)
    }

    proc, err := readELF(os.Args[1], &quot;main&quot;)
    if err != nil {
        panic(err)
    }

    fmt.Printf(&quot;Start: 0x%x\nEntry: 0x%x\n&quot;, proc.startAddress, proc.entryPoint)
}
</code></pre>
<p>We can test on a basic compiled C program:</p>
<pre><code class="hljs bash">$ cat tests/simple.c
int main() {
  return 4;
}
$ gcc tests/simple.c
$ go build -o main
$ ./main a.out
Start: 0x400000
Entry: 0x401106
</code></pre>
<p>And verify against <code>objdump</code>:</p>
<pre><code class="hljs bash">$ objdump -d a.out | grep -A10 &#39;&lt;main&gt;&#39;
0000000000401106 &lt;main&gt;:
  401106:       55                      push   %rbp&#39;&gt;&#39;
</code></pre>
<p>And that's it for dealing with ELF. Now we can sketch out a virtual
CPU and how we deal with interpreting instructions starting at this
address.</p>
<h3 id="the-cpu">The CPU</h3><p>AMD64 counts on being able to store values in registers and memory,
sometimes through direct addressing and sometimes indirectly using
stack operations (push and pop). And userland processes count on being
loadeded into CPU memory so the CPU can jump to the process entrypoint
and process.</p>
<pre><code class="hljs go">type cpu struct {
    proc    *process
    mem     []byte
    regfile *registerFile
    tick    chan bool
}

func newCPU(memory uint64) cpu {
    return cpu{
        mem:     make([]byte, memory),
        regfile: &amp;registerFile{},
        tick:    make(chan bool, 1),
    }
}
</code></pre>
<p>The <code>tick</code> channel is so that we can wrap the emulator in a
step-debugger. But by default we'll just set up a goroutine to tick
forever.</p>
<pre><code class="hljs go">func repl(c *cpu) {
  // TODO
}

func main() {
    if len(os.Args) == 0 {
        log.Fatal(&quot;Binary not provided&quot;)
    }

    proc, err := readELF(os.Args[1], &quot;main&quot;)
    if err != nil {
        panic(err)
    }

    debug := false
    for _, arg := range os.Args[1:] {
        switch arg {
        case &quot;--debug&quot;:
            fallthrough
        case &quot;-d&quot;:
            debug = true
        }
    }

    // 10 MB
    cpu := newCPU(0x400000 * 10)

    go cpu.run(proc)
    if debug {
        repl(&amp;cpu)
    } else {
        for {
            cpu.tick &lt;- true
        }
    }
}
</code></pre>
<h3 id="registers">Registers</h3><p>To emulate a simple program like our <code>tests/simple.c</code>,
we'll only need to support a few common registers.</p>
<pre><code class="hljs go">type register int

const (
    // These are in order of encoding value (i.e. rbp is 5)
    rax register = iota
    rcx
    rdx
    rbx
    rsp
    rbp
    rsi
    rdi
    r8
    r9
    r10
    r11
    r12
    r13
    r14
    r15
    rip
    rflags
)

var registerMap = map[register]string{
    rax:    &quot;rax&quot;,
    rcx:    &quot;rcx&quot;,
    rdx:    &quot;rdx&quot;,
    rbx:    &quot;rbx&quot;,
    rsp:    &quot;rsp&quot;,
    rbp:    &quot;rbp&quot;,
    rsi:    &quot;rsi&quot;,
    rdi:    &quot;rdi&quot;,
    r8:     &quot;r8&quot;,
    r9:     &quot;r9&quot;,
    r10:    &quot;r10&quot;,
    r11:    &quot;r11&quot;,
    r12:    &quot;r12&quot;,
    r13:    &quot;r13&quot;,
    r14:    &quot;r14&quot;,
    r15:    &quot;r15&quot;,
    rip:    &quot;rip&quot;,
    rflags: &quot;rflags&quot;,
}

type registerFile [18]uint64

func (regfile *registerFile) get(r register) uint64 {
    return regfile[r]
}

func (regfile *registerFile) set(r register, v uint64) {
    regfile[r] = v
}
</code></pre>
<p>Of immediate importance will be <code>rip</code>, <code>rsp</code>,
and <code>rax</code> registers. <code>rip</code> is used to track the
current instruction to process. It will generally be incremented
except for when dealing with function calls and
returns. <code>rsp</code> is used as a pointer to the top of a stack
in memory. It is incremented and decremented as values are pushed and
popped on this stack. Finally, <code>rax</code> is used to pass
function return values.</p>
<h3 id="loading-a-program">Loading a program</h3><p>Running a program is a matter of loading the program into memory,
setting the stack pointer to the last address of memory (in x86 the
stack grows down), pointing <code>rip</code> at the entrypoint, and
looping until the entrypoint function returns.</p>
<pre><code class="hljs go">func writeBytes(to []byte, start uint64, bytes int, val uint64) {
    for i := 0; i &lt; bytes; i++ {
        to[start+uint64(i)] = byte(val &gt;&gt; (8 * i) &amp; 0xFF)
    }
}

func (c *cpu) loop(entryReturnAddress uint64) {
    for {
        &lt;-c.tick

        ip := c.regfile.get(rip)
        if ip == entryReturnAddress {
            break
        }

        inb1 := c.mem[ip]

        // TODO: deal with instructions

        c.regfile.set(rip, ip+1)
    }
}

func (c *cpu) run(proc *process) {
    copy(c.mem[proc.startAddress:proc.startAddress+uint64(len(proc.bin))], proc.bin)
    c.regfile.set(rip, proc.entryPoint)
    initialStackPointer := uint64(len(c.mem))
    c.regfile.set(rsp, initialStackPointer)
    c.loop(initialStackPointer)
    os.Exit(int(c.regfile.get(rax)))
}
</code></pre>
<p>And now we're ready to start interpreting instructions.</p>
<h3 id="instruction-decoding">Instruction decoding</h3><p>Using <code>objdump</code> we already got a sense for what the program decodes to.</p>
<pre><code class="hljs bash">$ objdump -d a.out | grep -A10 &#39;&lt;main&gt;&#39;
0000000000401106 &lt;main&gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
  40110f:       5d                      pop    %rbp
  401110:       c3                      retq
  401111:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
  401118:       00 00 00
  40111b:       0f 1f 44 00 00          nopl   0x0(%rax,%rax,1)

0000000000401120 &lt;__libc_csu_init&gt;:
</code></pre>
<h4 id="push">push</h4><p>We see that <code>0x55</code> means <code>push
%rbp</code>. And we also see that instructions aren't a fixed number
of bytes. Some are one byte, some are 7. Some (not shown) are <a href="https://stackoverflow.com/questions/14698350/x86-64-asm-maximum-bytes-for-an-instruction">even
longer</a>.</p>
<p>Thankfully instructions follow some fairly simple patterns. There are
a set of prefix instructions and a set of real instructions. So far we
should be able to tell on the first byte whether the instruction is a
prefix instruction and, if not, how many bytes the instruction will
take up on the whole.</p>
<p>Ignoring prefix instructions for now though, the first thing to do is
look up <code>0x55</code> in an opcode table like
<a href="http://ref.x86asm.net/coder64.html">this</a>. Clicking on
<a href="http://ref.x86asm.net/coder64.html#x50">55</a> in the opcode index we
see that this is indeed a push instruction. <code>50+r</code> means
that we have to subtract <code>0x50</code> from the opcode to
determine the register we should push.</p>
<p>The register will be <code>5</code> which if we look up in a <a href="https://wiki.osdev.org/X86-64_Instruction_Encoding#Registers">register
table</a>
is RBP. Since we set up our register enum in code in this order, we'll
be able to just use the constant <code>rbp</code> in Go code.</p>
<p>Finally, since the next instruction numerically is <code>0x58</code>
we know that this instruction is identified by being between
<code>0x50</code> and <code>0x57</code> inclusive. This is all the
info we need to handle this instruction.</p>
<pre><code class="hljs go">// helper for dumping byte arrays as hex
func hbdebug(msg string, bs []byte) {
    str := &quot;%s:&quot;
    args := []interface{}{msg}
    for _, b := range bs {
        str = str + &quot; %x&quot;
        args = append(args, b)
    }
    fmt.Printf(str+&quot;\n&quot;, args...)
}

func (c *cpu) loop(entryReturnAddress uint64) {
    for {
        &lt;-c.tick

        ip := c.regfile.get(rip)
        if ip == entryReturnAddress {
            break
        }

        inb1 := c.mem[ip]

        if inb1 &gt;= 0x50 &amp;&amp; inb1 &lt; 0x58 { // push
            regvalue := c.regfile.get(register(inb1 - 0x50))
            sp := c.regfile.get(rsp)
            writeBytes(c.mem, sp-8, 8, regvalue)
            c.regfile.set(rsp, uint64(sp-8))
        } else {
            hbdebug(&quot;prog&quot;, c.mem[ip:ip+10])
            panic(&quot;Unknown instruction&quot;)
        }

        c.regfile.set(rip, ip+1)
    }
}
</code></pre>
<p>If we try this out now we should expect it to panic on the second
byte, <code>0x48</code>.</p>
<pre><code class="hljs bash">$ go build -o main
$ ./main a.out
prog: 48 89 e5 b8 4 0 0 0 5d c3
panic: Unknown instruction

goroutine 19 [running]:
main.(*cpu).loop(0xc000086c30, 0x2800000)
        /home/phil/tmp/goamd/main.go:168 +0x16d
main.(*cpu).run(0xc000086c30, 0xc000086c00)
        /home/phil/tmp/goamd/main.go:180 +0xac
created by main.main
        /home/phil/tmp/goamd/main.go:211 +0x286
</code></pre>
<p>Looking good.</p>
<h4 id="mov">mov</h4><p>Taking a look at the next two instructions with <code>objdump</code>
we see <code>mov</code> encoded two different ways.</p>
<pre><code class="hljs bash">$ objdump -d a.out | grep -A4 &#39;&lt;main&gt;&#39;
0000000000401106 &lt;main&gt;:
  401106:       55                      push   %rbp
  401107:       48 89 e5                mov    %rsp,%rbp
  40110a:       b8 fe 00 00 00          mov    $0xfe,%eax
</code></pre>
<p>Looking up <a href="http://ref.x86asm.net/coder64.html#x48">0x48</a> we see that
this is a prefix instruction that turns on 64-bit mode for the
instruction. Some instructions like <code>pop</code> and
<code>push</code> don't need this prefix to be in 64-bit mode. In any
case, this just means we'll have to have a size flag that switches
from 32-bit to 64-bit mode on seeing this instruction. This flag will
be reset each time we start reading an instruction.</p>
<p>Looking up <a href="http://ref.x86asm.net/coder64.html#x89">0x89</a>.</p>

      </div>
    </div>

    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-58109156-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-58109156-2');
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
