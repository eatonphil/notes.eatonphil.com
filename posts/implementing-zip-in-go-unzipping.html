# Implementing zip archiving in Golang: unzipping
## November 24, 2021
###### golang,zip

<small>All code for this post is <a href="https://github.com/eatonphil/gozip">available on Github</a>.</small>

Let's take a look at how zip files work. Take a small file for example:

```bash
$ cat hello.text
Hello!
```

Let's zip it up.

```bash
$ zip test.zip hello.text
adding: hello.text (stored 0%)
$ ls -lah test.zip
-rw-r--r-- 1 phil phil 177 Nov 23 23:04 test.zip
```

So a 6 byte text file becomes a 177 byte zip file. That is pretty
small! Parsing 177 bytes sounds like it can't possibly be too
complicated!

Let's hexdump the zip file.

```bash
$ hexdump -C test.zip
00000000  50 4b 03 04 0a 00 00 00  00 00 8a b8 77 53 9e d8  |PK..........wS..|
00000010  42 b0 07 00 00 00 07 00  00 00 0a 00 1c 00 68 65  |B.............he|
00000020  6c 6c 6f 2e 74 65 78 74  55 54 09 00 03 74 73 9d  |llo.textUT...ts.|
00000030  61 74 73 9d 61 75 78 0b  00 01 04 eb 03 00 00 04  |ats.aux.........|
00000040  eb 03 00 00 48 65 6c 6c  6f 21 0a 50 4b 01 02 1e  |....Hello!.PK...|
00000050  03 0a 00 00 00 00 00 8a  b8 77 53 9e d8 42 b0 07  |.........wS..B..|
00000060  00 00 00 07 00 00 00 0a  00 18 00 00 00 00 00 01  |................|
00000070  00 00 00 a4 81 00 00 00  00 68 65 6c 6c 6f 2e 74  |.........hello.t|
00000080  65 78 74 55 54 05 00 03  74 73 9d 61 75 78 0b 00  |extUT...ts.aux..|
00000090  01 04 eb 03 00 00 04 eb  03 00 00 50 4b 05 06 00  |...........PK...|
000000a0  00 00 00 01 00 01 00 50  00 00 00 4b 00 00 00 00  |.......P...K....|
000000b0  00                                                |.|
000000b1
```

We can see both the file name and the file contents in there.

Let's take a look at the zip structure defined
[here](https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT). Based
on section 4.3.6 it looks like file metadata followed by the file
contents are stored one after another. The file metadata looks like this:

| Field                       | Size    |
| ----------------------------|---------|
| local file header signature | 4 bytes |
| version needed to extract   | 2 bytes |
| general purpose bit flag    | 2 bytes |
| compression method          | 2 bytes |
| last mod file time          | 2 bytes |
| last mod file date          | 2 bytes |
| crc-32                      | 4 bytes |
| compressed size             | 4 bytes |
| uncompressed size           | 4 bytes |
| file name length            | 2 bytes |
| extra field length          | 2 bytes |
| file name                   | variable |
| extra field                 | variable |

The header signature is a single integer (<code>0x04034b50</code>) in
a valid zip file. We'll ignore version and general. Compression is
either <code>0</code> for no compression or <code>8</code> for DEFLATE
compression/decompression.

Last modified time and date is MSDOS-style date/time format which is
[pretty
funky](https://groups.google.com/g/comp.os.msdos.programmer/c/ffAVUFN2NbA).

When there is no compression, we'll use the uncompressed size
field. When compression is set we'll use the compressed size field.

And the last two length fields describe the number of bytes for the
last two variable fields.

```go
package main

import (
	"os"
	"bytes"
	"compress/flate"
	"io/ioutil"
	"encoding/binary"
	"time"
	"fmt"
)

type compression uint8
const (
	noCompression compression = iota
	deflateCompression
)

type localFileHeader struct {
	signature uint32
	version uint16
	bitFlag uint16
	compression compression
	lastModified time.Time
	crc32 uint32
	compressedSize uint32
	uncompressedSize uint32
	fileName string
	extraField []byte
	fileContents string
}
```

It's not a direct translation. We'll map compression to a Go-style
"enum", the MSDOS date/time to Go's time, and store the file name,
extra field directly without the length fields. We'll tack on the
actual file contents at the end too.

### main

The main program will read a zip file passed by name in command line
arguments. Since files are laid out one after another we'll call a
parse function until we stop seeing files.

```go
func main() {
	f, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		panic(err)
	}

	end := 0
	for end < len(f) {
		var err error
		var lfh *localFileHeader
		var next int
		lfh, next, err = parseLocalFileHeader(f, end)
		if err == errNotZip && end > 0 {
			break
		}
		if err != nil {
			panic(err)
		}

		end = next

		fmt.Println(lfh.lastModified, lfh.fileName, lfh.fileContents)
	}
}
```

### Reading integers, bytes, strings

In converting an array of bytes into distinct fields we'll need some
helper functions. Each helper will take an array of bytes and an
offset. They'll return an integer, string, or bytes and the index in
the array of bytes after the offset. They'll return an error if we
ever run past the size of the array of bytes.

```go
var errOverranBuffer = fmt.Errorf("Overran buffer")

func readUint32(bs []byte, offset int) (uint32, int, error) {
	end := offset + 4
	if end > len(bs) {
		return 0, 0, errOverranBuffer
	}

	return binary.LittleEndian.Uint32(bs[offset:end]), end, nil
}

func readUint16(bs []byte, offset int) (uint16, int, error) {
	end := offset+2
	if end > len(bs) {
		return 0, 0, errOverranBuffer
	}

	return binary.LittleEndian.Uint16(bs[offset:end]), end, nil
}
```

Grabbing bytes and strings is easier. The only extra piece on top of
slicing is bounds checking.

```go
func readBytes(bs []byte, offset int, n int) ([]byte, int, error) {
	end := offset + n
	if end > len(bs) {
		return nil, 0, errOverranBuffer
	}

	return bs[offset:offset+n], end, nil
}

func readString(bs []byte, offset int, n int) (string, int, error) {
	read, end, err := readBytes(bs, offset, n)
	return string(read), end, err
}
```

Now we're ready to actually grab files out of a zip!

### Files

For each file we'll fail early if the first four bytes are not the magic zip signature.

```go
var errNotZip = fmt.Errorf("Not a zip file")

func parseLocalFileHeader(bs []byte, start int) (*localFileHeader, int, error) {
	signature, i, err := readUint32(bs, start)
	if signature != 0x04034b50 {
		return nil, 0, errNotZip
	}
	if err != nil {
		return nil, 0, err
	}
```
