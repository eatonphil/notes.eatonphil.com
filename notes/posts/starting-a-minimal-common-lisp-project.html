# Starting a minimal Common Lisp project
## March 5, 2018

If you've only vaguely heard of Lisp before or studied Scheme in
school, Common Lisp is nothing like what you'd expect. While
functional programming is all the rage in Scheme, Common Lisp was
"expressly designed to be a real-world engineering language rather
than a theoretically 'pure' language" ([Practical Common
Lisp](http://www.gigamonkeys.com/book/introduction-why-lisp.html)).
Furthermore, [SBCL](http://sbcl.org/) -- a popular implementation --
is a highly optimized compiler that is competitive with
[Java](https://benchmarksgame.alioth.debian.org/u64q/lisp.html).

To skip past my Scheme digression, click [here](#building-blocks).

### On Scheme

I've done one or two unremarkable web prototypes in [Chicken
Scheme](https://www.call-cc.org/), an R5RS/R7RS Scheme implementation.
I don't think Chicken Scheme is the best bet for the web (I'm mostly
biased to this topic) because it has no native-thread support and
there are lighter interpreters out there that are easier to embed
(e.g. in nginx). Chicken Scheme's "niche" is being a generally
high-quality implementation with a great [collection of 3rd-party
libraries](http://wiki.call-cc.org/chicken-projects/egg-index-4.html),
but it is not the
[fastest](https://ecraven.github.io/r7rs-benchmarks/) Scheme you could
choose.

I worked on a larger web prototype -- a Github issue reporting app --
in [Racket](https://racket-lang.org/), a derivative of Scheme
R6RS. I've blogged favorably about Racket
[before](http://notes.eatonphil.com/walking-through-a-basic-racket-web-service.html).
It is an interpreter with a JIT compiler, has thread support, and is
also well known for its collection of [3rd-party
libaries](https://pkgs.racket-lang.org/). However the Racket ecosystem
[suffers](https://fare.livejournal.com/188429.html) from the same
issues Haskell's does: libraries and bindings are primarily
proof-of-concept only; missing documentation, tests and
use. Additionally, trying to render "templatized" HTML (like Jinja
allows for in Flask) without using S-exp-based syntax was a nightmare.
(Read: there's space for someone to write a good string templating
library.)

#### Sorry, Racket

Last point on Racket (because it really is worth looking into),
debugging in that Github issue project was not fun. The backtraces
were mostly useless. Naively I assume this may have to do with the way
Racket optimizes and rewrites functions. I was often left with zero
context to see find and correct my errors. But it could very well be I
was making poor use of Racket.

#### On the other hand

Common Lisp (its implementations and ecosystem) seems more robust and
developed. SBCL, with it's great performance and native-thread
support, is a promising candidate for backend web development.

### Building blocks

Common Lisp symbols, imagine "first-class" variables/labels, are
encapsulated in namespaces called packages. However packages don't
account for organization across directories, among other things. So
while packages are a part of the core Common Lisp language, the
"cross-directory" organizational structure is managed by the
(all-but-standard) [ASDF](https://github.com/fare/asdf) "systems". You
can think of packages as roughly similar to modules in Python whereas
systems in ASDF are more like packages in Python.

ASDF does not manage non-local dependencies. For that we use
[Quicklisp](https://www.quicklisp.org/beta/), the defacto package
manager. ASDF should come bundled with your Common Lisp installation,
which I'll assume is SBCL (not that it matters). Quicklisp does not
come built in.

### Getting Quicklisp

You can follow the notes on the Quicklisp site for installation, but
the basic gist is:

```shell
$ curl -O https://beta.quicklisp.org/quicklisp.lisp
$ sbcl --load quicklisp.lisp
...
* (quicklisp-quickstart:lisp)
...
* ^D
$ sbcl --load "~/quicklisp/setup.lisp"
...
* (ql:add-to-init-file)
```

### A minimal package

Now we're ready to get started. Create a directory using the name of
the library you'd like to package. For instance, I'll create a
"cl-docker" directory for my Docker wrapper library. Then create a
file using the same name in the directory with the ".asd" suffix:

```shell
$ cd ~/projects
$ mkdir cl-docker
$ touch cl-docker/cl-docker.asd
```

It is important for the ".asd" file to share the same name as the
directory because ASDF will look for it in that location (by default).

Before we get too far into packaging, let's write a function we'd like
to export from this library. Edit "cl-docker/docker.lisp" (this name does
not matter) and add the following:

```lisp
(defun ps ()
  (uiop:run-program '("docker" "ps") :output :string))
```

This uses a portable library, "uiop", that ASDF exposes by default (we
won't need to explicitly import this anywhere because the package is
managed by ASDF). It will run the command "docker ps" and return the
output as a string.

Next let's define the package (think module in Python) by editing
"package.lisp" (this name also does not matter):

```lisp
(defpackage cl-docker
  (:use cl)
  (:export :ps))
```

Here we state the packages name, say that we want to import all Common
Lisp base symbols into the package and we want to export only our "ps"
function.

At this point we must also declare within the "docker.lisp" file that
it is a part of this package:

```lisp
(in-package :cl-docker)

(defun ps ()
  (uiop:run-program '("docker" "ps") :output :string))
```

Next let's define the system (ASDF-level, similar to a package in Python)
in "cl-docker/cl-docker.asd":

```lisp
(defsystem :cl-docker
    :components ((:file "package")
                 (:file "docker")))
```
