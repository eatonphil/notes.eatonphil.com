# Starting a minimal Common Lisp project
## March 5, 2018

If you've only vaguely heard of "Lisp" before or studied Scheme in
school, Common Lisp is nothing like what you'd expect. While
functional programming is all the rage in Scheme, Common Lisp was
"expressly designed to be a real-world engineering language rather
than a theoretically 'pure' language" ([Practical Common
Lisp](http://www.gigamonkeys.com/book/introduction-why-lisp.html)).
Furthermore, [SBCL](http://sbcl.org/) -- a popular implementation --
is a highly optimized compiler competitive with
[Java](https://benchmarksgame.alioth.debian.org/u64q/lisp.html).

While I've done a few projects in [Chicken
Scheme](https://www.call-cc.org/) (an R5RS/R7RS Scheme implementation
with a relatively rich set of [3rd-party
libraries](http://wiki.call-cc.org/chicken-projects/egg-index-4.html))
and [Racket](https://racket-lang.org/) (a derivative of Scheme R6RS
also well know for its [3rd-party
libaries](https://pkgs.racket-lang.org/)), Common Lisp and its
ecosystem seem more robust and developed.  Overall, you may find it
worthwhile to set aside the beauty of Scheme to see the practicality
of Common Lisp.

### Building blocks

Common Lisp symbols, a term for things sort of like variables, are
encapsulated in namespaces called packages. However, packages don't
account for organization across directories. So while packages are a
part of the core Common Lisp language, the "cross-directory"
organizational structure is managed by (the all-but-standard)
[ASDF](https://github.com/fare/asdf) "systems". You can think roughly
of packages as similar to modules in Python whereas systems in ASDF
are more like packages in Python.

ASDF does not manage non-local dependencies however. Here
[Quicklisp](https://www.quicklisp.org/beta/) is something of the
default package manager.
