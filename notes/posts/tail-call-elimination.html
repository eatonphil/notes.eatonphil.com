# Tail call elimination
## May 14, 2019

In this post we'll explore what tail calls are, why they are useful,
and how they can be implemented in an interpreter, C, and LLVM IR.

### Tail calls

A tail call is a function call made at the end of a block that
returns the value of the call (some languages do not force this
<code>return</code> requirement). Here are a few examples.

```javascript
function tailCallEx1() {
  // Loops forever but is a tail call.
  return tailCallEx1();
}

function tailCallEx2(x) {
  if (x) {
    return tailCallEx2(x - 1);
  }

  return 1;
}

function tailCallEx3(x) {
  return x && tailCallEx(x - 1) || 1;
}

function tailCallEx4(x) {
  switch (x) {
    case 0:
	  return 1;
    default:
	  return tailCallEx4(x - 1);
  }
}
```

And here are some examples of non-tail calls.

```javascript
function nonTailCallEx1(x) {
  if (x) {
    // Not a tail call because the call is not the value returned.
    return 1 + nonTailCallEx1(x - 1);
  }
  
  return 0;
}

function nonTailCallEx2(x) {
  if (x) {
    const r = nonTailCallEx2(x - 1);
	console.log(r);
	return r;
  }
  
  return 1;
}
```

### Why is this important?

Tail call elimination is an optimization some languages choose to do
that rewrites the tail call as a jump or branch. This is useful for
two reasons:

1. Potential performance gain due to jump/branch instead of function call
2. No stack overflows due to no nested function call stacks

### Implementation 1: Interpreter

In an interpreter, tail call elimination can be implemented by
wrapping a function definition with a loop and breaking out of it
under normal conditions. But allowing the loop to take you back to the
beginning of the function in a tail call.

Here is an example of a standalone function that can be used as a
reference for how to implement tail-call eliminating (self-recursive
only) calls:

```javascript
function fibonacciVanilla(a, b, n) {
  if (n === 0) {
    return a;
  }
  
  return fibonacciVanilla(b, a + b, n - 1);
}

function fibonacciTCEliminated(a, b, n) {
  while (true) {
    if (n === 0) {
	  return a;
	}
	
	const a1 = b;
	const b1 = a + b;
	const n1 = n - 1;
	a = a1;
	b = b1;
	n = n1;
  }
}
```

Here is an example of this strategy used in a [Scheme
interpreter](https://github.com/eatonphil/bsdscheme).

```d
// Define a new function with name `name` and add it to the context.
Value namedLambda(Value arguments, Context ctx, string name) {
  auto funArguments = car(arguments);
  auto funBody = cdr(arguments);

  Value defined(Value parameters, void** rest) {
    Context newCtx = ctx.dup;

    // Copy the runtime calling context to the new context.
    Context runtimeCtx = cast(Context)(*rest);
    auto runtimeCallingContext = runtimeCtx.callingContext;
    newCtx.callingContext = runtimeCallingContext.dup;

    Value result;
	// Loop forever, will break immediately if not a tail call
    bool tailCalling = false;
    while (true) {
      if (valueIsList(funArguments)) {
        auto keyTmp = valueToList(funArguments);
        auto valueTmp = valueToList(parameters);
        while (true) {
          auto key = valueToSymbol(keyTmp[0]);
          auto value = valueTmp[0];

          newCtx.set(key, value);

          // TODO: handle arg count mismatch
          if (valueIsList(keyTmp[1])) {
            keyTmp = valueToList(keyTmp[1]);
            valueTmp = valueToList(valueTmp[1]);
          } else {
            break;
          }
        }
      } else if (valueIsSymbol(funArguments)) {
        auto key = valueToSymbol(funArguments);
        newCtx.set(key, car(parameters));
      } else if (!valueIsNil(funArguments)) {
        error("Expected symbol or list in lambda formals", funArguments);
      }

      if (!tailCalling) {
        newCtx.callingContext.push(Tuple!(string, Delegate)(name, &defined));
      }

      result = eval(withBegin(funBody), cast(void**)[newCtx]);

	  // In a tail call, let the loop carry us back.
      if (newCtx.doTailCall == &defined) {
        tailCalling = true;
        parameters = result;
        newCtx.doTailCall = null;
      } else {
        break; // Not in a tail call, we're done a regular function call.
      }
    }

    return result;
  }

  return makeFunctionValue(name, &defined, false);
}
```

NOTE: we can not eliminate mutually recursive tail calls with this
method.

### Implementation 2: Compiling to C


